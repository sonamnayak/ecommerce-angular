{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst buffer_1 = require(\"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n  INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n  INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n  INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n  INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n  INVALID_OFFSET: 'An invalid offset value was provided.',\n  INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n  INVALID_LENGTH: 'An invalid length value was provided.',\n  INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n  INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n  INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n  INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n  INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n  if (!buffer_1.Buffer.isEncoding(encoding)) {\n    throw new Error(ERRORS.INVALID_ENCODING);\n  }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n  return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n  if (typeof value === 'number') {\n    // Check for non finite/non integers\n    if (!isFiniteInteger(value) || value < 0) {\n      throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n    }\n  } else {\n    throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n  }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n  checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n  checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n  if (offset < 0 || offset > buff.length) {\n    throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n  }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n  return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n  if (typeof BigInt === 'undefined') {\n    throw new Error('Platform does not support JS BigInt type.');\n  }\n  if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n    throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n  }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;","map":{"version":3,"names":["Object","defineProperty","exports","value","buffer_1","require","ERRORS","INVALID_ENCODING","INVALID_SMARTBUFFER_SIZE","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","INVALID_OFFSET","INVALID_OFFSET_NON_NUMBER","INVALID_LENGTH","INVALID_LENGTH_NON_NUMBER","INVALID_TARGET_OFFSET","INVALID_TARGET_LENGTH","INVALID_READ_BEYOND_BOUNDS","INVALID_WRITE_BEYOND_BOUNDS","checkEncoding","encoding","Buffer","isEncoding","Error","isFiniteInteger","isFinite","isInteger","checkOffsetOrLengthValue","offset","checkLengthValue","length","checkOffsetValue","checkTargetOffset","buff","Math","floor","bigIntAndBufferInt64Check","bufferMethod","BigInt","prototype"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/smart-buffer/build/utils.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst buffer_1 = require(\"buffer\");\n/**\n * Error strings\n */\nconst ERRORS = {\n    INVALID_ENCODING: 'Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.',\n    INVALID_SMARTBUFFER_SIZE: 'Invalid size provided. Size must be a valid integer greater than zero.',\n    INVALID_SMARTBUFFER_BUFFER: 'Invalid Buffer provided in SmartBufferOptions.',\n    INVALID_SMARTBUFFER_OBJECT: 'Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.',\n    INVALID_OFFSET: 'An invalid offset value was provided.',\n    INVALID_OFFSET_NON_NUMBER: 'An invalid offset value was provided. A numeric value is required.',\n    INVALID_LENGTH: 'An invalid length value was provided.',\n    INVALID_LENGTH_NON_NUMBER: 'An invalid length value was provived. A numeric value is required.',\n    INVALID_TARGET_OFFSET: 'Target offset is beyond the bounds of the internal SmartBuffer data.',\n    INVALID_TARGET_LENGTH: 'Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.',\n    INVALID_READ_BEYOND_BOUNDS: 'Attempted to read beyond the bounds of the managed data.',\n    INVALID_WRITE_BEYOND_BOUNDS: 'Attempted to write beyond the bounds of the managed data.'\n};\nexports.ERRORS = ERRORS;\n/**\n * Checks if a given encoding is a valid Buffer encoding. (Throws an exception if check fails)\n *\n * @param { String } encoding The encoding string to check.\n */\nfunction checkEncoding(encoding) {\n    if (!buffer_1.Buffer.isEncoding(encoding)) {\n        throw new Error(ERRORS.INVALID_ENCODING);\n    }\n}\nexports.checkEncoding = checkEncoding;\n/**\n * Checks if a given number is a finite integer. (Throws an exception if check fails)\n *\n * @param { Number } value The number value to check.\n */\nfunction isFiniteInteger(value) {\n    return typeof value === 'number' && isFinite(value) && isInteger(value);\n}\nexports.isFiniteInteger = isFiniteInteger;\n/**\n * Checks if an offset/length value is valid. (Throws an exception if check fails)\n *\n * @param value The value to check.\n * @param offset True if checking an offset, false if checking a length.\n */\nfunction checkOffsetOrLengthValue(value, offset) {\n    if (typeof value === 'number') {\n        // Check for non finite/non integers\n        if (!isFiniteInteger(value) || value < 0) {\n            throw new Error(offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH);\n        }\n    }\n    else {\n        throw new Error(offset ? ERRORS.INVALID_OFFSET_NON_NUMBER : ERRORS.INVALID_LENGTH_NON_NUMBER);\n    }\n}\n/**\n * Checks if a length value is valid. (Throws an exception if check fails)\n *\n * @param { Number } length The value to check.\n */\nfunction checkLengthValue(length) {\n    checkOffsetOrLengthValue(length, false);\n}\nexports.checkLengthValue = checkLengthValue;\n/**\n * Checks if a offset value is valid. (Throws an exception if check fails)\n *\n * @param { Number } offset The value to check.\n */\nfunction checkOffsetValue(offset) {\n    checkOffsetOrLengthValue(offset, true);\n}\nexports.checkOffsetValue = checkOffsetValue;\n/**\n * Checks if a target offset value is out of bounds. (Throws an exception if check fails)\n *\n * @param { Number } offset The offset value to check.\n * @param { SmartBuffer } buff The SmartBuffer instance to check against.\n */\nfunction checkTargetOffset(offset, buff) {\n    if (offset < 0 || offset > buff.length) {\n        throw new Error(ERRORS.INVALID_TARGET_OFFSET);\n    }\n}\nexports.checkTargetOffset = checkTargetOffset;\n/**\n * Determines whether a given number is a integer.\n * @param value The number to check.\n */\nfunction isInteger(value) {\n    return typeof value === 'number' && isFinite(value) && Math.floor(value) === value;\n}\n/**\n * Throws if Node.js version is too low to support bigint\n */\nfunction bigIntAndBufferInt64Check(bufferMethod) {\n    if (typeof BigInt === 'undefined') {\n        throw new Error('Platform does not support JS BigInt type.');\n    }\n    if (typeof buffer_1.Buffer.prototype[bufferMethod] === 'undefined') {\n        throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);\n    }\n}\nexports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}