{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst util = require('util');\nconst crypto = require('crypto');\nconst fs = require('@npmcli/fs');\nconst Minipass = require('minipass');\nconst path = require('path');\nconst ssri = require('ssri');\nconst uniqueFilename = require('unique-filename');\nconst contentPath = require('./content/path');\nconst fixOwner = require('./util/fix-owner');\nconst hashToSegments = require('./util/hash-to-segments');\nconst indexV = require('../package.json')['cache-version'].index;\nconst moveFile = require('@npmcli/move-file');\nconst _rimraf = require('rimraf');\nconst rimraf = util.promisify(_rimraf);\nrimraf.sync = _rimraf.sync;\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor(cache, key) {\n    super(`No cache entry for ${key} found in ${cache}`);\n    this.code = 'ENOENT';\n    this.cache = cache;\n    this.key = key;\n  }\n};\nmodule.exports.compact = compact;\nfunction compact(_x, _x2, _x3) {\n  return _compact.apply(this, arguments);\n}\nfunction _compact() {\n  _compact = _asyncToGenerator(function* (cache, key, matchFn, opts = {}) {\n    const bucket = bucketPath(cache, key);\n    const entries = yield bucketEntries(bucket);\n    const newEntries = [];\n    // we loop backwards because the bottom-most result is the newest\n    // since we add new entries with appendFile\n    for (let i = entries.length - 1; i >= 0; --i) {\n      const entry = entries[i];\n      // a null integrity could mean either a delete was appended\n      // or the user has simply stored an index that does not map\n      // to any content. we determine if the user wants to keep the\n      // null integrity based on the validateEntry function passed in options.\n      // if the integrity is null and no validateEntry is provided, we break\n      // as we consider the null integrity to be a deletion of everything\n      // that came before it.\n      if (entry.integrity === null && !opts.validateEntry) {\n        break;\n      }\n\n      // if this entry is valid, and it is either the first entry or\n      // the newEntries array doesn't already include an entry that\n      // matches this one based on the provided matchFn, then we add\n      // it to the beginning of our list\n      if ((!opts.validateEntry || opts.validateEntry(entry) === true) && (newEntries.length === 0 || !newEntries.find(oldEntry => matchFn(oldEntry, entry)))) {\n        newEntries.unshift(entry);\n      }\n    }\n    const newIndex = '\\n' + newEntries.map(entry => {\n      const stringified = JSON.stringify(entry);\n      const hash = hashEntry(stringified);\n      return `${hash}\\t${stringified}`;\n    }).join('\\n');\n    const setup = /*#__PURE__*/function () {\n      var _ref5 = _asyncToGenerator(function* () {\n        const target = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n        yield fixOwner.mkdirfix(cache, path.dirname(target));\n        return {\n          target,\n          moved: false\n        };\n      });\n      return function setup() {\n        return _ref5.apply(this, arguments);\n      };\n    }();\n    const teardown = /*#__PURE__*/function () {\n      var _ref6 = _asyncToGenerator(function* (tmp) {\n        if (!tmp.moved) {\n          return rimraf(tmp.target);\n        }\n      });\n      return function teardown(_x15) {\n        return _ref6.apply(this, arguments);\n      };\n    }();\n    const write = /*#__PURE__*/function () {\n      var _ref7 = _asyncToGenerator(function* (tmp) {\n        yield fs.writeFile(tmp.target, newIndex, {\n          flag: 'wx'\n        });\n        yield fixOwner.mkdirfix(cache, path.dirname(bucket));\n        // we use @npmcli/move-file directly here because we\n        // want to overwrite the existing file\n        yield moveFile(tmp.target, bucket);\n        tmp.moved = true;\n        try {\n          yield fixOwner.chownr(cache, bucket);\n        } catch (err) {\n          if (err.code !== 'ENOENT') {\n            throw err;\n          }\n        }\n      });\n      return function write(_x16) {\n        return _ref7.apply(this, arguments);\n      };\n    }();\n\n    // write the file atomically\n    const tmp = yield setup();\n    try {\n      yield write(tmp);\n    } finally {\n      yield teardown(tmp);\n    }\n\n    // we reverse the list we generated such that the newest\n    // entries come first in order to make looping through them easier\n    // the true passed to formatEntry tells it to keep null\n    // integrity values, if they made it this far it's because\n    // validateEntry returned true, and as such we should return it\n    return newEntries.reverse().map(entry => formatEntry(cache, entry, true));\n  });\n  return _compact.apply(this, arguments);\n}\nmodule.exports.insert = insert;\nfunction insert(_x4, _x5, _x6) {\n  return _insert.apply(this, arguments);\n}\nfunction _insert() {\n  _insert = _asyncToGenerator(function* (cache, key, integrity, opts = {}) {\n    const {\n      metadata,\n      size\n    } = opts;\n    const bucket = bucketPath(cache, key);\n    const entry = {\n      key,\n      integrity: integrity && ssri.stringify(integrity),\n      time: Date.now(),\n      size,\n      metadata\n    };\n    try {\n      yield fixOwner.mkdirfix(cache, path.dirname(bucket));\n      const stringified = JSON.stringify(entry);\n      // NOTE - Cleverness ahoy!\n      //\n      // This works because it's tremendously unlikely for an entry to corrupt\n      // another while still preserving the string length of the JSON in\n      // question. So, we just slap the length in there and verify it on read.\n      //\n      // Thanks to @isaacs for the whiteboarding session that ended up with\n      // this.\n      yield fs.appendFile(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n      yield fixOwner.chownr(cache, bucket);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return undefined;\n      }\n      throw err;\n      // There's a class of race conditions that happen when things get deleted\n      // during fixOwner, or between the two mkdirfix/chownr calls.\n      //\n      // It's perfectly fine to just not bother in those cases and lie\n      // that the index entry was written. Because it's a cache.\n    }\n\n    return formatEntry(cache, entry);\n  });\n  return _insert.apply(this, arguments);\n}\nmodule.exports.insert.sync = insertSync;\nfunction insertSync(cache, key, integrity, opts = {}) {\n  const {\n    metadata,\n    size\n  } = opts;\n  const bucket = bucketPath(cache, key);\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata\n  };\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket));\n  const stringified = JSON.stringify(entry);\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`);\n  try {\n    fixOwner.chownr.sync(cache, bucket);\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err;\n    }\n  }\n  return formatEntry(cache, entry);\n}\nmodule.exports.find = find;\nfunction find(_x7, _x8) {\n  return _find.apply(this, arguments);\n}\nfunction _find() {\n  _find = _asyncToGenerator(function* (cache, key) {\n    const bucket = bucketPath(cache, key);\n    try {\n      const entries = yield bucketEntries(bucket);\n      return entries.reduce((latest, next) => {\n        if (next && next.key === key) {\n          return formatEntry(cache, next);\n        } else {\n          return latest;\n        }\n      }, null);\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        return null;\n      } else {\n        throw err;\n      }\n    }\n  });\n  return _find.apply(this, arguments);\n}\nmodule.exports.find.sync = findSync;\nfunction findSync(cache, key) {\n  const bucket = bucketPath(cache, key);\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next);\n      } else {\n        return latest;\n      }\n    }, null);\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}\nmodule.exports.delete = del;\nfunction del(cache, key, opts = {}) {\n  if (!opts.removeFully) {\n    return insert(cache, key, null, opts);\n  }\n  const bucket = bucketPath(cache, key);\n  return rimraf(bucket);\n}\nmodule.exports.delete.sync = delSync;\nfunction delSync(cache, key, opts = {}) {\n  if (!opts.removeFully) {\n    return insertSync(cache, key, null, opts);\n  }\n  const bucket = bucketPath(cache, key);\n  return rimraf.sync(bucket);\n}\nmodule.exports.lsStream = lsStream;\nfunction lsStream(cache) {\n  const indexDir = bucketDir(cache);\n  const stream = new Minipass({\n    objectMode: true\n  });\n\n  // Set all this up to run on the stream and then just return the stream\n  Promise.resolve().then( /*#__PURE__*/_asyncToGenerator(function* () {\n    const buckets = yield readdirOrEmpty(indexDir);\n    yield Promise.all(buckets.map( /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* (bucket) {\n        const bucketPath = path.join(indexDir, bucket);\n        const subbuckets = yield readdirOrEmpty(bucketPath);\n        yield Promise.all(subbuckets.map( /*#__PURE__*/function () {\n          var _ref3 = _asyncToGenerator(function* (subbucket) {\n            const subbucketPath = path.join(bucketPath, subbucket);\n\n            // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n            const subbucketEntries = yield readdirOrEmpty(subbucketPath);\n            yield Promise.all(subbucketEntries.map( /*#__PURE__*/function () {\n              var _ref4 = _asyncToGenerator(function* (entry) {\n                const entryPath = path.join(subbucketPath, entry);\n                try {\n                  const entries = yield bucketEntries(entryPath);\n                  // using a Map here prevents duplicate keys from showing up\n                  // twice, I guess?\n                  const reduced = entries.reduce((acc, entry) => {\n                    acc.set(entry.key, entry);\n                    return acc;\n                  }, new Map());\n                  // reduced is a map of key => entry\n                  for (const entry of reduced.values()) {\n                    const formatted = formatEntry(cache, entry);\n                    if (formatted) {\n                      stream.write(formatted);\n                    }\n                  }\n                } catch (err) {\n                  if (err.code === 'ENOENT') {\n                    return undefined;\n                  }\n                  throw err;\n                }\n              });\n              return function (_x11) {\n                return _ref4.apply(this, arguments);\n              };\n            }()));\n          });\n          return function (_x10) {\n            return _ref3.apply(this, arguments);\n          };\n        }()));\n      });\n      return function (_x9) {\n        return _ref2.apply(this, arguments);\n      };\n    }()));\n    stream.end();\n    return stream;\n  })).catch(err => stream.emit('error', err));\n  return stream;\n}\nmodule.exports.ls = ls;\nfunction ls(_x12) {\n  return _ls.apply(this, arguments);\n}\nfunction _ls() {\n  _ls = _asyncToGenerator(function* (cache) {\n    const entries = yield lsStream(cache).collect();\n    return entries.reduce((acc, xs) => {\n      acc[xs.key] = xs;\n      return acc;\n    }, {});\n  });\n  return _ls.apply(this, arguments);\n}\nmodule.exports.bucketEntries = bucketEntries;\nfunction bucketEntries(_x13, _x14) {\n  return _bucketEntries2.apply(this, arguments);\n}\nfunction _bucketEntries2() {\n  _bucketEntries2 = _asyncToGenerator(function* (bucket, filter) {\n    const data = yield fs.readFile(bucket, 'utf8');\n    return _bucketEntries(data, filter);\n  });\n  return _bucketEntries2.apply(this, arguments);\n}\nmodule.exports.bucketEntries.sync = bucketEntriesSync;\nfunction bucketEntriesSync(bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8');\n  return _bucketEntries(data, filter);\n}\nfunction _bucketEntries(data, filter) {\n  const entries = [];\n  data.split('\\n').forEach(entry => {\n    if (!entry) {\n      return;\n    }\n    const pieces = entry.split('\\t');\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return;\n    }\n    let obj;\n    try {\n      obj = JSON.parse(pieces[1]);\n    } catch (e) {\n      // Entry is corrupted!\n      return;\n    }\n    if (obj) {\n      entries.push(obj);\n    }\n  });\n  return entries;\n}\nmodule.exports.bucketDir = bucketDir;\nfunction bucketDir(cache) {\n  return path.join(cache, `index-v${indexV}`);\n}\nmodule.exports.bucketPath = bucketPath;\nfunction bucketPath(cache, key) {\n  const hashed = hashKey(key);\n  return path.join.apply(path, [bucketDir(cache)].concat(hashToSegments(hashed)));\n}\nmodule.exports.hashKey = hashKey;\nfunction hashKey(key) {\n  return hash(key, 'sha256');\n}\nmodule.exports.hashEntry = hashEntry;\nfunction hashEntry(str) {\n  return hash(str, 'sha1');\n}\nfunction hash(str, digest) {\n  return crypto.createHash(digest).update(str).digest('hex');\n}\nfunction formatEntry(cache, entry, keepAll) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity && !keepAll) {\n    return null;\n  }\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: entry.integrity ? contentPath(cache, entry.integrity) : undefined,\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata\n  };\n}\nfunction readdirOrEmpty(dir) {\n  return fs.readdir(dir).catch(err => {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n      return [];\n    }\n    throw err;\n  });\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","util","crypto","fs","Minipass","path","ssri","uniqueFilename","contentPath","fixOwner","hashToSegments","indexV","index","moveFile","_rimraf","rimraf","promisify","sync","module","exports","NotFoundError","Error","constructor","cache","key","code","compact","_x","_x2","_x3","_compact","apply","arguments","matchFn","opts","bucket","bucketPath","entries","bucketEntries","newEntries","i","length","entry","integrity","validateEntry","find","oldEntry","unshift","newIndex","map","stringified","JSON","stringify","hash","hashEntry","join","setup","_ref5","target","tmpPrefix","mkdirfix","dirname","moved","teardown","_ref6","tmp","_x15","write","_ref7","writeFile","flag","chownr","err","_x16","reverse","formatEntry","insert","_x4","_x5","_x6","_insert","metadata","size","time","Date","now","appendFile","undefined","insertSync","appendFileSync","_x7","_x8","_find","reduce","latest","next","findSync","bucketEntriesSync","delete","del","removeFully","delSync","lsStream","indexDir","bucketDir","stream","objectMode","Promise","resolve","then","buckets","readdirOrEmpty","all","_ref2","subbuckets","_ref3","subbucket","subbucketPath","subbucketEntries","_ref4","entryPath","reduced","acc","set","Map","values","formatted","_x11","_x10","_x9","end","catch","emit","ls","_x12","_ls","collect","xs","_x13","_x14","_bucketEntries2","filter","data","readFile","_bucketEntries","readFileSync","split","forEach","pieces","obj","parse","e","push","hashed","hashKey","concat","str","digest","createHash","update","keepAll","dir","readdir"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/cacache/lib/entry-index.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\nconst crypto = require('crypto')\nconst fs = require('@npmcli/fs')\nconst Minipass = require('minipass')\nconst path = require('path')\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\n\nconst contentPath = require('./content/path')\nconst fixOwner = require('./util/fix-owner')\nconst hashToSegments = require('./util/hash-to-segments')\nconst indexV = require('../package.json')['cache-version'].index\nconst moveFile = require('@npmcli/move-file')\nconst _rimraf = require('rimraf')\nconst rimraf = util.promisify(_rimraf)\nrimraf.sync = _rimraf.sync\n\nmodule.exports.NotFoundError = class NotFoundError extends Error {\n  constructor (cache, key) {\n    super(`No cache entry for ${key} found in ${cache}`)\n    this.code = 'ENOENT'\n    this.cache = cache\n    this.key = key\n  }\n}\n\nmodule.exports.compact = compact\n\nasync function compact (cache, key, matchFn, opts = {}) {\n  const bucket = bucketPath(cache, key)\n  const entries = await bucketEntries(bucket)\n  const newEntries = []\n  // we loop backwards because the bottom-most result is the newest\n  // since we add new entries with appendFile\n  for (let i = entries.length - 1; i >= 0; --i) {\n    const entry = entries[i]\n    // a null integrity could mean either a delete was appended\n    // or the user has simply stored an index that does not map\n    // to any content. we determine if the user wants to keep the\n    // null integrity based on the validateEntry function passed in options.\n    // if the integrity is null and no validateEntry is provided, we break\n    // as we consider the null integrity to be a deletion of everything\n    // that came before it.\n    if (entry.integrity === null && !opts.validateEntry) {\n      break\n    }\n\n    // if this entry is valid, and it is either the first entry or\n    // the newEntries array doesn't already include an entry that\n    // matches this one based on the provided matchFn, then we add\n    // it to the beginning of our list\n    if ((!opts.validateEntry || opts.validateEntry(entry) === true) &&\n      (newEntries.length === 0 ||\n        !newEntries.find((oldEntry) => matchFn(oldEntry, entry)))) {\n      newEntries.unshift(entry)\n    }\n  }\n\n  const newIndex = '\\n' + newEntries.map((entry) => {\n    const stringified = JSON.stringify(entry)\n    const hash = hashEntry(stringified)\n    return `${hash}\\t${stringified}`\n  }).join('\\n')\n\n  const setup = async () => {\n    const target = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n    await fixOwner.mkdirfix(cache, path.dirname(target))\n    return {\n      target,\n      moved: false,\n    }\n  }\n\n  const teardown = async (tmp) => {\n    if (!tmp.moved) {\n      return rimraf(tmp.target)\n    }\n  }\n\n  const write = async (tmp) => {\n    await fs.writeFile(tmp.target, newIndex, { flag: 'wx' })\n    await fixOwner.mkdirfix(cache, path.dirname(bucket))\n    // we use @npmcli/move-file directly here because we\n    // want to overwrite the existing file\n    await moveFile(tmp.target, bucket)\n    tmp.moved = true\n    try {\n      await fixOwner.chownr(cache, bucket)\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n  }\n\n  // write the file atomically\n  const tmp = await setup()\n  try {\n    await write(tmp)\n  } finally {\n    await teardown(tmp)\n  }\n\n  // we reverse the list we generated such that the newest\n  // entries come first in order to make looping through them easier\n  // the true passed to formatEntry tells it to keep null\n  // integrity values, if they made it this far it's because\n  // validateEntry returned true, and as such we should return it\n  return newEntries.reverse().map((entry) => formatEntry(cache, entry, true))\n}\n\nmodule.exports.insert = insert\n\nasync function insert (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata,\n  }\n  try {\n    await fixOwner.mkdirfix(cache, path.dirname(bucket))\n    const stringified = JSON.stringify(entry)\n    // NOTE - Cleverness ahoy!\n    //\n    // This works because it's tremendously unlikely for an entry to corrupt\n    // another while still preserving the string length of the JSON in\n    // question. So, we just slap the length in there and verify it on read.\n    //\n    // Thanks to @isaacs for the whiteboarding session that ended up with\n    // this.\n    await fs.appendFile(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n    await fixOwner.chownr(cache, bucket)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return undefined\n    }\n\n    throw err\n    // There's a class of race conditions that happen when things get deleted\n    // during fixOwner, or between the two mkdirfix/chownr calls.\n    //\n    // It's perfectly fine to just not bother in those cases and lie\n    // that the index entry was written. Because it's a cache.\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.insert.sync = insertSync\n\nfunction insertSync (cache, key, integrity, opts = {}) {\n  const { metadata, size } = opts\n  const bucket = bucketPath(cache, key)\n  const entry = {\n    key,\n    integrity: integrity && ssri.stringify(integrity),\n    time: Date.now(),\n    size,\n    metadata,\n  }\n  fixOwner.mkdirfix.sync(cache, path.dirname(bucket))\n  const stringified = JSON.stringify(entry)\n  fs.appendFileSync(bucket, `\\n${hashEntry(stringified)}\\t${stringified}`)\n  try {\n    fixOwner.chownr.sync(cache, bucket)\n  } catch (err) {\n    if (err.code !== 'ENOENT') {\n      throw err\n    }\n  }\n  return formatEntry(cache, entry)\n}\n\nmodule.exports.find = find\n\nasync function find (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    const entries = await bucketEntries(bucket)\n    return entries.reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.find.sync = findSync\n\nfunction findSync (cache, key) {\n  const bucket = bucketPath(cache, key)\n  try {\n    return bucketEntriesSync(bucket).reduce((latest, next) => {\n      if (next && next.key === key) {\n        return formatEntry(cache, next)\n      } else {\n        return latest\n      }\n    }, null)\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n\nmodule.exports.delete = del\n\nfunction del (cache, key, opts = {}) {\n  if (!opts.removeFully) {\n    return insert(cache, key, null, opts)\n  }\n\n  const bucket = bucketPath(cache, key)\n  return rimraf(bucket)\n}\n\nmodule.exports.delete.sync = delSync\n\nfunction delSync (cache, key, opts = {}) {\n  if (!opts.removeFully) {\n    return insertSync(cache, key, null, opts)\n  }\n\n  const bucket = bucketPath(cache, key)\n  return rimraf.sync(bucket)\n}\n\nmodule.exports.lsStream = lsStream\n\nfunction lsStream (cache) {\n  const indexDir = bucketDir(cache)\n  const stream = new Minipass({ objectMode: true })\n\n  // Set all this up to run on the stream and then just return the stream\n  Promise.resolve().then(async () => {\n    const buckets = await readdirOrEmpty(indexDir)\n    await Promise.all(buckets.map(async (bucket) => {\n      const bucketPath = path.join(indexDir, bucket)\n      const subbuckets = await readdirOrEmpty(bucketPath)\n      await Promise.all(subbuckets.map(async (subbucket) => {\n        const subbucketPath = path.join(bucketPath, subbucket)\n\n        // \"/cachename/<bucket 0xFF>/<bucket 0xFF>./*\"\n        const subbucketEntries = await readdirOrEmpty(subbucketPath)\n        await Promise.all(subbucketEntries.map(async (entry) => {\n          const entryPath = path.join(subbucketPath, entry)\n          try {\n            const entries = await bucketEntries(entryPath)\n            // using a Map here prevents duplicate keys from showing up\n            // twice, I guess?\n            const reduced = entries.reduce((acc, entry) => {\n              acc.set(entry.key, entry)\n              return acc\n            }, new Map())\n            // reduced is a map of key => entry\n            for (const entry of reduced.values()) {\n              const formatted = formatEntry(cache, entry)\n              if (formatted) {\n                stream.write(formatted)\n              }\n            }\n          } catch (err) {\n            if (err.code === 'ENOENT') {\n              return undefined\n            }\n            throw err\n          }\n        }))\n      }))\n    }))\n    stream.end()\n    return stream\n  }).catch(err => stream.emit('error', err))\n\n  return stream\n}\n\nmodule.exports.ls = ls\n\nasync function ls (cache) {\n  const entries = await lsStream(cache).collect()\n  return entries.reduce((acc, xs) => {\n    acc[xs.key] = xs\n    return acc\n  }, {})\n}\n\nmodule.exports.bucketEntries = bucketEntries\n\nasync function bucketEntries (bucket, filter) {\n  const data = await fs.readFile(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nmodule.exports.bucketEntries.sync = bucketEntriesSync\n\nfunction bucketEntriesSync (bucket, filter) {\n  const data = fs.readFileSync(bucket, 'utf8')\n  return _bucketEntries(data, filter)\n}\n\nfunction _bucketEntries (data, filter) {\n  const entries = []\n  data.split('\\n').forEach((entry) => {\n    if (!entry) {\n      return\n    }\n\n    const pieces = entry.split('\\t')\n    if (!pieces[1] || hashEntry(pieces[1]) !== pieces[0]) {\n      // Hash is no good! Corruption or malice? Doesn't matter!\n      // EJECT EJECT\n      return\n    }\n    let obj\n    try {\n      obj = JSON.parse(pieces[1])\n    } catch (e) {\n      // Entry is corrupted!\n      return\n    }\n    if (obj) {\n      entries.push(obj)\n    }\n  })\n  return entries\n}\n\nmodule.exports.bucketDir = bucketDir\n\nfunction bucketDir (cache) {\n  return path.join(cache, `index-v${indexV}`)\n}\n\nmodule.exports.bucketPath = bucketPath\n\nfunction bucketPath (cache, key) {\n  const hashed = hashKey(key)\n  return path.join.apply(\n    path,\n    [bucketDir(cache)].concat(hashToSegments(hashed))\n  )\n}\n\nmodule.exports.hashKey = hashKey\n\nfunction hashKey (key) {\n  return hash(key, 'sha256')\n}\n\nmodule.exports.hashEntry = hashEntry\n\nfunction hashEntry (str) {\n  return hash(str, 'sha1')\n}\n\nfunction hash (str, digest) {\n  return crypto\n    .createHash(digest)\n    .update(str)\n    .digest('hex')\n}\n\nfunction formatEntry (cache, entry, keepAll) {\n  // Treat null digests as deletions. They'll shadow any previous entries.\n  if (!entry.integrity && !keepAll) {\n    return null\n  }\n\n  return {\n    key: entry.key,\n    integrity: entry.integrity,\n    path: entry.integrity ? contentPath(cache, entry.integrity) : undefined,\n    size: entry.size,\n    time: entry.time,\n    metadata: entry.metadata,\n  }\n}\n\nfunction readdirOrEmpty (dir) {\n  return fs.readdir(dir).catch((err) => {\n    if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {\n      return []\n    }\n\n    throw err\n  })\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}