{"ast":null,"code":"// info about each config option.\n\nvar debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG ? function () {\n  console.error.apply(console, arguments);\n} : function () {};\nvar url = require('url');\nvar path = require('path');\nvar Stream = require('stream').Stream;\nvar abbrev = require('abbrev');\nvar os = require('os');\nmodule.exports = exports = nopt;\nexports.clean = clean;\nexports.typeDefs = {\n  String: {\n    type: String,\n    validate: validateString\n  },\n  Boolean: {\n    type: Boolean,\n    validate: validateBoolean\n  },\n  url: {\n    type: url,\n    validate: validateUrl\n  },\n  Number: {\n    type: Number,\n    validate: validateNumber\n  },\n  path: {\n    type: path,\n    validate: validatePath\n  },\n  Stream: {\n    type: Stream,\n    validate: validateStream\n  },\n  Date: {\n    type: Date,\n    validate: validateDate\n  }\n};\nfunction nopt(types, shorthands, args, slice) {\n  args = args || process.argv;\n  types = types || {};\n  shorthands = shorthands || {};\n  if (typeof slice !== 'number') {\n    slice = 2;\n  }\n  debug(types, shorthands, args, slice);\n  args = args.slice(slice);\n  var data = {};\n  var argv = {\n    remain: [],\n    cooked: args,\n    original: args.slice(0)\n  };\n  parse(args, data, argv.remain, types, shorthands);\n  // now data is full\n  clean(data, types, exports.typeDefs);\n  data.argv = argv;\n  Object.defineProperty(data.argv, 'toString', {\n    value: function () {\n      return this.original.map(JSON.stringify).join(' ');\n    },\n    enumerable: false\n  });\n  return data;\n}\nfunction clean(data, types, typeDefs) {\n  typeDefs = typeDefs || exports.typeDefs;\n  var remove = {};\n  var typeDefault = [false, true, null, String, Array];\n  Object.keys(data).forEach(function (k) {\n    if (k === 'argv') {\n      return;\n    }\n    var val = data[k];\n    var isArray = Array.isArray(val);\n    var type = types[k];\n    if (!isArray) {\n      val = [val];\n    }\n    if (!type) {\n      type = typeDefault;\n    }\n    if (type === Array) {\n      type = typeDefault.concat(Array);\n    }\n    if (!Array.isArray(type)) {\n      type = [type];\n    }\n    debug('val=%j', val);\n    debug('types=', type);\n    val = val.map(function (v) {\n      // if it's an unknown value, then parse false/true/null/numbers/dates\n      if (typeof v === 'string') {\n        debug('string %j', v);\n        v = v.trim();\n        if (v === 'null' && ~type.indexOf(null) || v === 'true' && (~type.indexOf(true) || ~type.indexOf(Boolean)) || v === 'false' && (~type.indexOf(false) || ~type.indexOf(Boolean))) {\n          v = JSON.parse(v);\n          debug('jsonable %j', v);\n        } else if (~type.indexOf(Number) && !isNaN(v)) {\n          debug('convert to number', v);\n          v = +v;\n        } else if (~type.indexOf(Date) && !isNaN(Date.parse(v))) {\n          debug('convert to date', v);\n          v = new Date(v);\n        }\n      }\n      if (!Object.prototype.hasOwnProperty.call(types, k)) {\n        return v;\n      }\n\n      // allow `--no-blah` to set 'blah' to null if null is allowed\n      if (v === false && ~type.indexOf(null) && !(~type.indexOf(false) || ~type.indexOf(Boolean))) {\n        v = null;\n      }\n      var d = {};\n      d[k] = v;\n      debug('prevalidated val', d, v, types[k]);\n      if (!validate(d, k, v, types[k], typeDefs)) {\n        if (exports.invalidHandler) {\n          exports.invalidHandler(k, v, types[k], data);\n        } else if (exports.invalidHandler !== false) {\n          debug('invalid: ' + k + '=' + v, types[k]);\n        }\n        return remove;\n      }\n      debug('validated v', d, v, types[k]);\n      return d[k];\n    }).filter(function (v) {\n      return v !== remove;\n    });\n\n    // if we allow Array specifically, then an empty array is how we\n    // express 'no value here', not null.  Allow it.\n    if (!val.length && type.indexOf(Array) === -1) {\n      debug('VAL HAS NO LENGTH, DELETE IT', val, k, type.indexOf(Array));\n      delete data[k];\n    } else if (isArray) {\n      debug(isArray, data[k], val);\n      data[k] = val;\n    } else {\n      data[k] = val[0];\n    }\n    debug('k=%s val=%j', k, val, data[k]);\n  });\n}\nfunction validateString(data, k, val) {\n  data[k] = String(val);\n}\nfunction validatePath(data, k, val) {\n  if (val === true) {\n    return false;\n  }\n  if (val === null) {\n    return true;\n  }\n  val = String(val);\n  var isWin = process.platform === 'win32';\n  var homePattern = isWin ? /^~(\\/|\\\\)/ : /^~\\//;\n  var home = os.homedir();\n  if (home && val.match(homePattern)) {\n    data[k] = path.resolve(home, val.slice(2));\n  } else {\n    data[k] = path.resolve(val);\n  }\n  return true;\n}\nfunction validateNumber(data, k, val) {\n  debug('validate Number %j %j %j', k, val, isNaN(val));\n  if (isNaN(val)) {\n    return false;\n  }\n  data[k] = +val;\n}\nfunction validateDate(data, k, val) {\n  var s = Date.parse(val);\n  debug('validate Date %j %j %j', k, val, s);\n  if (isNaN(s)) {\n    return false;\n  }\n  data[k] = new Date(val);\n}\nfunction validateBoolean(data, k, val) {\n  if (val instanceof Boolean) {\n    val = val.valueOf();\n  } else if (typeof val === 'string') {\n    if (!isNaN(val)) {\n      val = !!+val;\n    } else if (val === 'null' || val === 'false') {\n      val = false;\n    } else {\n      val = true;\n    }\n  } else {\n    val = !!val;\n  }\n  data[k] = val;\n}\nfunction validateUrl(data, k, val) {\n  // Changing this would be a breaking change in the npm cli\n  /* eslint-disable-next-line node/no-deprecated-api */\n  val = url.parse(String(val));\n  if (!val.host) {\n    return false;\n  }\n  data[k] = val.href;\n}\nfunction validateStream(data, k, val) {\n  if (!(val instanceof Stream)) {\n    return false;\n  }\n  data[k] = val;\n}\nfunction validate(data, k, val, type, typeDefs) {\n  // arrays are lists of types.\n  if (Array.isArray(type)) {\n    for (let i = 0, l = type.length; i < l; i++) {\n      if (type[i] === Array) {\n        continue;\n      }\n      if (validate(data, k, val, type[i], typeDefs)) {\n        return true;\n      }\n    }\n    delete data[k];\n    return false;\n  }\n\n  // an array of anything?\n  if (type === Array) {\n    return true;\n  }\n\n  // Original comment:\n  // NaN is poisonous.  Means that something is not allowed.\n  // New comment: Changing this to an isNaN check breaks a lot of tests.\n  // Something is being assumed here that is not actually what happens in\n  // practice.  Fixing it is outside the scope of getting linting to pass in\n  // this repo. Leaving as-is for now.\n  /* eslint-disable-next-line no-self-compare */\n  if (type !== type) {\n    debug('Poison NaN', k, val, type);\n    delete data[k];\n    return false;\n  }\n\n  // explicit list of values\n  if (val === type) {\n    debug('Explicitly allowed %j', val);\n    // if (isArray) (data[k] = data[k] || []).push(val)\n    // else data[k] = val\n    data[k] = val;\n    return true;\n  }\n\n  // now go through the list of typeDefs, validate against each one.\n  var ok = false;\n  var types = Object.keys(typeDefs);\n  for (let i = 0, l = types.length; i < l; i++) {\n    debug('test type %j %j %j', k, val, types[i]);\n    var t = typeDefs[types[i]];\n    if (t && (type && type.name && t.type && t.type.name ? type.name === t.type.name : type === t.type)) {\n      var d = {};\n      ok = t.validate(d, k, val) !== false;\n      val = d[k];\n      if (ok) {\n        // if (isArray) (data[k] = data[k] || []).push(val)\n        // else data[k] = val\n        data[k] = val;\n        break;\n      }\n    }\n  }\n  debug('OK? %j (%j %j %j)', ok, k, val, types[types.length - 1]);\n  if (!ok) {\n    delete data[k];\n  }\n  return ok;\n}\nfunction parse(args, data, remain, types, shorthands) {\n  debug('parse', args, data, remain);\n  var abbrevs = abbrev(Object.keys(types));\n  var shortAbbr = abbrev(Object.keys(shorthands));\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i];\n    debug('arg', arg);\n    if (arg.match(/^-{2,}$/)) {\n      // done with keys.\n      // the rest are args.\n      remain.push.apply(remain, args.slice(i + 1));\n      args[i] = '--';\n      break;\n    }\n    var hadEq = false;\n    if (arg.charAt(0) === '-' && arg.length > 1) {\n      var at = arg.indexOf('=');\n      if (at > -1) {\n        hadEq = true;\n        var v = arg.slice(at + 1);\n        arg = arg.slice(0, at);\n        args.splice(i, 1, arg, v);\n      }\n\n      // see if it's a shorthand\n      // if so, splice and back up to re-parse it.\n      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs);\n      debug('arg=%j shRes=%j', arg, shRes);\n      if (shRes) {\n        debug(arg, shRes);\n        args.splice.apply(args, [i, 1].concat(shRes));\n        if (arg !== shRes[0]) {\n          i--;\n          continue;\n        }\n      }\n      arg = arg.replace(/^-+/, '');\n      var no = null;\n      while (arg.toLowerCase().indexOf('no-') === 0) {\n        no = !no;\n        arg = arg.slice(3);\n      }\n      if (abbrevs[arg]) {\n        arg = abbrevs[arg];\n      }\n      var argType = types[arg];\n      var isTypeArray = Array.isArray(argType);\n      if (isTypeArray && argType.length === 1) {\n        isTypeArray = false;\n        argType = argType[0];\n      }\n      var isArray = argType === Array || isTypeArray && argType.indexOf(Array) !== -1;\n\n      // allow unknown things to be arrays if specified multiple times.\n      if (!Object.prototype.hasOwnProperty.call(types, arg) && Object.prototype.hasOwnProperty.call(data, arg)) {\n        if (!Array.isArray(data[arg])) {\n          data[arg] = [data[arg]];\n        }\n        isArray = true;\n      }\n      var val;\n      var la = args[i + 1];\n      var isBool = typeof no === 'boolean' || argType === Boolean || isTypeArray && argType.indexOf(Boolean) !== -1 || typeof argType === 'undefined' && !hadEq || la === 'false' && (argType === null || isTypeArray && ~argType.indexOf(null));\n      if (isBool) {\n        // just set and move along\n        val = !no;\n        // however, also support --bool true or --bool false\n        if (la === 'true' || la === 'false') {\n          val = JSON.parse(la);\n          la = null;\n          if (no) {\n            val = !val;\n          }\n          i++;\n        }\n\n        // also support \"foo\":[Boolean, \"bar\"] and \"--foo bar\"\n        if (isTypeArray && la) {\n          if (~argType.indexOf(la)) {\n            // an explicit type\n            val = la;\n            i++;\n          } else if (la === 'null' && ~argType.indexOf(null)) {\n            // null allowed\n            val = null;\n            i++;\n          } else if (!la.match(/^-{2,}[^-]/) && !isNaN(la) && ~argType.indexOf(Number)) {\n            // number\n            val = +la;\n            i++;\n          } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {\n            // string\n            val = la;\n            i++;\n          }\n        }\n        if (isArray) {\n          (data[arg] = data[arg] || []).push(val);\n        } else {\n          data[arg] = val;\n        }\n        continue;\n      }\n      if (argType === String) {\n        if (la === undefined) {\n          la = '';\n        } else if (la.match(/^-{1,2}[^-]+/)) {\n          la = '';\n          i--;\n        }\n      }\n      if (la && la.match(/^-{2,}$/)) {\n        la = undefined;\n        i--;\n      }\n      val = la === undefined ? true : la;\n      if (isArray) {\n        (data[arg] = data[arg] || []).push(val);\n      } else {\n        data[arg] = val;\n      }\n      i++;\n      continue;\n    }\n    remain.push(arg);\n  }\n}\nfunction resolveShort(arg, shorthands, shortAbbr, abbrevs) {\n  // handle single-char shorthands glommed together, like\n  // npm ls -glp, but only if there is one dash, and only if\n  // all of the chars are single-char shorthands, and it's\n  // not a match to some other abbrev.\n  arg = arg.replace(/^-+/, '');\n\n  // if it's an exact known option, then don't go any further\n  if (abbrevs[arg] === arg) {\n    return null;\n  }\n\n  // if it's an exact known shortopt, same deal\n  if (shorthands[arg]) {\n    // make it an array, if it's a list of words\n    if (shorthands[arg] && !Array.isArray(shorthands[arg])) {\n      shorthands[arg] = shorthands[arg].split(/\\s+/);\n    }\n    return shorthands[arg];\n  }\n\n  // first check to see if this arg is a set of single-char shorthands\n  var singles = shorthands.___singles;\n  if (!singles) {\n    singles = Object.keys(shorthands).filter(function (s) {\n      return s.length === 1;\n    }).reduce(function (l, r) {\n      l[r] = true;\n      return l;\n    }, {});\n    shorthands.___singles = singles;\n    debug('shorthand singles', singles);\n  }\n  var chrs = arg.split('').filter(function (c) {\n    return singles[c];\n  });\n  if (chrs.join('') === arg) {\n    return chrs.map(function (c) {\n      return shorthands[c];\n    }).reduce(function (l, r) {\n      return l.concat(r);\n    }, []);\n  }\n\n  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg\n  if (abbrevs[arg] && !shorthands[arg]) {\n    return null;\n  }\n\n  // if it's an abbr for a shorthand, then use that\n  if (shortAbbr[arg]) {\n    arg = shortAbbr[arg];\n  }\n\n  // make it an array, if it's a list of words\n  if (shorthands[arg] && !Array.isArray(shorthands[arg])) {\n    shorthands[arg] = shorthands[arg].split(/\\s+/);\n  }\n  return shorthands[arg];\n}","map":{"version":3,"names":["debug","process","env","DEBUG_NOPT","NOPT_DEBUG","console","error","apply","arguments","url","require","path","Stream","abbrev","os","module","exports","nopt","clean","typeDefs","String","type","validate","validateString","Boolean","validateBoolean","validateUrl","Number","validateNumber","validatePath","validateStream","Date","validateDate","types","shorthands","args","slice","argv","data","remain","cooked","original","parse","Object","defineProperty","value","map","JSON","stringify","join","enumerable","remove","typeDefault","Array","keys","forEach","k","val","isArray","concat","v","trim","indexOf","isNaN","prototype","hasOwnProperty","call","d","invalidHandler","filter","length","isWin","platform","homePattern","home","homedir","match","resolve","s","valueOf","host","href","i","l","ok","t","name","abbrevs","shortAbbr","arg","push","hadEq","charAt","at","splice","shRes","resolveShort","replace","no","toLowerCase","argType","isTypeArray","la","isBool","undefined","split","singles","___singles","reduce","r","chrs","c"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/nopt/lib/nopt.js"],"sourcesContent":["// info about each config option.\n\nvar debug = process.env.DEBUG_NOPT || process.env.NOPT_DEBUG\n  ? function () {\n    console.error.apply(console, arguments)\n  }\n  : function () {}\n\nvar url = require('url')\nvar path = require('path')\nvar Stream = require('stream').Stream\nvar abbrev = require('abbrev')\nvar os = require('os')\n\nmodule.exports = exports = nopt\nexports.clean = clean\n\nexports.typeDefs =\n  { String: { type: String, validate: validateString },\n    Boolean: { type: Boolean, validate: validateBoolean },\n    url: { type: url, validate: validateUrl },\n    Number: { type: Number, validate: validateNumber },\n    path: { type: path, validate: validatePath },\n    Stream: { type: Stream, validate: validateStream },\n    Date: { type: Date, validate: validateDate },\n  }\n\nfunction nopt (types, shorthands, args, slice) {\n  args = args || process.argv\n  types = types || {}\n  shorthands = shorthands || {}\n  if (typeof slice !== 'number') {\n    slice = 2\n  }\n\n  debug(types, shorthands, args, slice)\n\n  args = args.slice(slice)\n  var data = {}\n  var argv = {\n    remain: [],\n    cooked: args,\n    original: args.slice(0),\n  }\n\n  parse(args, data, argv.remain, types, shorthands)\n  // now data is full\n  clean(data, types, exports.typeDefs)\n  data.argv = argv\n  Object.defineProperty(data.argv, 'toString', { value: function () {\n    return this.original.map(JSON.stringify).join(' ')\n  },\n  enumerable: false })\n  return data\n}\n\nfunction clean (data, types, typeDefs) {\n  typeDefs = typeDefs || exports.typeDefs\n  var remove = {}\n  var typeDefault = [false, true, null, String, Array]\n\n  Object.keys(data).forEach(function (k) {\n    if (k === 'argv') {\n      return\n    }\n    var val = data[k]\n    var isArray = Array.isArray(val)\n    var type = types[k]\n    if (!isArray) {\n      val = [val]\n    }\n    if (!type) {\n      type = typeDefault\n    }\n    if (type === Array) {\n      type = typeDefault.concat(Array)\n    }\n    if (!Array.isArray(type)) {\n      type = [type]\n    }\n\n    debug('val=%j', val)\n    debug('types=', type)\n    val = val.map(function (v) {\n      // if it's an unknown value, then parse false/true/null/numbers/dates\n      if (typeof v === 'string') {\n        debug('string %j', v)\n        v = v.trim()\n        if ((v === 'null' && ~type.indexOf(null))\n            || (v === 'true' &&\n               (~type.indexOf(true) || ~type.indexOf(Boolean)))\n            || (v === 'false' &&\n               (~type.indexOf(false) || ~type.indexOf(Boolean)))) {\n          v = JSON.parse(v)\n          debug('jsonable %j', v)\n        } else if (~type.indexOf(Number) && !isNaN(v)) {\n          debug('convert to number', v)\n          v = +v\n        } else if (~type.indexOf(Date) && !isNaN(Date.parse(v))) {\n          debug('convert to date', v)\n          v = new Date(v)\n        }\n      }\n\n      if (!Object.prototype.hasOwnProperty.call(types, k)) {\n        return v\n      }\n\n      // allow `--no-blah` to set 'blah' to null if null is allowed\n      if (v === false && ~type.indexOf(null) &&\n          !(~type.indexOf(false) || ~type.indexOf(Boolean))) {\n        v = null\n      }\n\n      var d = {}\n      d[k] = v\n      debug('prevalidated val', d, v, types[k])\n      if (!validate(d, k, v, types[k], typeDefs)) {\n        if (exports.invalidHandler) {\n          exports.invalidHandler(k, v, types[k], data)\n        } else if (exports.invalidHandler !== false) {\n          debug('invalid: ' + k + '=' + v, types[k])\n        }\n        return remove\n      }\n      debug('validated v', d, v, types[k])\n      return d[k]\n    }).filter(function (v) {\n      return v !== remove\n    })\n\n    // if we allow Array specifically, then an empty array is how we\n    // express 'no value here', not null.  Allow it.\n    if (!val.length && type.indexOf(Array) === -1) {\n      debug('VAL HAS NO LENGTH, DELETE IT', val, k, type.indexOf(Array))\n      delete data[k]\n    } else if (isArray) {\n      debug(isArray, data[k], val)\n      data[k] = val\n    } else {\n      data[k] = val[0]\n    }\n\n    debug('k=%s val=%j', k, val, data[k])\n  })\n}\n\nfunction validateString (data, k, val) {\n  data[k] = String(val)\n}\n\nfunction validatePath (data, k, val) {\n  if (val === true) {\n    return false\n  }\n  if (val === null) {\n    return true\n  }\n\n  val = String(val)\n\n  var isWin = process.platform === 'win32'\n  var homePattern = isWin ? /^~(\\/|\\\\)/ : /^~\\//\n  var home = os.homedir()\n\n  if (home && val.match(homePattern)) {\n    data[k] = path.resolve(home, val.slice(2))\n  } else {\n    data[k] = path.resolve(val)\n  }\n  return true\n}\n\nfunction validateNumber (data, k, val) {\n  debug('validate Number %j %j %j', k, val, isNaN(val))\n  if (isNaN(val)) {\n    return false\n  }\n  data[k] = +val\n}\n\nfunction validateDate (data, k, val) {\n  var s = Date.parse(val)\n  debug('validate Date %j %j %j', k, val, s)\n  if (isNaN(s)) {\n    return false\n  }\n  data[k] = new Date(val)\n}\n\nfunction validateBoolean (data, k, val) {\n  if (val instanceof Boolean) {\n    val = val.valueOf()\n  } else if (typeof val === 'string') {\n    if (!isNaN(val)) {\n      val = !!(+val)\n    } else if (val === 'null' || val === 'false') {\n      val = false\n    } else {\n      val = true\n    }\n  } else {\n    val = !!val\n  }\n  data[k] = val\n}\n\nfunction validateUrl (data, k, val) {\n  // Changing this would be a breaking change in the npm cli\n  /* eslint-disable-next-line node/no-deprecated-api */\n  val = url.parse(String(val))\n  if (!val.host) {\n    return false\n  }\n  data[k] = val.href\n}\n\nfunction validateStream (data, k, val) {\n  if (!(val instanceof Stream)) {\n    return false\n  }\n  data[k] = val\n}\n\nfunction validate (data, k, val, type, typeDefs) {\n  // arrays are lists of types.\n  if (Array.isArray(type)) {\n    for (let i = 0, l = type.length; i < l; i++) {\n      if (type[i] === Array) {\n        continue\n      }\n      if (validate(data, k, val, type[i], typeDefs)) {\n        return true\n      }\n    }\n    delete data[k]\n    return false\n  }\n\n  // an array of anything?\n  if (type === Array) {\n    return true\n  }\n\n  // Original comment:\n  // NaN is poisonous.  Means that something is not allowed.\n  // New comment: Changing this to an isNaN check breaks a lot of tests.\n  // Something is being assumed here that is not actually what happens in\n  // practice.  Fixing it is outside the scope of getting linting to pass in\n  // this repo. Leaving as-is for now.\n  /* eslint-disable-next-line no-self-compare */\n  if (type !== type) {\n    debug('Poison NaN', k, val, type)\n    delete data[k]\n    return false\n  }\n\n  // explicit list of values\n  if (val === type) {\n    debug('Explicitly allowed %j', val)\n    // if (isArray) (data[k] = data[k] || []).push(val)\n    // else data[k] = val\n    data[k] = val\n    return true\n  }\n\n  // now go through the list of typeDefs, validate against each one.\n  var ok = false\n  var types = Object.keys(typeDefs)\n  for (let i = 0, l = types.length; i < l; i++) {\n    debug('test type %j %j %j', k, val, types[i])\n    var t = typeDefs[types[i]]\n    if (t && (\n      (type && type.name && t.type && t.type.name) ?\n        (type.name === t.type.name) :\n        (type === t.type)\n    )) {\n      var d = {}\n      ok = t.validate(d, k, val) !== false\n      val = d[k]\n      if (ok) {\n        // if (isArray) (data[k] = data[k] || []).push(val)\n        // else data[k] = val\n        data[k] = val\n        break\n      }\n    }\n  }\n  debug('OK? %j (%j %j %j)', ok, k, val, types[types.length - 1])\n\n  if (!ok) {\n    delete data[k]\n  }\n  return ok\n}\n\nfunction parse (args, data, remain, types, shorthands) {\n  debug('parse', args, data, remain)\n\n  var abbrevs = abbrev(Object.keys(types))\n  var shortAbbr = abbrev(Object.keys(shorthands))\n\n  for (var i = 0; i < args.length; i++) {\n    var arg = args[i]\n    debug('arg', arg)\n\n    if (arg.match(/^-{2,}$/)) {\n      // done with keys.\n      // the rest are args.\n      remain.push.apply(remain, args.slice(i + 1))\n      args[i] = '--'\n      break\n    }\n    var hadEq = false\n    if (arg.charAt(0) === '-' && arg.length > 1) {\n      var at = arg.indexOf('=')\n      if (at > -1) {\n        hadEq = true\n        var v = arg.slice(at + 1)\n        arg = arg.slice(0, at)\n        args.splice(i, 1, arg, v)\n      }\n\n      // see if it's a shorthand\n      // if so, splice and back up to re-parse it.\n      var shRes = resolveShort(arg, shorthands, shortAbbr, abbrevs)\n      debug('arg=%j shRes=%j', arg, shRes)\n      if (shRes) {\n        debug(arg, shRes)\n        args.splice.apply(args, [i, 1].concat(shRes))\n        if (arg !== shRes[0]) {\n          i--\n          continue\n        }\n      }\n      arg = arg.replace(/^-+/, '')\n      var no = null\n      while (arg.toLowerCase().indexOf('no-') === 0) {\n        no = !no\n        arg = arg.slice(3)\n      }\n\n      if (abbrevs[arg]) {\n        arg = abbrevs[arg]\n      }\n\n      var argType = types[arg]\n      var isTypeArray = Array.isArray(argType)\n      if (isTypeArray && argType.length === 1) {\n        isTypeArray = false\n        argType = argType[0]\n      }\n\n      var isArray = argType === Array ||\n        isTypeArray && argType.indexOf(Array) !== -1\n\n      // allow unknown things to be arrays if specified multiple times.\n      if (\n        !Object.prototype.hasOwnProperty.call(types, arg) &&\n        Object.prototype.hasOwnProperty.call(data, arg)\n      ) {\n        if (!Array.isArray(data[arg])) {\n          data[arg] = [data[arg]]\n        }\n        isArray = true\n      }\n\n      var val\n      var la = args[i + 1]\n\n      var isBool = typeof no === 'boolean' ||\n        argType === Boolean ||\n        isTypeArray && argType.indexOf(Boolean) !== -1 ||\n        (typeof argType === 'undefined' && !hadEq) ||\n        (la === 'false' &&\n         (argType === null ||\n          isTypeArray && ~argType.indexOf(null)))\n\n      if (isBool) {\n        // just set and move along\n        val = !no\n        // however, also support --bool true or --bool false\n        if (la === 'true' || la === 'false') {\n          val = JSON.parse(la)\n          la = null\n          if (no) {\n            val = !val\n          }\n          i++\n        }\n\n        // also support \"foo\":[Boolean, \"bar\"] and \"--foo bar\"\n        if (isTypeArray && la) {\n          if (~argType.indexOf(la)) {\n            // an explicit type\n            val = la\n            i++\n          } else if (la === 'null' && ~argType.indexOf(null)) {\n            // null allowed\n            val = null\n            i++\n          } else if (!la.match(/^-{2,}[^-]/) &&\n                      !isNaN(la) &&\n                      ~argType.indexOf(Number)) {\n            // number\n            val = +la\n            i++\n          } else if (!la.match(/^-[^-]/) && ~argType.indexOf(String)) {\n            // string\n            val = la\n            i++\n          }\n        }\n\n        if (isArray) {\n          (data[arg] = data[arg] || []).push(val)\n        } else {\n          data[arg] = val\n        }\n\n        continue\n      }\n\n      if (argType === String) {\n        if (la === undefined) {\n          la = ''\n        } else if (la.match(/^-{1,2}[^-]+/)) {\n          la = ''\n          i--\n        }\n      }\n\n      if (la && la.match(/^-{2,}$/)) {\n        la = undefined\n        i--\n      }\n\n      val = la === undefined ? true : la\n      if (isArray) {\n        (data[arg] = data[arg] || []).push(val)\n      } else {\n        data[arg] = val\n      }\n\n      i++\n      continue\n    }\n    remain.push(arg)\n  }\n}\n\nfunction resolveShort (arg, shorthands, shortAbbr, abbrevs) {\n  // handle single-char shorthands glommed together, like\n  // npm ls -glp, but only if there is one dash, and only if\n  // all of the chars are single-char shorthands, and it's\n  // not a match to some other abbrev.\n  arg = arg.replace(/^-+/, '')\n\n  // if it's an exact known option, then don't go any further\n  if (abbrevs[arg] === arg) {\n    return null\n  }\n\n  // if it's an exact known shortopt, same deal\n  if (shorthands[arg]) {\n    // make it an array, if it's a list of words\n    if (shorthands[arg] && !Array.isArray(shorthands[arg])) {\n      shorthands[arg] = shorthands[arg].split(/\\s+/)\n    }\n\n    return shorthands[arg]\n  }\n\n  // first check to see if this arg is a set of single-char shorthands\n  var singles = shorthands.___singles\n  if (!singles) {\n    singles = Object.keys(shorthands).filter(function (s) {\n      return s.length === 1\n    }).reduce(function (l, r) {\n      l[r] = true\n      return l\n    }, {})\n    shorthands.___singles = singles\n    debug('shorthand singles', singles)\n  }\n\n  var chrs = arg.split('').filter(function (c) {\n    return singles[c]\n  })\n\n  if (chrs.join('') === arg) {\n    return chrs.map(function (c) {\n      return shorthands[c]\n    }).reduce(function (l, r) {\n      return l.concat(r)\n    }, [])\n  }\n\n  // if it's an arg abbrev, and not a literal shorthand, then prefer the arg\n  if (abbrevs[arg] && !shorthands[arg]) {\n    return null\n  }\n\n  // if it's an abbr for a shorthand, then use that\n  if (shortAbbr[arg]) {\n    arg = shortAbbr[arg]\n  }\n\n  // make it an array, if it's a list of words\n  if (shorthands[arg] && !Array.isArray(shorthands[arg])) {\n    shorthands[arg] = shorthands[arg].split(/\\s+/)\n  }\n\n  return shorthands[arg]\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}