{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n  /**\n   * Creates a new SmartBuffer instance.\n   *\n   * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n   */\n  constructor(options) {\n    this.length = 0;\n    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n    this._writeOffset = 0;\n    this._readOffset = 0;\n    if (SmartBuffer.isSmartBufferOptions(options)) {\n      // Checks for encoding\n      if (options.encoding) {\n        utils_1.checkEncoding(options.encoding);\n        this._encoding = options.encoding;\n      }\n      // Checks for initial size length\n      if (options.size) {\n        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n          this._buff = Buffer.allocUnsafe(options.size);\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n        }\n        // Check for initial Buffer\n      } else if (options.buff) {\n        if (Buffer.isBuffer(options.buff)) {\n          this._buff = options.buff;\n          this.length = options.buff.length;\n        } else {\n          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n        }\n      } else {\n        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n      }\n    } else {\n      // If something was passed but it's not a SmartBufferOptions object\n      if (typeof options !== 'undefined') {\n        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n      }\n      // Otherwise default to sane options\n      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n    }\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n   *\n   * @param size { Number } The size of the internal Buffer.\n   * @param encoding { String } The BufferEncoding to use for strings.\n   *\n   * @return { SmartBuffer }\n   */\n  static fromSize(size, encoding) {\n    return new this({\n      size: size,\n      encoding: encoding\n    });\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n   *\n   * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n   * @param encoding { String } The BufferEncoding to use for strings.\n   *\n   * @return { SmartBuffer }\n   */\n  static fromBuffer(buff, encoding) {\n    return new this({\n      buff: buff,\n      encoding: encoding\n    });\n  }\n  /**\n   * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n   *\n   * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n   */\n  static fromOptions(options) {\n    return new this(options);\n  }\n  /**\n   * Type checking function that determines if an object is a SmartBufferOptions object.\n   */\n  static isSmartBufferOptions(options) {\n    const castOptions = options;\n    return castOptions && (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined);\n  }\n  // Signed integers\n  /**\n   * Reads an Int8 value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n  }\n  /**\n   * Reads an Int16BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n  }\n  /**\n   * Reads an Int16LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n  }\n  /**\n   * Reads an Int32BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n  }\n  /**\n   * Reads an Int32LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n  }\n  /**\n   * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n  readBigInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n  }\n  /**\n   * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n  readBigInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n  }\n  /**\n   * Writes an Int8 value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeInt8(value, offset) {\n    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    return this;\n  }\n  /**\n   * Inserts an Int8 value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n  }\n  /**\n   * Writes an Int16BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\n   * Inserts an Int16BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n  }\n  /**\n   * Writes an Int16LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\n   * Inserts an Int16LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n  }\n  /**\n   * Writes an Int32BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\n   * Inserts an Int32BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n  }\n  /**\n   * Writes an Int32LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\n   * Inserts an Int32LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n  }\n  /**\n   * Writes a BigInt64BE value to the current write position (or at optional offset).\n   *\n   * @param value { BigInt } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigInt64BE value at the given offset value.\n   *\n   * @param value { BigInt } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertBigInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n  }\n  /**\n   * Writes a BigInt64LE value to the current write position (or at optional offset).\n   *\n   * @param value { BigInt } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  }\n  /**\n   * Inserts a Int64LE value at the given offset value.\n   *\n   * @param value { BigInt } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertBigInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n  }\n  // Unsigned Integers\n  /**\n   * Reads an UInt8 value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readUInt8(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n  }\n  /**\n   * Reads an UInt16BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readUInt16BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n  }\n  /**\n   * Reads an UInt16LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readUInt16LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n  }\n  /**\n   * Reads an UInt32BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readUInt32BE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n  }\n  /**\n   * Reads an UInt32LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readUInt32LE(offset) {\n    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n  }\n  /**\n   * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n  readBigUInt64BE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n  }\n  /**\n   * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { BigInt }\n   */\n  readBigUInt64LE(offset) {\n    utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n  }\n  /**\n   * Writes an UInt8 value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeUInt8(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\n   * Inserts an UInt8 value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertUInt8(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n  }\n  /**\n   * Writes an UInt16BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeUInt16BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\n   * Inserts an UInt16BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertUInt16BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n  }\n  /**\n   * Writes an UInt16LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeUInt16LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\n   * Inserts an UInt16LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertUInt16LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n  }\n  /**\n   * Writes an UInt32BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeUInt32BE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\n   * Inserts an UInt32BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertUInt32BE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n  }\n  /**\n   * Writes an UInt32LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeUInt32LE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\n   * Inserts an UInt32LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertUInt32LE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n  }\n  /**\n   * Writes a BigUInt64BE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigUInt64BE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertBigUInt64BE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n  }\n  /**\n   * Writes a BigUInt64LE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  }\n  /**\n   * Inserts a BigUInt64LE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertBigUInt64LE(value, offset) {\n    utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n  }\n  // Floating Point\n  /**\n   * Reads an FloatBE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readFloatBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n  }\n  /**\n   * Reads an FloatLE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readFloatLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n  }\n  /**\n   * Writes a FloatBE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeFloatBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\n   * Inserts a FloatBE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertFloatBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n  }\n  /**\n   * Writes a FloatLE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeFloatLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  }\n  /**\n   * Inserts a FloatLE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertFloatLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n  }\n  // Double Floating Point\n  /**\n   * Reads an DoublEBE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readDoubleBE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n  }\n  /**\n   * Reads an DoubleLE value from the current read position or an optionally provided offset.\n   *\n   * @param offset { Number } The offset to read data from (optional)\n   * @return { Number }\n   */\n  readDoubleLE(offset) {\n    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n  }\n  /**\n   * Writes a DoubleBE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeDoubleBE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\n   * Inserts a DoubleBE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertDoubleBE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n  }\n  /**\n   * Writes a DoubleLE value to the current write position (or at optional offset).\n   *\n   * @param value { Number } The value to write.\n   * @param offset { Number } The offset to write the value at.\n   *\n   * @return this\n   */\n  writeDoubleLE(value, offset) {\n    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  }\n  /**\n   * Inserts a DoubleLE value at the given offset value.\n   *\n   * @param value { Number } The value to insert.\n   * @param offset { Number } The offset to insert the value at.\n   *\n   * @return this\n   */\n  insertDoubleLE(value, offset) {\n    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n  }\n  // Strings\n  /**\n   * Reads a String from the current read position.\n   *\n   * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n   *             the string (Defaults to instance level encoding).\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n   *\n   * @return { String }\n   */\n  readString(arg1, encoding) {\n    let lengthVal;\n    // Length provided\n    if (typeof arg1 === 'number') {\n      utils_1.checkLengthValue(arg1);\n      lengthVal = Math.min(arg1, this.length - this._readOffset);\n    } else {\n      encoding = arg1;\n      lengthVal = this.length - this._readOffset;\n    }\n    // Check encoding\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    }\n    const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n    this._readOffset += lengthVal;\n    return value;\n  }\n  /**\n   * Inserts a String\n   *\n   * @param value { String } The String value to insert.\n   * @param offset { Number } The offset to insert the string at.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n  insertString(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleString(value, true, offset, encoding);\n  }\n  /**\n   * Writes a String\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n  writeString(value, arg2, encoding) {\n    return this._handleString(value, false, arg2, encoding);\n  }\n  /**\n   * Reads a null-terminated String from the current read position.\n   *\n   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n   *\n   * @return { String }\n   */\n  readStringNT(encoding) {\n    if (typeof encoding !== 'undefined') {\n      utils_1.checkEncoding(encoding);\n    }\n    // Set null character position to the end SmartBuffer instance.\n    let nullPos = this.length;\n    // Find next null character (if one is not found, default from above is used)\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    }\n    // Read string value\n    const value = this._buff.slice(this._readOffset, nullPos);\n    // Increment internal Buffer read offset\n    this._readOffset = nullPos + 1;\n    return value.toString(encoding || this._encoding);\n  }\n  /**\n   * Inserts a null-terminated String.\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n  insertStringNT(value, offset, encoding) {\n    utils_1.checkOffsetValue(offset);\n    // Write Values\n    this.insertString(value, offset, encoding);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\n   * Writes a null-terminated String.\n   *\n   * @param value { String } The String value to write.\n   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   *\n   * @return this\n   */\n  writeStringNT(value, arg2, encoding) {\n    // Write Values\n    this.writeString(value, arg2, encoding);\n    this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n    return this;\n  }\n  // Buffers\n  /**\n   * Reads a Buffer from the internal read position.\n   *\n   * @param length { Number } The length of data to read as a Buffer.\n   *\n   * @return { Buffer }\n   */\n  readBuffer(length) {\n    if (typeof length !== 'undefined') {\n      utils_1.checkLengthValue(length);\n    }\n    const lengthVal = typeof length === 'number' ? length : this.length;\n    const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n    // Read buffer value\n    const value = this._buff.slice(this._readOffset, endPoint);\n    // Increment internal Buffer read offset\n    this._readOffset = endPoint;\n    return value;\n  }\n  /**\n   * Writes a Buffer to the current write position.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n  insertBuffer(value, offset) {\n    utils_1.checkOffsetValue(offset);\n    return this._handleBuffer(value, true, offset);\n  }\n  /**\n   * Writes a Buffer to the current write position.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n  writeBuffer(value, offset) {\n    return this._handleBuffer(value, false, offset);\n  }\n  /**\n   * Reads a null-terminated Buffer from the current read poisiton.\n   *\n   * @return { Buffer }\n   */\n  readBufferNT() {\n    // Set null character position to the end SmartBuffer instance.\n    let nullPos = this.length;\n    // Find next null character (if one is not found, default from above is used)\n    for (let i = this._readOffset; i < this.length; i++) {\n      if (this._buff[i] === 0x00) {\n        nullPos = i;\n        break;\n      }\n    }\n    // Read value\n    const value = this._buff.slice(this._readOffset, nullPos);\n    // Increment internal Buffer read offset\n    this._readOffset = nullPos + 1;\n    return value;\n  }\n  /**\n   * Inserts a null-terminated Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n  insertBufferNT(value, offset) {\n    utils_1.checkOffsetValue(offset);\n    // Write Values\n    this.insertBuffer(value, offset);\n    this.insertUInt8(0x00, offset + value.length);\n    return this;\n  }\n  /**\n   * Writes a null-terminated Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   *\n   * @return this\n   */\n  writeBufferNT(value, offset) {\n    // Checks for valid numberic value;\n    if (typeof offset !== 'undefined') {\n      utils_1.checkOffsetValue(offset);\n    }\n    // Write Values\n    this.writeBuffer(value, offset);\n    this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n    return this;\n  }\n  /**\n   * Clears the SmartBuffer instance to its original empty state.\n   */\n  clear() {\n    this._writeOffset = 0;\n    this._readOffset = 0;\n    this.length = 0;\n    return this;\n  }\n  /**\n   * Gets the remaining data left to be read from the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n  remaining() {\n    return this.length - this._readOffset;\n  }\n  /**\n   * Gets the current read offset value of the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n  get readOffset() {\n    return this._readOffset;\n  }\n  /**\n   * Sets the read offset value of the SmartBuffer instance.\n   *\n   * @param offset { Number } - The offset value to set.\n   */\n  set readOffset(offset) {\n    utils_1.checkOffsetValue(offset);\n    // Check for bounds.\n    utils_1.checkTargetOffset(offset, this);\n    this._readOffset = offset;\n  }\n  /**\n   * Gets the current write offset value of the SmartBuffer instance.\n   *\n   * @return { Number }\n   */\n  get writeOffset() {\n    return this._writeOffset;\n  }\n  /**\n   * Sets the write offset value of the SmartBuffer instance.\n   *\n   * @param offset { Number } - The offset value to set.\n   */\n  set writeOffset(offset) {\n    utils_1.checkOffsetValue(offset);\n    // Check for bounds.\n    utils_1.checkTargetOffset(offset, this);\n    this._writeOffset = offset;\n  }\n  /**\n   * Gets the currently set string encoding of the SmartBuffer instance.\n   *\n   * @return { BufferEncoding } The string Buffer encoding currently set.\n   */\n  get encoding() {\n    return this._encoding;\n  }\n  /**\n   * Sets the string encoding of the SmartBuffer instance.\n   *\n   * @param encoding { BufferEncoding } The string Buffer encoding to set.\n   */\n  set encoding(encoding) {\n    utils_1.checkEncoding(encoding);\n    this._encoding = encoding;\n  }\n  /**\n   * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n   *\n   * @return { Buffer } The Buffer value.\n   */\n  get internalBuffer() {\n    return this._buff;\n  }\n  /**\n   * Gets the value of the internal managed Buffer (Includes managed data only)\n   *\n   * @param { Buffer }\n   */\n  toBuffer() {\n    return this._buff.slice(0, this.length);\n  }\n  /**\n   * Gets the String value of the internal managed Buffer\n   *\n   * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n   */\n  toString(encoding) {\n    const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n    // Check for invalid encoding.\n    utils_1.checkEncoding(encodingVal);\n    return this._buff.toString(encodingVal, 0, this.length);\n  }\n  /**\n   * Destroys the SmartBuffer instance.\n   */\n  destroy() {\n    this.clear();\n    return this;\n  }\n  /**\n   * Handles inserting and writing strings.\n   *\n   * @param value { String } The String value to insert.\n   * @param isInsert { Boolean } True if inserting a string, false if writing.\n   * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n   */\n  _handleString(value, isInsert, arg3, encoding) {\n    let offsetVal = this._writeOffset;\n    let encodingVal = this._encoding;\n    // Check for offset\n    if (typeof arg3 === 'number') {\n      offsetVal = arg3;\n      // Check for encoding\n    } else if (typeof arg3 === 'string') {\n      utils_1.checkEncoding(arg3);\n      encodingVal = arg3;\n    }\n    // Check for encoding (third param)\n    if (typeof encoding === 'string') {\n      utils_1.checkEncoding(encoding);\n      encodingVal = encoding;\n    }\n    // Calculate bytelength of string.\n    const byteLength = Buffer.byteLength(value, encodingVal);\n    // Ensure there is enough internal Buffer capacity.\n    if (isInsert) {\n      this.ensureInsertable(byteLength, offsetVal);\n    } else {\n      this._ensureWriteable(byteLength, offsetVal);\n    }\n    // Write value\n    this._buff.write(value, offsetVal, byteLength, encodingVal);\n    // Increment internal Buffer write offset;\n    if (isInsert) {\n      this._writeOffset += byteLength;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof arg3 === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += byteLength;\n      }\n    }\n    return this;\n  }\n  /**\n   * Handles writing or insert of a Buffer.\n   *\n   * @param value { Buffer } The Buffer to write.\n   * @param offset { Number } The offset to write the Buffer to.\n   */\n  _handleBuffer(value, isInsert, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n    // Ensure there is enough internal Buffer capacity.\n    if (isInsert) {\n      this.ensureInsertable(value.length, offsetVal);\n    } else {\n      this._ensureWriteable(value.length, offsetVal);\n    }\n    // Write buffer value\n    value.copy(this._buff, offsetVal);\n    // Increment internal Buffer write offset;\n    if (isInsert) {\n      this._writeOffset += value.length;\n    } else {\n      // If an offset was given, check to see if we wrote beyond the current writeOffset.\n      if (typeof offset === 'number') {\n        this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n      } else {\n        // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n        this._writeOffset += value.length;\n      }\n    }\n    return this;\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to read data.\n   *\n   * @param length { Number } The length of the data that needs to be read.\n   * @param offset { Number } The offset of the data that needs to be read.\n   */\n  ensureReadable(length, offset) {\n    // Offset value defaults to managed read offset.\n    let offsetVal = this._readOffset;\n    // If an offset was provided, use it.\n    if (typeof offset !== 'undefined') {\n      // Checks for valid numberic value;\n      utils_1.checkOffsetValue(offset);\n      // Overide with custom offset.\n      offsetVal = offset;\n    }\n    // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n    if (offsetVal < 0 || offsetVal + length > this.length) {\n      throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to insert data.\n   *\n   * @param dataLength { Number } The length of the data that needs to be written.\n   * @param offset { Number } The offset of the data to be written.\n   */\n  ensureInsertable(dataLength, offset) {\n    // Checks for valid numberic value;\n    utils_1.checkOffsetValue(offset);\n    // Ensure there is enough internal Buffer capacity.\n    this._ensureCapacity(this.length + dataLength);\n    // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n    if (offset < this.length) {\n      this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n    }\n    // Adjust tracked smart buffer length\n    if (offset + dataLength > this.length) {\n      this.length = offset + dataLength;\n    } else {\n      this.length += dataLength;\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to write data.\n   *\n   * @param dataLength { Number } The length of the data that needs to be written.\n   * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n   */\n  _ensureWriteable(dataLength, offset) {\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n    // Ensure enough capacity to write data.\n    this._ensureCapacity(offsetVal + dataLength);\n    // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n    if (offsetVal + dataLength > this.length) {\n      this.length = offsetVal + dataLength;\n    }\n  }\n  /**\n   * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n   *\n   * @param minLength { Number } The minimum length of the data needs to be written.\n   */\n  _ensureCapacity(minLength) {\n    const oldLength = this._buff.length;\n    if (minLength > oldLength) {\n      let data = this._buff;\n      let newLength = oldLength * 3 / 2 + 1;\n      if (newLength < minLength) {\n        newLength = minLength;\n      }\n      this._buff = Buffer.allocUnsafe(newLength);\n      data.copy(this._buff, 0, 0, oldLength);\n    }\n  }\n  /**\n   * Reads a numeric number value using the provided function.\n   *\n   * @typeparam T { number | bigint } The type of the value to be read\n   *\n   * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes read.\n   * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n   *\n   * @returns { T } the number value\n   */\n  _readNumberValue(func, byteSize, offset) {\n    this.ensureReadable(byteSize, offset);\n    // Call Buffer.readXXXX();\n    const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n    // Adjust internal read offset if an optional read offset was not provided.\n    if (typeof offset === 'undefined') {\n      this._readOffset += byteSize;\n    }\n    return value;\n  }\n  /**\n   * Inserts a numeric number value based on the given offset and value.\n   *\n   * @typeparam T { number | bigint } The type of the value to be written\n   *\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes written.\n   * @param value { T } The number value to write.\n   * @param offset { Number } the offset to write the number at (REQUIRED).\n   *\n   * @returns SmartBuffer this buffer\n   */\n  _insertNumberValue(func, byteSize, value, offset) {\n    // Check for invalid offset values.\n    utils_1.checkOffsetValue(offset);\n    // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n    this.ensureInsertable(byteSize, offset);\n    // Call buffer.writeXXXX();\n    func.call(this._buff, value, offset);\n    // Adjusts internally managed write offset.\n    this._writeOffset += byteSize;\n    return this;\n  }\n  /**\n   * Writes a numeric number value based on the given offset and value.\n   *\n   * @typeparam T { number | bigint } The type of the value to be written\n   *\n   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n   * @param byteSize { Number } The number of bytes written.\n   * @param value { T } The number value to write.\n   * @param offset { Number } the offset to write the number at (REQUIRED).\n   *\n   * @returns SmartBuffer this buffer\n   */\n  _writeNumberValue(func, byteSize, value, offset) {\n    // If an offset was provided, validate it.\n    if (typeof offset === 'number') {\n      // Check if we're writing beyond the bounds of the managed data.\n      if (offset < 0) {\n        throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n      }\n      utils_1.checkOffsetValue(offset);\n    }\n    // Default to writeOffset if no offset value was given.\n    const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n    // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n    this._ensureWriteable(byteSize, offsetVal);\n    func.call(this._buff, value, offsetVal);\n    // If an offset was given, check to see if we wrote beyond the current writeOffset.\n    if (typeof offset === 'number') {\n      this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n    } else {\n      // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n      this._writeOffset += byteSize;\n    }\n    return this;\n  }\n}\nexports.SmartBuffer = SmartBuffer;","map":{"version":3,"names":["Object","defineProperty","exports","value","utils_1","require","DEFAULT_SMARTBUFFER_SIZE","DEFAULT_SMARTBUFFER_ENCODING","SmartBuffer","constructor","options","length","_encoding","_writeOffset","_readOffset","isSmartBufferOptions","encoding","checkEncoding","size","isFiniteInteger","_buff","Buffer","allocUnsafe","Error","ERRORS","INVALID_SMARTBUFFER_SIZE","buff","isBuffer","INVALID_SMARTBUFFER_BUFFER","INVALID_SMARTBUFFER_OBJECT","fromSize","fromBuffer","fromOptions","castOptions","undefined","readInt8","offset","_readNumberValue","prototype","readInt16BE","readInt16LE","readInt32BE","readInt32LE","readBigInt64BE","bigIntAndBufferInt64Check","readBigInt64LE","writeInt8","_writeNumberValue","insertInt8","_insertNumberValue","writeInt16BE","insertInt16BE","writeInt16LE","insertInt16LE","writeInt32BE","insertInt32BE","writeInt32LE","insertInt32LE","writeBigInt64BE","insertBigInt64BE","writeBigInt64LE","insertBigInt64LE","readUInt8","readUInt16BE","readUInt16LE","readUInt32BE","readUInt32LE","readBigUInt64BE","readBigUInt64LE","writeUInt8","insertUInt8","writeUInt16BE","insertUInt16BE","writeUInt16LE","insertUInt16LE","writeUInt32BE","insertUInt32BE","writeUInt32LE","insertUInt32LE","writeBigUInt64BE","insertBigUInt64BE","writeBigUInt64LE","insertBigUInt64LE","readFloatBE","readFloatLE","writeFloatBE","insertFloatBE","writeFloatLE","insertFloatLE","readDoubleBE","readDoubleLE","writeDoubleBE","insertDoubleBE","writeDoubleLE","insertDoubleLE","readString","arg1","lengthVal","checkLengthValue","Math","min","slice","toString","insertString","checkOffsetValue","_handleString","writeString","arg2","readStringNT","nullPos","i","insertStringNT","writeStringNT","writeOffset","readBuffer","endPoint","insertBuffer","_handleBuffer","writeBuffer","readBufferNT","insertBufferNT","writeBufferNT","clear","remaining","readOffset","checkTargetOffset","internalBuffer","toBuffer","encodingVal","destroy","isInsert","arg3","offsetVal","byteLength","ensureInsertable","_ensureWriteable","write","max","copy","ensureReadable","INVALID_READ_BEYOND_BOUNDS","dataLength","_ensureCapacity","minLength","oldLength","data","newLength","func","byteSize","call","INVALID_WRITE_BEYOND_BOUNDS"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/smart-buffer/build/smartbuffer.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst utils_1 = require(\"./utils\");\n// The default Buffer size if one is not provided.\nconst DEFAULT_SMARTBUFFER_SIZE = 4096;\n// The default string encoding to use for reading/writing strings.\nconst DEFAULT_SMARTBUFFER_ENCODING = 'utf8';\nclass SmartBuffer {\n    /**\n     * Creates a new SmartBuffer instance.\n     *\n     * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.\n     */\n    constructor(options) {\n        this.length = 0;\n        this._encoding = DEFAULT_SMARTBUFFER_ENCODING;\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        if (SmartBuffer.isSmartBufferOptions(options)) {\n            // Checks for encoding\n            if (options.encoding) {\n                utils_1.checkEncoding(options.encoding);\n                this._encoding = options.encoding;\n            }\n            // Checks for initial size length\n            if (options.size) {\n                if (utils_1.isFiniteInteger(options.size) && options.size > 0) {\n                    this._buff = Buffer.allocUnsafe(options.size);\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);\n                }\n                // Check for initial Buffer\n            }\n            else if (options.buff) {\n                if (Buffer.isBuffer(options.buff)) {\n                    this._buff = options.buff;\n                    this.length = options.buff.length;\n                }\n                else {\n                    throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);\n                }\n            }\n            else {\n                this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n            }\n        }\n        else {\n            // If something was passed but it's not a SmartBufferOptions object\n            if (typeof options !== 'undefined') {\n                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);\n            }\n            // Otherwise default to sane options\n            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);\n        }\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.\n     *\n     * @param size { Number } The size of the internal Buffer.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromSize(size, encoding) {\n        return new this({\n            size: size,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.\n     *\n     * @param buffer { Buffer } The Buffer to use as the internal Buffer value.\n     * @param encoding { String } The BufferEncoding to use for strings.\n     *\n     * @return { SmartBuffer }\n     */\n    static fromBuffer(buff, encoding) {\n        return new this({\n            buff: buff,\n            encoding: encoding\n        });\n    }\n    /**\n     * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.\n     *\n     * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.\n     */\n    static fromOptions(options) {\n        return new this(options);\n    }\n    /**\n     * Type checking function that determines if an object is a SmartBufferOptions object.\n     */\n    static isSmartBufferOptions(options) {\n        const castOptions = options;\n        return (castOptions &&\n            (castOptions.encoding !== undefined || castOptions.size !== undefined || castOptions.buff !== undefined));\n    }\n    // Signed integers\n    /**\n     * Reads an Int8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);\n    }\n    /**\n     * Reads an Int16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);\n    }\n    /**\n     * Reads an Int16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);\n    }\n    /**\n     * Reads an Int32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);\n    }\n    /**\n     * Reads an Int32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);\n    }\n    /**\n     * Writes an Int8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt8(value, offset) {\n        this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n        return this;\n    }\n    /**\n     * Inserts an Int8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value, offset);\n    }\n    /**\n     * Writes an Int16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an Int16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an Int16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an Int32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an Int32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an Int32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigInt64BE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { BigInt } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a Int64LE value at the given offset value.\n     *\n     * @param value { BigInt } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value, offset);\n    }\n    // Unsigned Integers\n    /**\n     * Reads an UInt8 value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt8(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);\n    }\n    /**\n     * Reads an UInt16BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);\n    }\n    /**\n     * Reads an UInt16LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt16LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);\n    }\n    /**\n     * Reads an UInt32BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32BE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);\n    }\n    /**\n     * Reads an UInt32LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readUInt32LE(offset) {\n        return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);\n    }\n    /**\n     * Reads a BigUInt64BE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64BE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64BE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);\n    }\n    /**\n     * Reads a BigUInt64LE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { BigInt }\n     */\n    readBigUInt64LE(offset) {\n        utils_1.bigIntAndBufferInt64Check('readBigUInt64LE');\n        return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);\n    }\n    /**\n     * Writes an UInt8 value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt8(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Inserts an UInt8 value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt8(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value, offset);\n    }\n    /**\n     * Writes an UInt16BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt16LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt16LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Inserts an UInt16LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt16LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value, offset);\n    }\n    /**\n     * Writes an UInt32BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32BE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32BE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value, offset);\n    }\n    /**\n     * Writes an UInt32LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeUInt32LE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Inserts an UInt32LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertUInt32LE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value, offset);\n    }\n    /**\n     * Writes a BigUInt64BE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64BE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64BE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64BE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value, offset);\n    }\n    /**\n     * Writes a BigUInt64LE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    /**\n     * Inserts a BigUInt64LE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertBigUInt64LE(value, offset) {\n        utils_1.bigIntAndBufferInt64Check('writeBigUInt64LE');\n        return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value, offset);\n    }\n    // Floating Point\n    /**\n     * Reads an FloatBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);\n    }\n    /**\n     * Reads an FloatLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readFloatLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);\n    }\n    /**\n     * Writes a FloatBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value, offset);\n    }\n    /**\n     * Writes a FloatLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeFloatLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    /**\n     * Inserts a FloatLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertFloatLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value, offset);\n    }\n    // Double Floating Point\n    /**\n     * Reads an DoublEBE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleBE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);\n    }\n    /**\n     * Reads an DoubleLE value from the current read position or an optionally provided offset.\n     *\n     * @param offset { Number } The offset to read data from (optional)\n     * @return { Number }\n     */\n    readDoubleLE(offset) {\n        return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);\n    }\n    /**\n     * Writes a DoubleBE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleBE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleBE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleBE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value, offset);\n    }\n    /**\n     * Writes a DoubleLE value to the current write position (or at optional offset).\n     *\n     * @param value { Number } The value to write.\n     * @param offset { Number } The offset to write the value at.\n     *\n     * @return this\n     */\n    writeDoubleLE(value, offset) {\n        return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    /**\n     * Inserts a DoubleLE value at the given offset value.\n     *\n     * @param value { Number } The value to insert.\n     * @param offset { Number } The offset to insert the value at.\n     *\n     * @return this\n     */\n    insertDoubleLE(value, offset) {\n        return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value, offset);\n    }\n    // Strings\n    /**\n     * Reads a String from the current read position.\n     *\n     * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for\n     *             the string (Defaults to instance level encoding).\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readString(arg1, encoding) {\n        let lengthVal;\n        // Length provided\n        if (typeof arg1 === 'number') {\n            utils_1.checkLengthValue(arg1);\n            lengthVal = Math.min(arg1, this.length - this._readOffset);\n        }\n        else {\n            encoding = arg1;\n            lengthVal = this.length - this._readOffset;\n        }\n        // Check encoding\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        const value = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding || this._encoding);\n        this._readOffset += lengthVal;\n        return value;\n    }\n    /**\n     * Inserts a String\n     *\n     * @param value { String } The String value to insert.\n     * @param offset { Number } The offset to insert the string at.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertString(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleString(value, true, offset, encoding);\n    }\n    /**\n     * Writes a String\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeString(value, arg2, encoding) {\n        return this._handleString(value, false, arg2, encoding);\n    }\n    /**\n     * Reads a null-terminated String from the current read position.\n     *\n     * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).\n     *\n     * @return { String }\n     */\n    readStringNT(encoding) {\n        if (typeof encoding !== 'undefined') {\n            utils_1.checkEncoding(encoding);\n        }\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read string value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value.toString(encoding || this._encoding);\n    }\n    /**\n     * Inserts a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    insertStringNT(value, offset, encoding) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertString(value, offset, encoding);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated String.\n     *\n     * @param value { String } The String value to write.\n     * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     *\n     * @return this\n     */\n    writeStringNT(value, arg2, encoding) {\n        // Write Values\n        this.writeString(value, arg2, encoding);\n        this.writeUInt8(0x00, typeof arg2 === 'number' ? arg2 + value.length : this.writeOffset);\n        return this;\n    }\n    // Buffers\n    /**\n     * Reads a Buffer from the internal read position.\n     *\n     * @param length { Number } The length of data to read as a Buffer.\n     *\n     * @return { Buffer }\n     */\n    readBuffer(length) {\n        if (typeof length !== 'undefined') {\n            utils_1.checkLengthValue(length);\n        }\n        const lengthVal = typeof length === 'number' ? length : this.length;\n        const endPoint = Math.min(this.length, this._readOffset + lengthVal);\n        // Read buffer value\n        const value = this._buff.slice(this._readOffset, endPoint);\n        // Increment internal Buffer read offset\n        this._readOffset = endPoint;\n        return value;\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBuffer(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        return this._handleBuffer(value, true, offset);\n    }\n    /**\n     * Writes a Buffer to the current write position.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBuffer(value, offset) {\n        return this._handleBuffer(value, false, offset);\n    }\n    /**\n     * Reads a null-terminated Buffer from the current read poisiton.\n     *\n     * @return { Buffer }\n     */\n    readBufferNT() {\n        // Set null character position to the end SmartBuffer instance.\n        let nullPos = this.length;\n        // Find next null character (if one is not found, default from above is used)\n        for (let i = this._readOffset; i < this.length; i++) {\n            if (this._buff[i] === 0x00) {\n                nullPos = i;\n                break;\n            }\n        }\n        // Read value\n        const value = this._buff.slice(this._readOffset, nullPos);\n        // Increment internal Buffer read offset\n        this._readOffset = nullPos + 1;\n        return value;\n    }\n    /**\n     * Inserts a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    insertBufferNT(value, offset) {\n        utils_1.checkOffsetValue(offset);\n        // Write Values\n        this.insertBuffer(value, offset);\n        this.insertUInt8(0x00, offset + value.length);\n        return this;\n    }\n    /**\n     * Writes a null-terminated Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     *\n     * @return this\n     */\n    writeBufferNT(value, offset) {\n        // Checks for valid numberic value;\n        if (typeof offset !== 'undefined') {\n            utils_1.checkOffsetValue(offset);\n        }\n        // Write Values\n        this.writeBuffer(value, offset);\n        this.writeUInt8(0x00, typeof offset === 'number' ? offset + value.length : this._writeOffset);\n        return this;\n    }\n    /**\n     * Clears the SmartBuffer instance to its original empty state.\n     */\n    clear() {\n        this._writeOffset = 0;\n        this._readOffset = 0;\n        this.length = 0;\n        return this;\n    }\n    /**\n     * Gets the remaining data left to be read from the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    remaining() {\n        return this.length - this._readOffset;\n    }\n    /**\n     * Gets the current read offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get readOffset() {\n        return this._readOffset;\n    }\n    /**\n     * Sets the read offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set readOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._readOffset = offset;\n    }\n    /**\n     * Gets the current write offset value of the SmartBuffer instance.\n     *\n     * @return { Number }\n     */\n    get writeOffset() {\n        return this._writeOffset;\n    }\n    /**\n     * Sets the write offset value of the SmartBuffer instance.\n     *\n     * @param offset { Number } - The offset value to set.\n     */\n    set writeOffset(offset) {\n        utils_1.checkOffsetValue(offset);\n        // Check for bounds.\n        utils_1.checkTargetOffset(offset, this);\n        this._writeOffset = offset;\n    }\n    /**\n     * Gets the currently set string encoding of the SmartBuffer instance.\n     *\n     * @return { BufferEncoding } The string Buffer encoding currently set.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Sets the string encoding of the SmartBuffer instance.\n     *\n     * @param encoding { BufferEncoding } The string Buffer encoding to set.\n     */\n    set encoding(encoding) {\n        utils_1.checkEncoding(encoding);\n        this._encoding = encoding;\n    }\n    /**\n     * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)\n     *\n     * @return { Buffer } The Buffer value.\n     */\n    get internalBuffer() {\n        return this._buff;\n    }\n    /**\n     * Gets the value of the internal managed Buffer (Includes managed data only)\n     *\n     * @param { Buffer }\n     */\n    toBuffer() {\n        return this._buff.slice(0, this.length);\n    }\n    /**\n     * Gets the String value of the internal managed Buffer\n     *\n     * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).\n     */\n    toString(encoding) {\n        const encodingVal = typeof encoding === 'string' ? encoding : this._encoding;\n        // Check for invalid encoding.\n        utils_1.checkEncoding(encodingVal);\n        return this._buff.toString(encodingVal, 0, this.length);\n    }\n    /**\n     * Destroys the SmartBuffer instance.\n     */\n    destroy() {\n        this.clear();\n        return this;\n    }\n    /**\n     * Handles inserting and writing strings.\n     *\n     * @param value { String } The String value to insert.\n     * @param isInsert { Boolean } True if inserting a string, false if writing.\n     * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.\n     * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).\n     */\n    _handleString(value, isInsert, arg3, encoding) {\n        let offsetVal = this._writeOffset;\n        let encodingVal = this._encoding;\n        // Check for offset\n        if (typeof arg3 === 'number') {\n            offsetVal = arg3;\n            // Check for encoding\n        }\n        else if (typeof arg3 === 'string') {\n            utils_1.checkEncoding(arg3);\n            encodingVal = arg3;\n        }\n        // Check for encoding (third param)\n        if (typeof encoding === 'string') {\n            utils_1.checkEncoding(encoding);\n            encodingVal = encoding;\n        }\n        // Calculate bytelength of string.\n        const byteLength = Buffer.byteLength(value, encodingVal);\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(byteLength, offsetVal);\n        }\n        else {\n            this._ensureWriteable(byteLength, offsetVal);\n        }\n        // Write value\n        this._buff.write(value, offsetVal, byteLength, encodingVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += byteLength;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof arg3 === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += byteLength;\n            }\n        }\n        return this;\n    }\n    /**\n     * Handles writing or insert of a Buffer.\n     *\n     * @param value { Buffer } The Buffer to write.\n     * @param offset { Number } The offset to write the Buffer to.\n     */\n    _handleBuffer(value, isInsert, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity.\n        if (isInsert) {\n            this.ensureInsertable(value.length, offsetVal);\n        }\n        else {\n            this._ensureWriteable(value.length, offsetVal);\n        }\n        // Write buffer value\n        value.copy(this._buff, offsetVal);\n        // Increment internal Buffer write offset;\n        if (isInsert) {\n            this._writeOffset += value.length;\n        }\n        else {\n            // If an offset was given, check to see if we wrote beyond the current writeOffset.\n            if (typeof offset === 'number') {\n                this._writeOffset = Math.max(this._writeOffset, offsetVal + value.length);\n            }\n            else {\n                // If no offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n                this._writeOffset += value.length;\n            }\n        }\n        return this;\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to read data.\n     *\n     * @param length { Number } The length of the data that needs to be read.\n     * @param offset { Number } The offset of the data that needs to be read.\n     */\n    ensureReadable(length, offset) {\n        // Offset value defaults to managed read offset.\n        let offsetVal = this._readOffset;\n        // If an offset was provided, use it.\n        if (typeof offset !== 'undefined') {\n            // Checks for valid numberic value;\n            utils_1.checkOffsetValue(offset);\n            // Overide with custom offset.\n            offsetVal = offset;\n        }\n        // Checks if offset is below zero, or the offset+length offset is beyond the total length of the managed data.\n        if (offsetVal < 0 || offsetVal + length > this.length) {\n            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to insert data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written.\n     */\n    ensureInsertable(dataLength, offset) {\n        // Checks for valid numberic value;\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity.\n        this._ensureCapacity(this.length + dataLength);\n        // If an offset was provided and its not the very end of the buffer, copy data into appropriate location in regards to the offset.\n        if (offset < this.length) {\n            this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);\n        }\n        // Adjust tracked smart buffer length\n        if (offset + dataLength > this.length) {\n            this.length = offset + dataLength;\n        }\n        else {\n            this.length += dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write data.\n     *\n     * @param dataLength { Number } The length of the data that needs to be written.\n     * @param offset { Number } The offset of the data to be written (defaults to writeOffset).\n     */\n    _ensureWriteable(dataLength, offset) {\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure enough capacity to write data.\n        this._ensureCapacity(offsetVal + dataLength);\n        // Adjust SmartBuffer length (if offset + length is larger than managed length, adjust length)\n        if (offsetVal + dataLength > this.length) {\n            this.length = offsetVal + dataLength;\n        }\n    }\n    /**\n     * Ensures that the internal Buffer is large enough to write at least the given amount of data.\n     *\n     * @param minLength { Number } The minimum length of the data needs to be written.\n     */\n    _ensureCapacity(minLength) {\n        const oldLength = this._buff.length;\n        if (minLength > oldLength) {\n            let data = this._buff;\n            let newLength = (oldLength * 3) / 2 + 1;\n            if (newLength < minLength) {\n                newLength = minLength;\n            }\n            this._buff = Buffer.allocUnsafe(newLength);\n            data.copy(this._buff, 0, 0, oldLength);\n        }\n    }\n    /**\n     * Reads a numeric number value using the provided function.\n     *\n     * @typeparam T { number | bigint } The type of the value to be read\n     *\n     * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes read.\n     * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.\n     *\n     * @returns { T } the number value\n     */\n    _readNumberValue(func, byteSize, offset) {\n        this.ensureReadable(byteSize, offset);\n        // Call Buffer.readXXXX();\n        const value = func.call(this._buff, typeof offset === 'number' ? offset : this._readOffset);\n        // Adjust internal read offset if an optional read offset was not provided.\n        if (typeof offset === 'undefined') {\n            this._readOffset += byteSize;\n        }\n        return value;\n    }\n    /**\n     * Inserts a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _insertNumberValue(func, byteSize, value, offset) {\n        // Check for invalid offset values.\n        utils_1.checkOffsetValue(offset);\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this.ensureInsertable(byteSize, offset);\n        // Call buffer.writeXXXX();\n        func.call(this._buff, value, offset);\n        // Adjusts internally managed write offset.\n        this._writeOffset += byteSize;\n        return this;\n    }\n    /**\n     * Writes a numeric number value based on the given offset and value.\n     *\n     * @typeparam T { number | bigint } The type of the value to be written\n     *\n     * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.\n     * @param byteSize { Number } The number of bytes written.\n     * @param value { T } The number value to write.\n     * @param offset { Number } the offset to write the number at (REQUIRED).\n     *\n     * @returns SmartBuffer this buffer\n     */\n    _writeNumberValue(func, byteSize, value, offset) {\n        // If an offset was provided, validate it.\n        if (typeof offset === 'number') {\n            // Check if we're writing beyond the bounds of the managed data.\n            if (offset < 0) {\n                throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);\n            }\n            utils_1.checkOffsetValue(offset);\n        }\n        // Default to writeOffset if no offset value was given.\n        const offsetVal = typeof offset === 'number' ? offset : this._writeOffset;\n        // Ensure there is enough internal Buffer capacity. (raw offset is passed)\n        this._ensureWriteable(byteSize, offsetVal);\n        func.call(this._buff, value, offsetVal);\n        // If an offset was given, check to see if we wrote beyond the current writeOffset.\n        if (typeof offset === 'number') {\n            this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);\n        }\n        else {\n            // If no numeric offset was given, we wrote to the end of the SmartBuffer so increment writeOffset.\n            this._writeOffset += byteSize;\n        }\n        return this;\n    }\n}\nexports.SmartBuffer = SmartBuffer;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}