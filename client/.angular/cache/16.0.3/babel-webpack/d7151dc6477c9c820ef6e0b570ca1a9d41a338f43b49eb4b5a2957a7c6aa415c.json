{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst fs = require('graceful-fs');\nconst os = require('os');\nconst tar = require('tar');\nconst path = require('path');\nconst util = require('util');\nconst stream = require('stream');\nconst crypto = require('crypto');\nconst log = require('npmlog');\nconst semver = require('semver');\nconst fetch = require('make-fetch-happen');\nconst processRelease = require('./process-release');\nconst win = process.platform === 'win32';\nconst streamPipeline = util.promisify(stream.pipeline);\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\nfunction install(_x, _x2, _x3) {\n  return _install.apply(this, arguments);\n}\nfunction _install() {\n  _install = _asyncToGenerator(function* (fs, gyp, argv) {\n    const release = processRelease(argv, gyp, process.version, process.release);\n\n    // Determine which node dev files version we are installing\n    log.verbose('install', 'input version string %j', release.version);\n    if (!release.semver) {\n      // could not parse the version string with semver\n      throw new Error('Invalid version number: ' + release.version);\n    }\n    if (semver.lt(release.version, '0.8.0')) {\n      throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version);\n    }\n\n    // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n    if (release.semver.prerelease[0] === 'pre') {\n      log.verbose('detected \"pre\" node version', release.version);\n      if (!gyp.opts.nodedir) {\n        throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead');\n      }\n      log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir);\n      return;\n    }\n\n    // flatten version into String\n    log.verbose('install', 'installing version: %s', release.versionDir);\n\n    // the directory where the dev files will be installed\n    const devDir = path.resolve(gyp.devDir, release.versionDir);\n\n    // If '--ensure' was passed, then don't *always* install the version;\n    // check if it is already installed, and only install when needed\n    if (gyp.opts.ensure) {\n      log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed');\n      try {\n        yield fs.promises.stat(devDir);\n      } catch (err) {\n        if (err.code === 'ENOENT') {\n          log.verbose('install', 'version not already installed, continuing with install', release.version);\n          try {\n            return yield go();\n          } catch (err) {\n            return rollback(err);\n          }\n        } else if (err.code === 'EACCES') {\n          return eaccesFallback(err);\n        }\n        throw err;\n      }\n      log.verbose('install', 'version is already installed, need to check \"installVersion\"');\n      const installVersionFile = path.resolve(devDir, 'installVersion');\n      let installVersion = 0;\n      try {\n        const ver = yield fs.promises.readFile(installVersionFile, 'ascii');\n        installVersion = parseInt(ver, 10) || 0;\n      } catch (err) {\n        if (err.code !== 'ENOENT') {\n          throw err;\n        }\n      }\n      log.verbose('got \"installVersion\"', installVersion);\n      log.verbose('needs \"installVersion\"', gyp.package.installVersion);\n      if (installVersion < gyp.package.installVersion) {\n        log.verbose('install', 'version is no good; reinstalling');\n        try {\n          return yield go();\n        } catch (err) {\n          return rollback(err);\n        }\n      }\n      log.verbose('install', 'version is good');\n    } else {\n      try {\n        return yield go();\n      } catch (err) {\n        return rollback(err);\n      }\n    }\n    function go() {\n      return _go.apply(this, arguments);\n    } // go()\n    /**\n     * Checks if a given filename is \"valid\" for this installation.\n     */\n    function _go() {\n      _go = _asyncToGenerator(function* () {\n        log.verbose('ensuring nodedir is created', devDir);\n\n        // first create the dir for the node dev files\n        try {\n          const created = yield fs.promises.mkdir(devDir, {\n            recursive: true\n          });\n          if (created) {\n            log.verbose('created nodedir', created);\n          }\n        } catch (err) {\n          if (err.code === 'EACCES') {\n            return eaccesFallback(err);\n          }\n          throw err;\n        }\n\n        // now download the node tarball\n        const tarPath = gyp.opts.tarball;\n        let extractCount = 0;\n        const contentShasums = {};\n        const expectShasums = {};\n\n        // checks if a file to be extracted from the tarball is valid.\n        // only .h header files and the gyp files get extracted\n        function isValid(path) {\n          const isValid = valid(path);\n          if (isValid) {\n            log.verbose('extracted file from tarball', path);\n            extractCount++;\n          } else {\n            // invalid\n            log.silly('ignoring from tarball', path);\n          }\n          return isValid;\n        }\n\n        // download the tarball and extract!\n\n        if (tarPath) {\n          yield tar.extract({\n            file: tarPath,\n            strip: 1,\n            filter: isValid,\n            cwd: devDir\n          });\n        } else {\n          try {\n            const res = yield download(gyp, release.tarballUrl);\n            if (res.status !== 200) {\n              throw new Error(`${res.status} response downloading ${release.tarballUrl}`);\n            }\n            yield streamPipeline(res.body,\n            // content checksum\n            new ShaSum((_, checksum) => {\n              const filename = path.basename(release.tarballUrl).trim();\n              contentShasums[filename] = checksum;\n              log.verbose('content checksum', filename, checksum);\n            }), tar.extract({\n              strip: 1,\n              cwd: devDir,\n              filter: isValid\n            }));\n          } catch (err) {\n            // something went wrong downloading the tarball?\n            if (err.code === 'ENOTFOUND') {\n              throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' + 'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' + 'network settings.');\n            }\n            throw err;\n          }\n        }\n\n        // invoked after the tarball has finished being extracted\n        if (extractCount === 0) {\n          throw new Error('There was a fatal problem while downloading/extracting the tarball');\n        }\n        log.verbose('tarball', 'done parsing tarball');\n        const installVersionPath = path.resolve(devDir, 'installVersion');\n        yield Promise.all([\n        // need to download node.lib\n        ...(win ? downloadNodeLib() : []),\n        // write the \"installVersion\" file\n        fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n        // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n        ...(!tarPath || win ? [downloadShasums()] : [])]);\n        log.verbose('download contents checksum', JSON.stringify(contentShasums));\n        // check content shasums\n        for (const k in contentShasums) {\n          log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k]);\n          if (contentShasums[k] !== expectShasums[k]) {\n            throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k]);\n          }\n        }\n        function downloadShasums() {\n          return _downloadShasums.apply(this, arguments);\n        }\n        function _downloadShasums() {\n          _downloadShasums = _asyncToGenerator(function* () {\n            log.verbose('check download content checksum, need to download `SHASUMS256.txt`...');\n            log.verbose('checksum url', release.shasumsUrl);\n            const res = yield download(gyp, release.shasumsUrl);\n            if (res.status !== 200) {\n              throw new Error(`${res.status}  status code downloading checksum`);\n            }\n            for (const line of (yield res.text()).trim().split('\\n')) {\n              const items = line.trim().split(/\\s+/);\n              if (items.length !== 2) {\n                return;\n              }\n\n              // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n              const name = items[1].replace(/^\\.\\//, '');\n              expectShasums[name] = items[0];\n            }\n            log.verbose('checksum data', JSON.stringify(expectShasums));\n          });\n          return _downloadShasums.apply(this, arguments);\n        }\n        function downloadNodeLib() {\n          log.verbose('on Windows; need to download `' + release.name + '.lib`...');\n          const archs = ['ia32', 'x64', 'arm64'];\n          return archs.map( /*#__PURE__*/function () {\n            var _ref = _asyncToGenerator(function* (arch) {\n              const dir = path.resolve(devDir, arch);\n              const targetLibPath = path.resolve(dir, release.name + '.lib');\n              const {\n                libUrl,\n                libPath\n              } = release[arch];\n              const name = `${arch} ${release.name}.lib`;\n              log.verbose(name, 'dir', dir);\n              log.verbose(name, 'url', libUrl);\n              yield fs.promises.mkdir(dir, {\n                recursive: true\n              });\n              log.verbose('streaming', name, 'to:', targetLibPath);\n              const res = yield download(gyp, libUrl);\n              if (res.status === 403 || res.status === 404) {\n                if (arch === 'arm64') {\n                  // Arm64 is a newer platform on Windows and not all node distributions provide it.\n                  log.verbose(`${name} was not found in ${libUrl}`);\n                } else {\n                  log.warn(`${name} was not found in ${libUrl}`);\n                }\n                return;\n              } else if (res.status !== 200) {\n                throw new Error(`${res.status} status code downloading ${name}`);\n              }\n              return streamPipeline(res.body, new ShaSum((_, checksum) => {\n                contentShasums[libPath] = checksum;\n                log.verbose('content checksum', libPath, checksum);\n              }), fs.createWriteStream(targetLibPath));\n            });\n            return function (_x9) {\n              return _ref.apply(this, arguments);\n            };\n          }());\n        } // downloadNodeLib()\n      });\n      return _go.apply(this, arguments);\n    }\n    function valid(file) {\n      // header files\n      const extname = path.extname(file);\n      return extname === '.h' || extname === '.gypi';\n    }\n    function rollback(_x7) {\n      return _rollback.apply(this, arguments);\n    }\n    /**\n     * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n     * it drops the permissions before invoking any child processes (like\n     * node-gyp). So what happens is the \"nobody\" user doesn't have\n     * permission to create the dev dir. As a fallback, make the tmpdir() be\n     * the dev dir for this installation. This is not ideal, but at least\n     * the compilation will succeed...\n     */\n    function _rollback() {\n      _rollback = _asyncToGenerator(function* (err) {\n        log.warn('install', 'got an error, rolling back install');\n        // roll-back the install if anything went wrong\n        yield util.promisify(gyp.commands.remove)([release.versionDir]);\n        throw err;\n      });\n      return _rollback.apply(this, arguments);\n    }\n    function eaccesFallback(_x8) {\n      return _eaccesFallback.apply(this, arguments);\n    }\n    function _eaccesFallback() {\n      _eaccesFallback = _asyncToGenerator(function* (err) {\n        const noretry = '--node_gyp_internal_noretry';\n        if (argv.indexOf(noretry) !== -1) {\n          throw err;\n        }\n        const tmpdir = os.tmpdir();\n        gyp.devDir = path.resolve(tmpdir, '.node-gyp');\n        let userString = '';\n        try {\n          // os.userInfo can fail on some systems, it's not critical here\n          userString = ` (\"${os.userInfo().username}\")`;\n        } catch (e) {}\n        log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir);\n        log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir);\n        if (process.cwd() === tmpdir) {\n          log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space');\n          gyp.todo.push({\n            name: 'remove',\n            args: argv\n          });\n        }\n        return util.promisify(gyp.commands.install)([noretry].concat(argv));\n      });\n      return _eaccesFallback.apply(this, arguments);\n    }\n  });\n  return _install.apply(this, arguments);\n}\nclass ShaSum extends stream.Transform {\n  constructor(callback) {\n    super();\n    this._callback = callback;\n    this._digester = crypto.createHash('sha256');\n  }\n  _transform(chunk, _, callback) {\n    this._digester.update(chunk);\n    callback(null, chunk);\n  }\n  _flush(callback) {\n    this._callback(null, this._digester.digest('hex'));\n    callback();\n  }\n}\nfunction download(_x4, _x5) {\n  return _download.apply(this, arguments);\n}\nfunction _download() {\n  _download = _asyncToGenerator(function* (gyp, url) {\n    log.http('GET', url);\n    const requestOpts = {\n      headers: {\n        'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n        Connection: 'keep-alive'\n      },\n      proxy: gyp.opts.proxy,\n      noProxy: gyp.opts.noproxy\n    };\n    const cafile = gyp.opts.cafile;\n    if (cafile) {\n      requestOpts.ca = yield readCAFile(cafile);\n    }\n    const res = yield fetch(url, requestOpts);\n    log.http(res.status, res.url);\n    return res;\n  });\n  return _download.apply(this, arguments);\n}\nfunction readCAFile(_x6) {\n  return _readCAFile.apply(this, arguments);\n}\nfunction _readCAFile() {\n  _readCAFile = _asyncToGenerator(function* (filename) {\n    // The CA file can contain multiple certificates so split on certificate\n    // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n    const ca = yield fs.promises.readFile(filename, 'utf8');\n    const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g;\n    return ca.match(re);\n  });\n  return _readCAFile.apply(this, arguments);\n}\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback);\n};\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n};\nmodule.exports.usage = 'Install node development files for the specified node version.';","map":{"version":3,"names":["_asyncToGenerator","require","default","fs","os","tar","path","util","stream","crypto","log","semver","fetch","processRelease","win","process","platform","streamPipeline","promisify","pipeline","install","_x","_x2","_x3","_install","apply","arguments","gyp","argv","release","version","verbose","Error","lt","prerelease","opts","nodedir","versionDir","devDir","resolve","ensure","promises","stat","err","code","go","rollback","eaccesFallback","installVersionFile","installVersion","ver","readFile","parseInt","package","_go","created","mkdir","recursive","tarPath","tarball","extractCount","contentShasums","expectShasums","isValid","valid","silly","extract","file","strip","filter","cwd","res","download","tarballUrl","status","body","ShaSum","_","checksum","filename","basename","trim","installVersionPath","Promise","all","downloadNodeLib","writeFile","downloadShasums","JSON","stringify","k","_downloadShasums","shasumsUrl","line","text","split","items","length","name","replace","archs","map","_ref","arch","dir","targetLibPath","libUrl","libPath","warn","createWriteStream","_x9","extname","_x7","_rollback","commands","remove","_x8","_eaccesFallback","noretry","indexOf","tmpdir","userString","userInfo","username","e","todo","push","args","concat","Transform","constructor","callback","_callback","_digester","createHash","_transform","chunk","update","_flush","digest","_x4","_x5","_download","url","http","requestOpts","headers","Connection","proxy","noProxy","noproxy","cafile","ca","readCAFile","_x6","_readCAFile","re","match","module","exports","then","bind","undefined","test","usage"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/node-gyp/lib/install.js"],"sourcesContent":["'use strict'\n\nconst fs = require('graceful-fs')\nconst os = require('os')\nconst tar = require('tar')\nconst path = require('path')\nconst util = require('util')\nconst stream = require('stream')\nconst crypto = require('crypto')\nconst log = require('npmlog')\nconst semver = require('semver')\nconst fetch = require('make-fetch-happen')\nconst processRelease = require('./process-release')\nconst win = process.platform === 'win32'\nconst streamPipeline = util.promisify(stream.pipeline)\n\n/**\n * @param {typeof import('graceful-fs')} fs\n */\n\nasync function install (fs, gyp, argv) {\n  const release = processRelease(argv, gyp, process.version, process.release)\n\n  // Determine which node dev files version we are installing\n  log.verbose('install', 'input version string %j', release.version)\n\n  if (!release.semver) {\n    // could not parse the version string with semver\n    throw new Error('Invalid version number: ' + release.version)\n  }\n\n  if (semver.lt(release.version, '0.8.0')) {\n    throw new Error('Minimum target version is `0.8.0` or greater. Got: ' + release.version)\n  }\n\n  // 0.x.y-pre versions are not published yet and cannot be installed. Bail.\n  if (release.semver.prerelease[0] === 'pre') {\n    log.verbose('detected \"pre\" node version', release.version)\n    if (!gyp.opts.nodedir) {\n      throw new Error('\"pre\" versions of node cannot be installed, use the --nodedir flag instead')\n    }\n    log.verbose('--nodedir flag was passed; skipping install', gyp.opts.nodedir)\n    return\n  }\n\n  // flatten version into String\n  log.verbose('install', 'installing version: %s', release.versionDir)\n\n  // the directory where the dev files will be installed\n  const devDir = path.resolve(gyp.devDir, release.versionDir)\n\n  // If '--ensure' was passed, then don't *always* install the version;\n  // check if it is already installed, and only install when needed\n  if (gyp.opts.ensure) {\n    log.verbose('install', '--ensure was passed, so won\\'t reinstall if already installed')\n    try {\n      await fs.promises.stat(devDir)\n    } catch (err) {\n      if (err.code === 'ENOENT') {\n        log.verbose('install', 'version not already installed, continuing with install', release.version)\n        try {\n          return await go()\n        } catch (err) {\n          return rollback(err)\n        }\n      } else if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n      throw err\n    }\n    log.verbose('install', 'version is already installed, need to check \"installVersion\"')\n    const installVersionFile = path.resolve(devDir, 'installVersion')\n    let installVersion = 0\n    try {\n      const ver = await fs.promises.readFile(installVersionFile, 'ascii')\n      installVersion = parseInt(ver, 10) || 0\n    } catch (err) {\n      if (err.code !== 'ENOENT') {\n        throw err\n      }\n    }\n    log.verbose('got \"installVersion\"', installVersion)\n    log.verbose('needs \"installVersion\"', gyp.package.installVersion)\n    if (installVersion < gyp.package.installVersion) {\n      log.verbose('install', 'version is no good; reinstalling')\n      try {\n        return await go()\n      } catch (err) {\n        return rollback(err)\n      }\n    }\n    log.verbose('install', 'version is good')\n  } else {\n    try {\n      return await go()\n    } catch (err) {\n      return rollback(err)\n    }\n  }\n\n  async function go () {\n    log.verbose('ensuring nodedir is created', devDir)\n\n    // first create the dir for the node dev files\n    try {\n      const created = await fs.promises.mkdir(devDir, { recursive: true })\n\n      if (created) {\n        log.verbose('created nodedir', created)\n      }\n    } catch (err) {\n      if (err.code === 'EACCES') {\n        return eaccesFallback(err)\n      }\n\n      throw err\n    }\n\n    // now download the node tarball\n    const tarPath = gyp.opts.tarball\n    let extractCount = 0\n    const contentShasums = {}\n    const expectShasums = {}\n\n    // checks if a file to be extracted from the tarball is valid.\n    // only .h header files and the gyp files get extracted\n    function isValid (path) {\n      const isValid = valid(path)\n      if (isValid) {\n        log.verbose('extracted file from tarball', path)\n        extractCount++\n      } else {\n        // invalid\n        log.silly('ignoring from tarball', path)\n      }\n      return isValid\n    }\n\n    // download the tarball and extract!\n\n    if (tarPath) {\n      await tar.extract({\n        file: tarPath,\n        strip: 1,\n        filter: isValid,\n        cwd: devDir\n      })\n    } else {\n      try {\n        const res = await download(gyp, release.tarballUrl)\n\n        if (res.status !== 200) {\n          throw new Error(`${res.status} response downloading ${release.tarballUrl}`)\n        }\n\n        await streamPipeline(\n          res.body,\n          // content checksum\n          new ShaSum((_, checksum) => {\n            const filename = path.basename(release.tarballUrl).trim()\n            contentShasums[filename] = checksum\n            log.verbose('content checksum', filename, checksum)\n          }),\n          tar.extract({\n            strip: 1,\n            cwd: devDir,\n            filter: isValid\n          })\n        )\n      } catch (err) {\n        // something went wrong downloading the tarball?\n        if (err.code === 'ENOTFOUND') {\n          throw new Error('This is most likely not a problem with node-gyp or the package itself and\\n' +\n            'is related to network connectivity. In most cases you are behind a proxy or have bad \\n' +\n            'network settings.')\n        }\n        throw err\n      }\n    }\n\n    // invoked after the tarball has finished being extracted\n    if (extractCount === 0) {\n      throw new Error('There was a fatal problem while downloading/extracting the tarball')\n    }\n\n    log.verbose('tarball', 'done parsing tarball')\n\n    const installVersionPath = path.resolve(devDir, 'installVersion')\n    await Promise.all([\n      // need to download node.lib\n      ...(win ? downloadNodeLib() : []),\n      // write the \"installVersion\" file\n      fs.promises.writeFile(installVersionPath, gyp.package.installVersion + '\\n'),\n      // Only download SHASUMS.txt if we downloaded something in need of SHA verification\n      ...(!tarPath || win ? [downloadShasums()] : [])\n    ])\n\n    log.verbose('download contents checksum', JSON.stringify(contentShasums))\n    // check content shasums\n    for (const k in contentShasums) {\n      log.verbose('validating download checksum for ' + k, '(%s == %s)', contentShasums[k], expectShasums[k])\n      if (contentShasums[k] !== expectShasums[k]) {\n        throw new Error(k + ' local checksum ' + contentShasums[k] + ' not match remote ' + expectShasums[k])\n      }\n    }\n\n    async function downloadShasums () {\n      log.verbose('check download content checksum, need to download `SHASUMS256.txt`...')\n      log.verbose('checksum url', release.shasumsUrl)\n\n      const res = await download(gyp, release.shasumsUrl)\n\n      if (res.status !== 200) {\n        throw new Error(`${res.status}  status code downloading checksum`)\n      }\n\n      for (const line of (await res.text()).trim().split('\\n')) {\n        const items = line.trim().split(/\\s+/)\n        if (items.length !== 2) {\n          return\n        }\n\n        // 0035d18e2dcf9aad669b1c7c07319e17abfe3762  ./node-v0.11.4.tar.gz\n        const name = items[1].replace(/^\\.\\//, '')\n        expectShasums[name] = items[0]\n      }\n\n      log.verbose('checksum data', JSON.stringify(expectShasums))\n    }\n\n    function downloadNodeLib () {\n      log.verbose('on Windows; need to download `' + release.name + '.lib`...')\n      const archs = ['ia32', 'x64', 'arm64']\n      return archs.map(async (arch) => {\n        const dir = path.resolve(devDir, arch)\n        const targetLibPath = path.resolve(dir, release.name + '.lib')\n        const { libUrl, libPath } = release[arch]\n        const name = `${arch} ${release.name}.lib`\n        log.verbose(name, 'dir', dir)\n        log.verbose(name, 'url', libUrl)\n\n        await fs.promises.mkdir(dir, { recursive: true })\n        log.verbose('streaming', name, 'to:', targetLibPath)\n\n        const res = await download(gyp, libUrl)\n\n        if (res.status === 403 || res.status === 404) {\n          if (arch === 'arm64') {\n            // Arm64 is a newer platform on Windows and not all node distributions provide it.\n            log.verbose(`${name} was not found in ${libUrl}`)\n          } else {\n            log.warn(`${name} was not found in ${libUrl}`)\n          }\n          return\n        } else if (res.status !== 200) {\n          throw new Error(`${res.status} status code downloading ${name}`)\n        }\n\n        return streamPipeline(\n          res.body,\n          new ShaSum((_, checksum) => {\n            contentShasums[libPath] = checksum\n            log.verbose('content checksum', libPath, checksum)\n          }),\n          fs.createWriteStream(targetLibPath)\n        )\n      })\n    } // downloadNodeLib()\n  } // go()\n\n  /**\n   * Checks if a given filename is \"valid\" for this installation.\n   */\n\n  function valid (file) {\n    // header files\n    const extname = path.extname(file)\n    return extname === '.h' || extname === '.gypi'\n  }\n\n  async function rollback (err) {\n    log.warn('install', 'got an error, rolling back install')\n    // roll-back the install if anything went wrong\n    await util.promisify(gyp.commands.remove)([release.versionDir])\n    throw err\n  }\n\n  /**\n   * The EACCES fallback is a workaround for npm's `sudo` behavior, where\n   * it drops the permissions before invoking any child processes (like\n   * node-gyp). So what happens is the \"nobody\" user doesn't have\n   * permission to create the dev dir. As a fallback, make the tmpdir() be\n   * the dev dir for this installation. This is not ideal, but at least\n   * the compilation will succeed...\n   */\n\n  async function eaccesFallback (err) {\n    const noretry = '--node_gyp_internal_noretry'\n    if (argv.indexOf(noretry) !== -1) {\n      throw err\n    }\n    const tmpdir = os.tmpdir()\n    gyp.devDir = path.resolve(tmpdir, '.node-gyp')\n    let userString = ''\n    try {\n      // os.userInfo can fail on some systems, it's not critical here\n      userString = ` (\"${os.userInfo().username}\")`\n    } catch (e) {}\n    log.warn('EACCES', 'current user%s does not have permission to access the dev dir \"%s\"', userString, devDir)\n    log.warn('EACCES', 'attempting to reinstall using temporary dev dir \"%s\"', gyp.devDir)\n    if (process.cwd() === tmpdir) {\n      log.verbose('tmpdir == cwd', 'automatically will remove dev files after to save disk space')\n      gyp.todo.push({ name: 'remove', args: argv })\n    }\n    return util.promisify(gyp.commands.install)([noretry].concat(argv))\n  }\n}\n\nclass ShaSum extends stream.Transform {\n  constructor (callback) {\n    super()\n    this._callback = callback\n    this._digester = crypto.createHash('sha256')\n  }\n\n  _transform (chunk, _, callback) {\n    this._digester.update(chunk)\n    callback(null, chunk)\n  }\n\n  _flush (callback) {\n    this._callback(null, this._digester.digest('hex'))\n    callback()\n  }\n}\n\nasync function download (gyp, url) {\n  log.http('GET', url)\n\n  const requestOpts = {\n    headers: {\n      'User-Agent': `node-gyp v${gyp.version} (node ${process.version})`,\n      Connection: 'keep-alive'\n    },\n    proxy: gyp.opts.proxy,\n    noProxy: gyp.opts.noproxy\n  }\n\n  const cafile = gyp.opts.cafile\n  if (cafile) {\n    requestOpts.ca = await readCAFile(cafile)\n  }\n\n  const res = await fetch(url, requestOpts)\n  log.http(res.status, res.url)\n\n  return res\n}\n\nasync function readCAFile (filename) {\n  // The CA file can contain multiple certificates so split on certificate\n  // boundaries.  [\\S\\s]*? is used to match everything including newlines.\n  const ca = await fs.promises.readFile(filename, 'utf8')\n  const re = /(-----BEGIN CERTIFICATE-----[\\S\\s]*?-----END CERTIFICATE-----)/g\n  return ca.match(re)\n}\n\nmodule.exports = function (gyp, argv, callback) {\n  install(fs, gyp, argv).then(callback.bind(undefined, null), callback)\n}\nmodule.exports.test = {\n  download,\n  install,\n  readCAFile\n}\nmodule.exports.usage = 'Install node development files for the specified node version.'\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}