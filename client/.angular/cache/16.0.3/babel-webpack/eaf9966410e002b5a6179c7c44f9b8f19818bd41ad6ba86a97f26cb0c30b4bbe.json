{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Minipass = require('minipass');\nconst MinipassSized = require('minipass-sized');\nconst Blob = require('./blob.js');\nconst {\n  BUFFER\n} = Blob;\nconst FetchError = require('./fetch-error.js');\n\n// optional dependency on 'encoding'\nlet convert;\ntry {\n  convert = require('encoding').convert;\n} catch (e) {\n  // defer error until textConverted is called\n}\nconst INTERNALS = Symbol('Body internals');\nconst CONSUME_BODY = Symbol('consumeBody');\nclass Body {\n  constructor(bodyArg, options = {}) {\n    const {\n      size = 0,\n      timeout = 0\n    } = options;\n    const body = bodyArg === undefined || bodyArg === null ? null : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString()) : isBlob(bodyArg) ? bodyArg : Buffer.isBuffer(bodyArg) ? bodyArg : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]' ? Buffer.from(bodyArg) : ArrayBuffer.isView(bodyArg) ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength) : Minipass.isStream(bodyArg) ? bodyArg : Buffer.from(String(bodyArg));\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null\n    };\n    this.size = size;\n    this.timeout = timeout;\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er : new FetchError(`Invalid response while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n        this[INTERNALS].error = error;\n      });\n    }\n  }\n  get body() {\n    return this[INTERNALS].body;\n  }\n  get bodyUsed() {\n    return this[INTERNALS].disturbed;\n  }\n  arrayBuffer() {\n    return this[CONSUME_BODY]().then(buf => buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength));\n  }\n  blob() {\n    const ct = this.headers && this.headers.get('content-type') || '';\n    return this[CONSUME_BODY]().then(buf => Object.assign(new Blob([], {\n      type: ct.toLowerCase()\n    }), {\n      [BUFFER]: buf\n    }));\n  }\n  json() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const buf = yield _this[CONSUME_BODY]();\n      try {\n        return JSON.parse(buf.toString());\n      } catch (er) {\n        throw new FetchError(`invalid json response body at ${_this.url} reason: ${er.message}`, 'invalid-json');\n      }\n    })();\n  }\n  text() {\n    return this[CONSUME_BODY]().then(buf => buf.toString());\n  }\n  buffer() {\n    return this[CONSUME_BODY]();\n  }\n  textConverted() {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers));\n  }\n  [CONSUME_BODY]() {\n    if (this[INTERNALS].disturbed) {\n      return Promise.reject(new TypeError(`body used already for: ${this.url}`));\n    }\n    this[INTERNALS].disturbed = true;\n    if (this[INTERNALS].error) {\n      return Promise.reject(this[INTERNALS].error);\n    }\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n    if (Buffer.isBuffer(this.body)) {\n      return Promise.resolve(this.body);\n    }\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body;\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream)) {\n      return Promise.resolve(Buffer.alloc(0));\n    }\n    const stream = this.size && upstream instanceof MinipassSized ? upstream : !this.size && upstream instanceof Minipass && !(upstream instanceof MinipassSized) ? upstream : this.size ? new MinipassSized({\n      size: this.size\n    }) : new Minipass();\n\n    // allow timeout on slow response body, but only if the stream is still writable. this\n    // makes the timeout center on the socket stream from lib/index.js rather than the\n    // intermediary minipass stream we create to receive the data\n    const resTimeout = this.timeout && stream.writable ? setTimeout(() => {\n      stream.emit('error', new FetchError(`Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`, 'body-timeout'));\n    }, this.timeout) : null;\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout && resTimeout.unref) {\n      resTimeout.unref();\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er));\n        upstream.pipe(stream);\n      }\n      resolve();\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout);\n      return buf;\n    }).catch(er => {\n      clearTimeout(resTimeout);\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError') {\n        throw er;\n      } else if (er.name === 'RangeError') {\n        throw new FetchError(`Could not create Buffer from response body for ${this.url}: ${er.message}`, 'system', er);\n      } else {\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${this.url}: ${er.message}`, 'system', er);\n      }\n    });\n  }\n  static clone(instance) {\n    if (instance.bodyUsed) {\n      throw new Error('cannot clone body after it is used');\n    }\n    const body = instance.body;\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass();\n      const p1 = new Minipass();\n      const p2 = new Minipass();\n      tee.on('error', er => {\n        p1.emit('error', er);\n        p2.emit('error', er);\n      });\n      body.on('error', er => tee.emit('error', er));\n      tee.pipe(p1);\n      tee.pipe(p2);\n      body.pipe(tee);\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1;\n      return p2;\n    } else {\n      return instance.body;\n    }\n  }\n  static extractContentType(body) {\n    return body === null || body === undefined ? null : typeof body === 'string' ? 'text/plain;charset=UTF-8' : isURLSearchParams(body) ? 'application/x-www-form-urlencoded;charset=UTF-8' : isBlob(body) ? body.type || null : Buffer.isBuffer(body) ? null : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null : ArrayBuffer.isView(body) ? null : typeof body.getBoundary === 'function' ? `multipart/form-data;boundary=${body.getBoundary()}` : Minipass.isStream(body) ? null : 'text/plain;charset=UTF-8';\n  }\n  static getTotalBytes(instance) {\n    const {\n      body\n    } = instance;\n    return body === null || body === undefined ? 0 : isBlob(body) ? body.size : Buffer.isBuffer(body) ? body.length : body && typeof body.getLengthSync === 'function' && (\n    // detect form data input from form-data module\n    body._lengthRetrievers && /* istanbul ignore next */body._lengthRetrievers.length === 0 ||\n    // 1.x\n    body.hasKnownLength && body.hasKnownLength()) // 2.x\n    ? body.getLengthSync() : null;\n  }\n  static writeToStream(dest, instance) {\n    const {\n      body\n    } = instance;\n    if (body === null || body === undefined) {\n      dest.end();\n    } else if (Buffer.isBuffer(body) || typeof body === 'string') {\n      dest.end(body);\n    } else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body;\n      stream.on('error', er => dest.emit('error', er)).pipe(dest);\n    }\n    return dest;\n  }\n}\nObject.defineProperties(Body.prototype, {\n  body: {\n    enumerable: true\n  },\n  bodyUsed: {\n    enumerable: true\n  },\n  arrayBuffer: {\n    enumerable: true\n  },\n  blob: {\n    enumerable: true\n  },\n  json: {\n    enumerable: true\n  },\n  text: {\n    enumerable: true\n  }\n});\nconst isURLSearchParams = obj =>\n// Duck-typing as a necessary condition.\ntypeof obj !== 'object' || typeof obj.append !== 'function' || typeof obj.delete !== 'function' || typeof obj.get !== 'function' || typeof obj.getAll !== 'function' || typeof obj.has !== 'function' || typeof obj.set !== 'function' ? false\n// Brand-checking and more duck-typing as optional condition.\n: obj.constructor.name === 'URLSearchParams' || Object.prototype.toString.call(obj) === '[object URLSearchParams]' || typeof obj.sort === 'function';\nconst isBlob = obj => typeof obj === 'object' && typeof obj.arrayBuffer === 'function' && typeof obj.type === 'string' && typeof obj.stream === 'function' && typeof obj.constructor === 'function' && typeof obj.constructor.name === 'string' && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function');\n  }\n  const ct = headers && headers.get('content-type');\n  let charset = 'utf-8';\n  let res;\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct);\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  const str = buffer.slice(0, 1024).toString();\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str);\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str);\n      if (res) {\n        res.pop();\n      } // drop last quote\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop());\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str);\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop();\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030';\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(buffer, 'UTF-8', charset).toString();\n};\nmodule.exports = Body;","map":{"version":3,"names":["_asyncToGenerator","require","default","Minipass","MinipassSized","Blob","BUFFER","FetchError","convert","e","INTERNALS","Symbol","CONSUME_BODY","Body","constructor","bodyArg","options","size","timeout","body","undefined","isURLSearchParams","Buffer","from","toString","isBlob","isBuffer","Object","prototype","call","ArrayBuffer","isView","buffer","byteOffset","byteLength","isStream","String","disturbed","error","on","er","name","url","message","bodyUsed","arrayBuffer","then","buf","slice","blob","ct","headers","get","assign","type","toLowerCase","json","_this","JSON","parse","text","textConverted","convertBody","Promise","reject","TypeError","resolve","alloc","upstream","stream","resTimeout","writable","setTimeout","emit","unref","pipe","concat","clearTimeout","catch","clone","instance","Error","getBoundary","tee","p1","p2","extractContentType","getTotalBytes","length","getLengthSync","_lengthRetrievers","hasKnownLength","writeToStream","dest","end","defineProperties","enumerable","obj","append","delete","getAll","has","set","sort","test","toStringTag","charset","res","exec","str","pop","module","exports"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/minipass-fetch/lib/body.js"],"sourcesContent":["'use strict'\nconst Minipass = require('minipass')\nconst MinipassSized = require('minipass-sized')\n\nconst Blob = require('./blob.js')\nconst { BUFFER } = Blob\nconst FetchError = require('./fetch-error.js')\n\n// optional dependency on 'encoding'\nlet convert\ntry {\n  convert = require('encoding').convert\n} catch (e) {\n  // defer error until textConverted is called\n}\n\nconst INTERNALS = Symbol('Body internals')\nconst CONSUME_BODY = Symbol('consumeBody')\n\nclass Body {\n  constructor (bodyArg, options = {}) {\n    const { size = 0, timeout = 0 } = options\n    const body = bodyArg === undefined || bodyArg === null ? null\n      : isURLSearchParams(bodyArg) ? Buffer.from(bodyArg.toString())\n      : isBlob(bodyArg) ? bodyArg\n      : Buffer.isBuffer(bodyArg) ? bodyArg\n      : Object.prototype.toString.call(bodyArg) === '[object ArrayBuffer]'\n        ? Buffer.from(bodyArg)\n        : ArrayBuffer.isView(bodyArg)\n          ? Buffer.from(bodyArg.buffer, bodyArg.byteOffset, bodyArg.byteLength)\n          : Minipass.isStream(bodyArg) ? bodyArg\n          : Buffer.from(String(bodyArg))\n\n    this[INTERNALS] = {\n      body,\n      disturbed: false,\n      error: null,\n    }\n\n    this.size = size\n    this.timeout = timeout\n\n    if (Minipass.isStream(body)) {\n      body.on('error', er => {\n        const error = er.name === 'AbortError' ? er\n          : new FetchError(`Invalid response while trying to fetch ${\n            this.url}: ${er.message}`, 'system', er)\n        this[INTERNALS].error = error\n      })\n    }\n  }\n\n  get body () {\n    return this[INTERNALS].body\n  }\n\n  get bodyUsed () {\n    return this[INTERNALS].disturbed\n  }\n\n  arrayBuffer () {\n    return this[CONSUME_BODY]().then(buf =>\n      buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength))\n  }\n\n  blob () {\n    const ct = this.headers && this.headers.get('content-type') || ''\n    return this[CONSUME_BODY]().then(buf => Object.assign(\n      new Blob([], { type: ct.toLowerCase() }),\n      { [BUFFER]: buf }\n    ))\n  }\n\n  async json () {\n    const buf = await this[CONSUME_BODY]()\n    try {\n      return JSON.parse(buf.toString())\n    } catch (er) {\n      throw new FetchError(\n        `invalid json response body at ${this.url} reason: ${er.message}`,\n        'invalid-json'\n      )\n    }\n  }\n\n  text () {\n    return this[CONSUME_BODY]().then(buf => buf.toString())\n  }\n\n  buffer () {\n    return this[CONSUME_BODY]()\n  }\n\n  textConverted () {\n    return this[CONSUME_BODY]().then(buf => convertBody(buf, this.headers))\n  }\n\n  [CONSUME_BODY] () {\n    if (this[INTERNALS].disturbed) {\n      return Promise.reject(new TypeError(`body used already for: ${\n        this.url}`))\n    }\n\n    this[INTERNALS].disturbed = true\n\n    if (this[INTERNALS].error) {\n      return Promise.reject(this[INTERNALS].error)\n    }\n\n    // body is null\n    if (this.body === null) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    if (Buffer.isBuffer(this.body)) {\n      return Promise.resolve(this.body)\n    }\n\n    const upstream = isBlob(this.body) ? this.body.stream() : this.body\n\n    /* istanbul ignore if: should never happen */\n    if (!Minipass.isStream(upstream)) {\n      return Promise.resolve(Buffer.alloc(0))\n    }\n\n    const stream = this.size && upstream instanceof MinipassSized ? upstream\n      : !this.size && upstream instanceof Minipass &&\n        !(upstream instanceof MinipassSized) ? upstream\n      : this.size ? new MinipassSized({ size: this.size })\n      : new Minipass()\n\n    // allow timeout on slow response body, but only if the stream is still writable. this\n    // makes the timeout center on the socket stream from lib/index.js rather than the\n    // intermediary minipass stream we create to receive the data\n    const resTimeout = this.timeout && stream.writable ? setTimeout(() => {\n      stream.emit('error', new FetchError(\n        `Response timeout while trying to fetch ${\n          this.url} (over ${this.timeout}ms)`, 'body-timeout'))\n    }, this.timeout) : null\n\n    // do not keep the process open just for this timeout, even\n    // though we expect it'll get cleared eventually.\n    if (resTimeout && resTimeout.unref) {\n      resTimeout.unref()\n    }\n\n    // do the pipe in the promise, because the pipe() can send too much\n    // data through right away and upset the MP Sized object\n    return new Promise((resolve, reject) => {\n      // if the stream is some other kind of stream, then pipe through a MP\n      // so we can collect it more easily.\n      if (stream !== upstream) {\n        upstream.on('error', er => stream.emit('error', er))\n        upstream.pipe(stream)\n      }\n      resolve()\n    }).then(() => stream.concat()).then(buf => {\n      clearTimeout(resTimeout)\n      return buf\n    }).catch(er => {\n      clearTimeout(resTimeout)\n      // request was aborted, reject with this Error\n      if (er.name === 'AbortError' || er.name === 'FetchError') {\n        throw er\n      } else if (er.name === 'RangeError') {\n        throw new FetchError(`Could not create Buffer from response body for ${\n          this.url}: ${er.message}`, 'system', er)\n      } else {\n        // other errors, such as incorrect content-encoding or content-length\n        throw new FetchError(`Invalid response body while trying to fetch ${\n          this.url}: ${er.message}`, 'system', er)\n      }\n    })\n  }\n\n  static clone (instance) {\n    if (instance.bodyUsed) {\n      throw new Error('cannot clone body after it is used')\n    }\n\n    const body = instance.body\n\n    // check that body is a stream and not form-data object\n    // NB: can't clone the form-data object without having it as a dependency\n    if (Minipass.isStream(body) && typeof body.getBoundary !== 'function') {\n      // create a dedicated tee stream so that we don't lose data\n      // potentially sitting in the body stream's buffer by writing it\n      // immediately to p1 and not having it for p2.\n      const tee = new Minipass()\n      const p1 = new Minipass()\n      const p2 = new Minipass()\n      tee.on('error', er => {\n        p1.emit('error', er)\n        p2.emit('error', er)\n      })\n      body.on('error', er => tee.emit('error', er))\n      tee.pipe(p1)\n      tee.pipe(p2)\n      body.pipe(tee)\n      // set instance body to one fork, return the other\n      instance[INTERNALS].body = p1\n      return p2\n    } else {\n      return instance.body\n    }\n  }\n\n  static extractContentType (body) {\n    return body === null || body === undefined ? null\n      : typeof body === 'string' ? 'text/plain;charset=UTF-8'\n      : isURLSearchParams(body)\n        ? 'application/x-www-form-urlencoded;charset=UTF-8'\n        : isBlob(body) ? body.type || null\n        : Buffer.isBuffer(body) ? null\n        : Object.prototype.toString.call(body) === '[object ArrayBuffer]' ? null\n        : ArrayBuffer.isView(body) ? null\n        : typeof body.getBoundary === 'function'\n          ? `multipart/form-data;boundary=${body.getBoundary()}`\n          : Minipass.isStream(body) ? null\n          : 'text/plain;charset=UTF-8'\n  }\n\n  static getTotalBytes (instance) {\n    const { body } = instance\n    return (body === null || body === undefined) ? 0\n      : isBlob(body) ? body.size\n      : Buffer.isBuffer(body) ? body.length\n      : body && typeof body.getLengthSync === 'function' && (\n        // detect form data input from form-data module\n        body._lengthRetrievers &&\n        /* istanbul ignore next */ body._lengthRetrievers.length === 0 || // 1.x\n        body.hasKnownLength && body.hasKnownLength()) // 2.x\n        ? body.getLengthSync()\n        : null\n  }\n\n  static writeToStream (dest, instance) {\n    const { body } = instance\n\n    if (body === null || body === undefined) {\n      dest.end()\n    } else if (Buffer.isBuffer(body) || typeof body === 'string') {\n      dest.end(body)\n    } else {\n      // body is stream or blob\n      const stream = isBlob(body) ? body.stream() : body\n      stream.on('error', er => dest.emit('error', er)).pipe(dest)\n    }\n\n    return dest\n  }\n}\n\nObject.defineProperties(Body.prototype, {\n  body: { enumerable: true },\n  bodyUsed: { enumerable: true },\n  arrayBuffer: { enumerable: true },\n  blob: { enumerable: true },\n  json: { enumerable: true },\n  text: { enumerable: true },\n})\n\nconst isURLSearchParams = obj =>\n  // Duck-typing as a necessary condition.\n  (typeof obj !== 'object' ||\n    typeof obj.append !== 'function' ||\n    typeof obj.delete !== 'function' ||\n    typeof obj.get !== 'function' ||\n    typeof obj.getAll !== 'function' ||\n    typeof obj.has !== 'function' ||\n    typeof obj.set !== 'function') ? false\n  // Brand-checking and more duck-typing as optional condition.\n  : obj.constructor.name === 'URLSearchParams' ||\n    Object.prototype.toString.call(obj) === '[object URLSearchParams]' ||\n    typeof obj.sort === 'function'\n\nconst isBlob = obj =>\n  typeof obj === 'object' &&\n  typeof obj.arrayBuffer === 'function' &&\n  typeof obj.type === 'string' &&\n  typeof obj.stream === 'function' &&\n  typeof obj.constructor === 'function' &&\n  typeof obj.constructor.name === 'string' &&\n  /^(Blob|File)$/.test(obj.constructor.name) &&\n  /^(Blob|File)$/.test(obj[Symbol.toStringTag])\n\nconst convertBody = (buffer, headers) => {\n  /* istanbul ignore if */\n  if (typeof convert !== 'function') {\n    throw new Error('The package `encoding` must be installed to use the textConverted() function')\n  }\n\n  const ct = headers && headers.get('content-type')\n  let charset = 'utf-8'\n  let res\n\n  // header\n  if (ct) {\n    res = /charset=([^;]*)/i.exec(ct)\n  }\n\n  // no charset in content type, peek at response body for at most 1024 bytes\n  const str = buffer.slice(0, 1024).toString()\n\n  // html5\n  if (!res && str) {\n    res = /<meta.+?charset=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // html4\n  if (!res && str) {\n    res = /<meta[\\s]+?http-equiv=(['\"])content-type\\1[\\s]+?content=(['\"])(.+?)\\2/i.exec(str)\n\n    if (!res) {\n      res = /<meta[\\s]+?content=(['\"])(.+?)\\1[\\s]+?http-equiv=(['\"])content-type\\3/i.exec(str)\n      if (res) {\n        res.pop()\n      } // drop last quote\n    }\n\n    if (res) {\n      res = /charset=(.*)/i.exec(res.pop())\n    }\n  }\n\n  // xml\n  if (!res && str) {\n    res = /<\\?xml.+?encoding=(['\"])(.+?)\\1/i.exec(str)\n  }\n\n  // found charset\n  if (res) {\n    charset = res.pop()\n\n    // prevent decode issues when sites use incorrect encoding\n    // ref: https://hsivonen.fi/encoding-menu/\n    if (charset === 'gb2312' || charset === 'gbk') {\n      charset = 'gb18030'\n    }\n  }\n\n  // turn raw buffers into a single utf-8 buffer\n  return convert(\n    buffer,\n    'UTF-8',\n    charset\n  ).toString()\n}\n\nmodule.exports = Body\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}