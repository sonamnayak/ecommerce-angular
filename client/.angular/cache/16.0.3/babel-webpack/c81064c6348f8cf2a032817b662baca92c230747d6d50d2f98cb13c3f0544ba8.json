{"ast":null,"code":"const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern);\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false;\n  }\n  return new Minimatch(pattern, options).match(p);\n};\nmodule.exports = minimatch;\nconst path = require('./lib/path.js');\nminimatch.sep = path.sep;\nconst GLOBSTAR = Symbol('globstar **');\nminimatch.GLOBSTAR = GLOBSTAR;\nconst expand = require('brace-expansion');\nconst plTypes = {\n  '!': {\n    open: '(?:(?!(?:',\n    close: '))[^/]*?)'\n  },\n  '?': {\n    open: '(?:',\n    close: ')?'\n  },\n  '+': {\n    open: '(?:',\n    close: ')+'\n  },\n  '*': {\n    open: '(?:',\n    close: ')*'\n  },\n  '@': {\n    open: '(?:',\n    close: ')'\n  }\n};\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]';\n\n// * => any number of characters\nconst star = qmark + '*?';\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?';\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?';\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true;\n  return set;\n}, {});\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!');\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(');\n\n// normalizes slashes.\nconst slashSplit = /\\/+/;\nminimatch.filter = (pattern, options = {}) => (p, i, list) => minimatch(p, pattern, options);\nconst ext = (a, b = {}) => {\n  const t = {};\n  Object.keys(a).forEach(k => t[k] = a[k]);\n  Object.keys(b).forEach(k => t[k] = b[k]);\n  return t;\n};\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch;\n  }\n  const orig = minimatch;\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options));\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor(pattern, options) {\n      super(pattern, ext(def, options));\n    }\n  };\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch;\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options));\n  m.defaults = options => orig.defaults(ext(def, options));\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options));\n  return m;\n};\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern);\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern];\n  }\n  return expand(pattern);\n};\nconst MAX_PATTERN_LENGTH = 1024 * 64;\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern');\n  }\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long');\n  }\n};\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol('subparse');\nminimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options);\n  list = list.filter(f => mm.match(f));\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern);\n  }\n  return list;\n};\n\n// replace stuff like \\* with *\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1');\nconst charUnescape = s => s.replace(/\\\\([^-\\]])/g, '$1');\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\nconst braExpEscape = s => s.replace(/[[\\]\\\\]/g, '\\\\$&');\nclass Minimatch {\n  constructor(pattern, options) {\n    assertValidPattern(pattern);\n    if (!options) options = {};\n    this.options = options;\n    this.set = [];\n    this.pattern = pattern;\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape || options.allowWindowsEscape === false;\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/');\n    }\n    this.regexp = null;\n    this.negate = false;\n    this.comment = false;\n    this.empty = false;\n    this.partial = !!options.partial;\n\n    // make the set of regexps etc.\n    this.make();\n  }\n  debug() {}\n  make() {\n    const pattern = this.pattern;\n    const options = this.options;\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true;\n      return;\n    }\n    if (!pattern) {\n      this.empty = true;\n      return;\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate();\n\n    // step 2: expand braces\n    let set = this.globSet = this.braceExpand();\n    if (options.debug) this.debug = (...args) => console.error(...args);\n    this.debug(this.pattern, set);\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(s => s.split(slashSplit));\n    this.debug(this.pattern, set);\n\n    // glob --> regexps\n    set = set.map((s, si, set) => s.map(this.parse, this));\n    this.debug(this.pattern, set);\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(s => s.indexOf(false) === -1);\n    this.debug(this.pattern, set);\n    this.set = set;\n  }\n  parseNegate() {\n    if (this.options.nonegate) return;\n    const pattern = this.pattern;\n    let negate = false;\n    let negateOffset = 0;\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate;\n      negateOffset++;\n    }\n    if (negateOffset) this.pattern = pattern.slice(negateOffset);\n    this.negate = negate;\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne(file, pattern, partial) {\n    var options = this.options;\n    this.debug('matchOne', {\n      'this': this,\n      file: file,\n      pattern: pattern\n    });\n    this.debug('matchOne', file.length, pattern.length);\n    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {\n      this.debug('matchOne loop');\n      var p = pattern[pi];\n      var f = file[fi];\n      this.debug(pattern, p, f);\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* istanbul ignore if */\n      if (p === false) return false;\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f]);\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi;\n        var pr = pi + 1;\n        if (pr === pl) {\n          this.debug('** at the end');\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' || !options.dot && file[fi].charAt(0) === '.') return false;\n          }\n          return true;\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr];\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee);\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee);\n            // found a match.\n            return true;\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' || !options.dot && swallowee.charAt(0) === '.') {\n              this.debug('dot detected!', file, fr, pattern, pr);\n              break;\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue');\n            fr++;\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        /* istanbul ignore if */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr);\n          if (fr === fl) return true;\n        }\n        return false;\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit;\n      if (typeof p === 'string') {\n        hit = f === p;\n        this.debug('string match', p, f, hit);\n      } else {\n        hit = f.match(p);\n        this.debug('pattern match', p, f, hit);\n      }\n      if (!hit) return false;\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true;\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial;\n    } else /* istanbul ignore else */if (pi === pl) {\n        // ran out of pattern, still have file left.\n        // this is only acceptable if we're on the very last\n        // empty segment of a file with a trailing slash.\n        // a/* should match a/b/\n        return fi === fl - 1 && file[fi] === '';\n      }\n\n    // should be unreachable.\n    /* istanbul ignore next */\n    throw new Error('wtf?');\n  }\n  braceExpand() {\n    return braceExpand(this.pattern, this.options);\n  }\n  parse(pattern, isSub) {\n    assertValidPattern(pattern);\n    const options = this.options;\n\n    // shortcuts\n    if (pattern === '**') {\n      if (!options.noglobstar) return GLOBSTAR;else pattern = '*';\n    }\n    if (pattern === '') return '';\n    let re = '';\n    let hasMagic = false;\n    let escaping = false;\n    // ? => one single character\n    const patternListStack = [];\n    const negativeLists = [];\n    let stateChar;\n    let inClass = false;\n    let reClassStart = -1;\n    let classStart = -1;\n    let cs;\n    let pl;\n    let sp;\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.  However, if the pattern\n    // starts with ., then traversal patterns can match.\n    let dotTravAllowed = pattern.charAt(0) === '.';\n    let dotFileAllowed = options.dot || dotTravAllowed;\n    const patternStart = () => dotTravAllowed ? '' : dotFileAllowed ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))' : '(?!\\\\.)';\n    const subPatternStart = p => p.charAt(0) === '.' ? '' : options.dot ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))' : '(?!\\\\.)';\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star;\n            hasMagic = true;\n            break;\n          case '?':\n            re += qmark;\n            hasMagic = true;\n            break;\n          default:\n            re += '\\\\' + stateChar;\n            break;\n        }\n        this.debug('clearStateChar %j %j', stateChar, re);\n        stateChar = false;\n      }\n    };\n    for (let i = 0, c; i < pattern.length && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c);\n\n      // skip over any that are escaped.\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false;\n        }\n        if (reSpecials[c]) {\n          re += '\\\\';\n        }\n        re += c;\n        escaping = false;\n        continue;\n      }\n      switch (c) {\n        /* istanbul ignore next */\n        case '/':\n          {\n            // Should already be path-split by now.\n            return false;\n          }\n        case '\\\\':\n          if (inClass && pattern.charAt(i + 1) === '-') {\n            re += c;\n            continue;\n          }\n          clearStateChar();\n          escaping = true;\n          continue;\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c);\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class');\n            if (c === '!' && i === classStart + 1) c = '^';\n            re += c;\n            continue;\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          this.debug('call clearStateChar %j', stateChar);\n          clearStateChar();\n          stateChar = c;\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar();\n          continue;\n        case '(':\n          {\n            if (inClass) {\n              re += '(';\n              continue;\n            }\n            if (!stateChar) {\n              re += '\\\\(';\n              continue;\n            }\n            const plEntry = {\n              type: stateChar,\n              start: i - 1,\n              reStart: re.length,\n              open: plTypes[stateChar].open,\n              close: plTypes[stateChar].close\n            };\n            this.debug(this.pattern, '\\t', plEntry);\n            patternListStack.push(plEntry);\n            // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n            re += plEntry.open;\n            // next entry starts with a dot maybe?\n            if (plEntry.start === 0 && plEntry.type !== '!') {\n              dotTravAllowed = true;\n              re += subPatternStart(pattern.slice(i + 1));\n            }\n            this.debug('plType %j %j', stateChar, re);\n            stateChar = false;\n            continue;\n          }\n        case ')':\n          {\n            const plEntry = patternListStack[patternListStack.length - 1];\n            if (inClass || !plEntry) {\n              re += '\\\\)';\n              continue;\n            }\n            patternListStack.pop();\n\n            // closing an extglob\n            clearStateChar();\n            hasMagic = true;\n            pl = plEntry;\n            // negation is (?:(?!js)[^/]*)\n            // The others are (?:<pattern>)<type>\n            re += pl.close;\n            if (pl.type === '!') {\n              negativeLists.push(Object.assign(pl, {\n                reEnd: re.length\n              }));\n            }\n            continue;\n          }\n        case '|':\n          {\n            const plEntry = patternListStack[patternListStack.length - 1];\n            if (inClass || !plEntry) {\n              re += '\\\\|';\n              continue;\n            }\n            clearStateChar();\n            re += '|';\n            // next subpattern can start with a dot?\n            if (plEntry.start === 0 && plEntry.type !== '!') {\n              dotTravAllowed = true;\n              re += subPatternStart(pattern.slice(i + 1));\n            }\n            continue;\n          }\n\n        // these are mostly the same in regexp and glob\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar();\n          if (inClass) {\n            re += '\\\\' + c;\n            continue;\n          }\n          inClass = true;\n          classStart = i;\n          reClassStart = re.length;\n          re += c;\n          continue;\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c;\n            continue;\n          }\n\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          cs = pattern.substring(classStart + 1, i);\n          try {\n            RegExp('[' + braExpEscape(charUnescape(cs)) + ']');\n            // looks good, finish up the class.\n            re += c;\n          } catch (er) {\n            // out of order ranges in JS are errors, but in glob syntax,\n            // they're just a range that matches nothing.\n            re = re.substring(0, reClassStart) + '(?:$.)'; // match nothing ever\n          }\n\n          hasMagic = true;\n          inClass = false;\n          continue;\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar();\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\';\n          }\n          re += c;\n          break;\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.slice(classStart + 1);\n      sp = this.parse(cs, SUBPARSE);\n      re = re.substring(0, reClassStart) + '\\\\[' + sp[0];\n      hasMagic = hasMagic || sp[1];\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail;\n      tail = re.slice(pl.reStart + pl.open.length);\n      this.debug('setting tail', re, pl);\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\';\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + '|';\n      });\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re);\n      const t = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\\\' + pl.type;\n      hasMagic = true;\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail;\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar();\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\';\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    const addPatternStart = addPatternStartSet[re.charAt(0)];\n\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n];\n      const nlBefore = re.slice(0, nl.reStart);\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);\n      let nlAfter = re.slice(nl.reEnd);\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;\n\n      // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n      const closeParensBefore = nlBefore.split(')').length;\n      const openParensBefore = nlBefore.split('(').length - closeParensBefore;\n      let cleanAfter = nlAfter;\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '');\n      }\n      nlAfter = cleanAfter;\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\\\/)' : '';\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast;\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re;\n    }\n    if (addPatternStart) {\n      re = patternStart() + re;\n    }\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic];\n    }\n\n    // if it's nocase, and the lcase/uppercase don't match, it's magic\n    if (options.nocase && !hasMagic) {\n      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase();\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern);\n    }\n    const flags = options.nocase ? 'i' : '';\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re\n      });\n    } catch (er) /* istanbul ignore next - should be impossible */{\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.');\n    }\n  }\n  makeRe() {\n    if (this.regexp || this.regexp === false) return this.regexp;\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set;\n    if (!set.length) {\n      this.regexp = false;\n      return this.regexp;\n    }\n    const options = this.options;\n    const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;\n    const flags = options.nocase ? 'i' : '';\n\n    // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      pattern = pattern.map(p => typeof p === 'string' ? regExpEscape(p) : p === GLOBSTAR ? GLOBSTAR : p._src).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p);\n        }\n        return set;\n      }, []);\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i - 1] === GLOBSTAR) {\n          return;\n        }\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i + 1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i + 1];\n          } else {\n            pattern[i] = twoStar;\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i - 1] += '(?:\\\\\\/|' + twoStar + ')?';\n        } else {\n          pattern[i - 1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i + 1];\n          pattern[i + 1] = GLOBSTAR;\n        }\n      });\n      return pattern.filter(p => p !== GLOBSTAR).join('/');\n    }).join('|');\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^(?:' + re + ')$';\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').*$';\n    try {\n      this.regexp = new RegExp(re, flags);\n    } catch (ex) /* istanbul ignore next - should be impossible */{\n      this.regexp = false;\n    }\n    return this.regexp;\n  }\n  match(f, partial = this.partial) {\n    this.debug('match', f, this.pattern);\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false;\n    if (this.empty) return f === '';\n    if (f === '/' && partial) return true;\n    const options = this.options;\n\n    // windows: need to use /, not \\\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/');\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit);\n    this.debug(this.pattern, 'split', f);\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set;\n    this.debug(this.pattern, 'set', set);\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename;\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i];\n      if (filename) break;\n    }\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i];\n      let file = f;\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename];\n      }\n      const hit = this.matchOne(file, pattern, partial);\n      if (hit) {\n        if (options.flipNegate) return true;\n        return !this.negate;\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false;\n    return this.negate;\n  }\n  static defaults(def) {\n    return minimatch.defaults(def).Minimatch;\n  }\n}\nminimatch.Minimatch = Minimatch;","map":{"version":3,"names":["minimatch","module","exports","p","pattern","options","assertValidPattern","nocomment","charAt","Minimatch","match","path","require","sep","GLOBSTAR","Symbol","expand","plTypes","open","close","qmark","star","twoStarDot","twoStarNoDot","charSet","s","split","reduce","set","c","reSpecials","addPatternStartSet","slashSplit","filter","i","list","ext","a","b","t","Object","keys","forEach","k","defaults","def","length","orig","m","constructor","makeRe","braceExpand","nobrace","test","MAX_PATTERN_LENGTH","TypeError","SUBPARSE","mm","f","nonull","push","globUnescape","replace","charUnescape","regExpEscape","braExpEscape","windowsPathsNoEscape","allowWindowsEscape","regexp","negate","comment","empty","partial","make","debug","parseNegate","globSet","args","console","error","globParts","map","si","parse","indexOf","nonegate","negateOffset","slice","matchOne","file","fi","pi","fl","pl","fr","pr","dot","swallowee","hit","Error","isSub","noglobstar","re","hasMagic","escaping","patternListStack","negativeLists","stateChar","inClass","reClassStart","classStart","cs","sp","dotTravAllowed","dotFileAllowed","patternStart","subPatternStart","clearStateChar","noext","plEntry","type","start","reStart","pop","assign","reEnd","substring","RegExp","er","tail","_","$1","$2","addPatternStart","n","nl","nlBefore","nlFirst","nlAfter","nlLast","closeParensBefore","openParensBefore","cleanAfter","dollar","nocase","toUpperCase","toLowerCase","flags","_glob","_src","twoStar","join","ex","filename","matchBase","flipNegate"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/minimatch/minimatch.js"],"sourcesContent":["const minimatch = module.exports = (p, pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // shortcut: comments match nothing.\n  if (!options.nocomment && pattern.charAt(0) === '#') {\n    return false\n  }\n\n  return new Minimatch(pattern, options).match(p)\n}\n\nmodule.exports = minimatch\n\nconst path = require('./lib/path.js')\nminimatch.sep = path.sep\n\nconst GLOBSTAR = Symbol('globstar **')\nminimatch.GLOBSTAR = GLOBSTAR\nconst expand = require('brace-expansion')\n\nconst plTypes = {\n  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},\n  '?': { open: '(?:', close: ')?' },\n  '+': { open: '(?:', close: ')+' },\n  '*': { open: '(?:', close: ')*' },\n  '@': { open: '(?:', close: ')' }\n}\n\n// any single thing other than /\n// don't need to escape / when using new RegExp()\nconst qmark = '[^/]'\n\n// * => any number of characters\nconst star = qmark + '*?'\n\n// ** when dots are allowed.  Anything goes, except .. and .\n// not (^ or / followed by one or two dots followed by $ or /),\n// followed by anything, any number of times.\nconst twoStarDot = '(?:(?!(?:\\\\\\/|^)(?:\\\\.{1,2})($|\\\\\\/)).)*?'\n\n// not a ^ or / followed by a dot,\n// followed by anything, any number of times.\nconst twoStarNoDot = '(?:(?!(?:\\\\\\/|^)\\\\.).)*?'\n\n// \"abc\" -> { a:true, b:true, c:true }\nconst charSet = s => s.split('').reduce((set, c) => {\n  set[c] = true\n  return set\n}, {})\n\n// characters that need to be escaped in RegExp.\nconst reSpecials = charSet('().*{}+?[]^$\\\\!')\n\n// characters that indicate we have to add the pattern start\nconst addPatternStartSet = charSet('[.(')\n\n// normalizes slashes.\nconst slashSplit = /\\/+/\n\nminimatch.filter = (pattern, options = {}) =>\n  (p, i, list) => minimatch(p, pattern, options)\n\nconst ext = (a, b = {}) => {\n  const t = {}\n  Object.keys(a).forEach(k => t[k] = a[k])\n  Object.keys(b).forEach(k => t[k] = b[k])\n  return t\n}\n\nminimatch.defaults = def => {\n  if (!def || typeof def !== 'object' || !Object.keys(def).length) {\n    return minimatch\n  }\n\n  const orig = minimatch\n\n  const m = (p, pattern, options) => orig(p, pattern, ext(def, options))\n  m.Minimatch = class Minimatch extends orig.Minimatch {\n    constructor (pattern, options) {\n      super(pattern, ext(def, options))\n    }\n  }\n  m.Minimatch.defaults = options => orig.defaults(ext(def, options)).Minimatch\n  m.filter = (pattern, options) => orig.filter(pattern, ext(def, options))\n  m.defaults = options => orig.defaults(ext(def, options))\n  m.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options))\n  m.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options))\n  m.match = (list, pattern, options) => orig.match(list, pattern, ext(def, options))\n\n  return m\n}\n\n\n\n\n\n// Brace expansion:\n// a{b,c}d -> abd acd\n// a{b,}c -> abc ac\n// a{0..3}d -> a0d a1d a2d a3d\n// a{b,c{d,e}f}g -> abg acdfg acefg\n// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg\n//\n// Invalid sets are not expanded.\n// a{2..}b -> a{2..}b\n// a{b}c -> a{b}c\nminimatch.braceExpand = (pattern, options) => braceExpand(pattern, options)\n\nconst braceExpand = (pattern, options = {}) => {\n  assertValidPattern(pattern)\n\n  // Thanks to Yeting Li <https://github.com/yetingli> for\n  // improving this regexp to avoid a ReDOS vulnerability.\n  if (options.nobrace || !/\\{(?:(?!\\{).)*\\}/.test(pattern)) {\n    // shortcut. no need to expand.\n    return [pattern]\n  }\n\n  return expand(pattern)\n}\n\nconst MAX_PATTERN_LENGTH = 1024 * 64\nconst assertValidPattern = pattern => {\n  if (typeof pattern !== 'string') {\n    throw new TypeError('invalid pattern')\n  }\n\n  if (pattern.length > MAX_PATTERN_LENGTH) {\n    throw new TypeError('pattern is too long')\n  }\n}\n\n// parse a component of the expanded set.\n// At this point, no pattern may contain \"/\" in it\n// so we're going to return a 2d array, where each entry is the full\n// pattern, split on '/', and then turned into a regular expression.\n// A regexp is made at the end which joins each array with an\n// escaped /, and another full one which joins each regexp with |.\n//\n// Following the lead of Bash 4.1, note that \"**\" only has special meaning\n// when it is the *only* thing in a path portion.  Otherwise, any series\n// of * is equivalent to a single *.  Globstar behavior is enabled by\n// default, and can be disabled by setting options.noglobstar.\nconst SUBPARSE = Symbol('subparse')\n\nminimatch.makeRe = (pattern, options) =>\n  new Minimatch(pattern, options || {}).makeRe()\n\nminimatch.match = (list, pattern, options = {}) => {\n  const mm = new Minimatch(pattern, options)\n  list = list.filter(f => mm.match(f))\n  if (mm.options.nonull && !list.length) {\n    list.push(pattern)\n  }\n  return list\n}\n\n// replace stuff like \\* with *\nconst globUnescape = s => s.replace(/\\\\(.)/g, '$1')\nconst charUnescape = s => s.replace(/\\\\([^-\\]])/g, '$1')\nconst regExpEscape = s => s.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&')\nconst braExpEscape = s => s.replace(/[[\\]\\\\]/g, '\\\\$&')\n\nclass Minimatch {\n  constructor (pattern, options) {\n    assertValidPattern(pattern)\n\n    if (!options) options = {}\n\n    this.options = options\n    this.set = []\n    this.pattern = pattern\n    this.windowsPathsNoEscape = !!options.windowsPathsNoEscape ||\n      options.allowWindowsEscape === false\n    if (this.windowsPathsNoEscape) {\n      this.pattern = this.pattern.replace(/\\\\/g, '/')\n    }\n    this.regexp = null\n    this.negate = false\n    this.comment = false\n    this.empty = false\n    this.partial = !!options.partial\n\n    // make the set of regexps etc.\n    this.make()\n  }\n\n  debug () {}\n\n  make () {\n    const pattern = this.pattern\n    const options = this.options\n\n    // empty patterns and comments match nothing.\n    if (!options.nocomment && pattern.charAt(0) === '#') {\n      this.comment = true\n      return\n    }\n    if (!pattern) {\n      this.empty = true\n      return\n    }\n\n    // step 1: figure out negation, etc.\n    this.parseNegate()\n\n    // step 2: expand braces\n    let set = this.globSet = this.braceExpand()\n\n    if (options.debug) this.debug = (...args) => console.error(...args)\n\n    this.debug(this.pattern, set)\n\n    // step 3: now we have a set, so turn each one into a series of path-portion\n    // matching patterns.\n    // These will be regexps, except in the case of \"**\", which is\n    // set to the GLOBSTAR object for globstar behavior,\n    // and will not contain any / characters\n    set = this.globParts = set.map(s => s.split(slashSplit))\n\n    this.debug(this.pattern, set)\n\n    // glob --> regexps\n    set = set.map((s, si, set) => s.map(this.parse, this))\n\n    this.debug(this.pattern, set)\n\n    // filter out everything that didn't compile properly.\n    set = set.filter(s => s.indexOf(false) === -1)\n\n    this.debug(this.pattern, set)\n\n    this.set = set\n  }\n\n  parseNegate () {\n    if (this.options.nonegate) return\n\n    const pattern = this.pattern\n    let negate = false\n    let negateOffset = 0\n\n    for (let i = 0; i < pattern.length && pattern.charAt(i) === '!'; i++) {\n      negate = !negate\n      negateOffset++\n    }\n\n    if (negateOffset) this.pattern = pattern.slice(negateOffset)\n    this.negate = negate\n  }\n\n  // set partial to true to test if, for example,\n  // \"/a/b\" matches the start of \"/*/b/*/d\"\n  // Partial means, if you run out of file before you run\n  // out of pattern, then that's fine, as long as all\n  // the parts match.\n  matchOne (file, pattern, partial) {\n    var options = this.options\n\n    this.debug('matchOne',\n      { 'this': this, file: file, pattern: pattern })\n\n    this.debug('matchOne', file.length, pattern.length)\n\n    for (var fi = 0,\n        pi = 0,\n        fl = file.length,\n        pl = pattern.length\n        ; (fi < fl) && (pi < pl)\n        ; fi++, pi++) {\n      this.debug('matchOne loop')\n      var p = pattern[pi]\n      var f = file[fi]\n\n      this.debug(pattern, p, f)\n\n      // should be impossible.\n      // some invalid regexp stuff in the set.\n      /* istanbul ignore if */\n      if (p === false) return false\n\n      if (p === GLOBSTAR) {\n        this.debug('GLOBSTAR', [pattern, p, f])\n\n        // \"**\"\n        // a/**/b/**/c would match the following:\n        // a/b/x/y/z/c\n        // a/x/y/z/b/c\n        // a/b/x/b/x/c\n        // a/b/c\n        // To do this, take the rest of the pattern after\n        // the **, and see if it would match the file remainder.\n        // If so, return success.\n        // If not, the ** \"swallows\" a segment, and try again.\n        // This is recursively awful.\n        //\n        // a/**/b/**/c matching a/b/x/y/z/c\n        // - a matches a\n        // - doublestar\n        //   - matchOne(b/x/y/z/c, b/**/c)\n        //     - b matches b\n        //     - doublestar\n        //       - matchOne(x/y/z/c, c) -> no\n        //       - matchOne(y/z/c, c) -> no\n        //       - matchOne(z/c, c) -> no\n        //       - matchOne(c, c) yes, hit\n        var fr = fi\n        var pr = pi + 1\n        if (pr === pl) {\n          this.debug('** at the end')\n          // a ** at the end will just swallow the rest.\n          // We have found a match.\n          // however, it will not swallow /.x, unless\n          // options.dot is set.\n          // . and .. are *never* matched by **, for explosively\n          // exponential reasons.\n          for (; fi < fl; fi++) {\n            if (file[fi] === '.' || file[fi] === '..' ||\n              (!options.dot && file[fi].charAt(0) === '.')) return false\n          }\n          return true\n        }\n\n        // ok, let's see if we can swallow whatever we can.\n        while (fr < fl) {\n          var swallowee = file[fr]\n\n          this.debug('\\nglobstar while', file, fr, pattern, pr, swallowee)\n\n          // XXX remove this slice.  Just pass the start index.\n          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {\n            this.debug('globstar found match!', fr, fl, swallowee)\n            // found a match.\n            return true\n          } else {\n            // can't swallow \".\" or \"..\" ever.\n            // can only swallow \".foo\" when explicitly asked.\n            if (swallowee === '.' || swallowee === '..' ||\n              (!options.dot && swallowee.charAt(0) === '.')) {\n              this.debug('dot detected!', file, fr, pattern, pr)\n              break\n            }\n\n            // ** swallows a segment, and continue.\n            this.debug('globstar swallow a segment, and continue')\n            fr++\n          }\n        }\n\n        // no match was found.\n        // However, in partial mode, we can't say this is necessarily over.\n        // If there's more *pattern* left, then\n        /* istanbul ignore if */\n        if (partial) {\n          // ran out of file\n          this.debug('\\n>>> no match, partial?', file, fr, pattern, pr)\n          if (fr === fl) return true\n        }\n        return false\n      }\n\n      // something other than **\n      // non-magic patterns just have to match exactly\n      // patterns with magic have been turned into regexps.\n      var hit\n      if (typeof p === 'string') {\n        hit = f === p\n        this.debug('string match', p, f, hit)\n      } else {\n        hit = f.match(p)\n        this.debug('pattern match', p, f, hit)\n      }\n\n      if (!hit) return false\n    }\n\n    // Note: ending in / means that we'll get a final \"\"\n    // at the end of the pattern.  This can only match a\n    // corresponding \"\" at the end of the file.\n    // If the file ends in /, then it can only match a\n    // a pattern that ends in /, unless the pattern just\n    // doesn't have any more for it. But, a/b/ should *not*\n    // match \"a/b/*\", even though \"\" matches against the\n    // [^/]*? pattern, except in partial mode, where it might\n    // simply not be reached yet.\n    // However, a/b/ should still satisfy a/*\n\n    // now either we fell off the end of the pattern, or we're done.\n    if (fi === fl && pi === pl) {\n      // ran out of pattern and filename at the same time.\n      // an exact hit!\n      return true\n    } else if (fi === fl) {\n      // ran out of file, but still had pattern left.\n      // this is ok if we're doing the match as part of\n      // a glob fs traversal.\n      return partial\n    } else /* istanbul ignore else */ if (pi === pl) {\n      // ran out of pattern, still have file left.\n      // this is only acceptable if we're on the very last\n      // empty segment of a file with a trailing slash.\n      // a/* should match a/b/\n      return (fi === fl - 1) && (file[fi] === '')\n    }\n\n    // should be unreachable.\n    /* istanbul ignore next */\n    throw new Error('wtf?')\n  }\n\n  braceExpand () {\n    return braceExpand(this.pattern, this.options)\n  }\n\n  parse (pattern, isSub) {\n    assertValidPattern(pattern)\n\n    const options = this.options\n\n    // shortcuts\n    if (pattern === '**') {\n      if (!options.noglobstar)\n        return GLOBSTAR\n      else\n        pattern = '*'\n    }\n    if (pattern === '') return ''\n\n    let re = ''\n    let hasMagic = false\n    let escaping = false\n    // ? => one single character\n    const patternListStack = []\n    const negativeLists = []\n    let stateChar\n    let inClass = false\n    let reClassStart = -1\n    let classStart = -1\n    let cs\n    let pl\n    let sp\n    // . and .. never match anything that doesn't start with .,\n    // even when options.dot is set.  However, if the pattern\n    // starts with ., then traversal patterns can match.\n    let dotTravAllowed = pattern.charAt(0) === '.'\n    let dotFileAllowed = options.dot || dotTravAllowed\n    const patternStart = () =>\n      dotTravAllowed\n        ? ''\n        : dotFileAllowed\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n    const subPatternStart = (p) =>\n      p.charAt(0) === '.'\n        ? ''\n        : options.dot\n        ? '(?!(?:^|\\\\/)\\\\.{1,2}(?:$|\\\\/))'\n        : '(?!\\\\.)'\n\n\n    const clearStateChar = () => {\n      if (stateChar) {\n        // we had some state-tracking character\n        // that wasn't consumed by this pass.\n        switch (stateChar) {\n          case '*':\n            re += star\n            hasMagic = true\n          break\n          case '?':\n            re += qmark\n            hasMagic = true\n          break\n          default:\n            re += '\\\\' + stateChar\n          break\n        }\n        this.debug('clearStateChar %j %j', stateChar, re)\n        stateChar = false\n      }\n    }\n\n    for (let i = 0, c; (i < pattern.length) && (c = pattern.charAt(i)); i++) {\n      this.debug('%s\\t%s %s %j', pattern, i, re, c)\n\n      // skip over any that are escaped.\n      if (escaping) {\n        /* istanbul ignore next - completely not allowed, even escaped. */\n        if (c === '/') {\n          return false\n        }\n\n        if (reSpecials[c]) {\n          re += '\\\\'\n        }\n        re += c\n        escaping = false\n        continue\n      }\n\n      switch (c) {\n        /* istanbul ignore next */\n        case '/': {\n          // Should already be path-split by now.\n          return false\n        }\n\n        case '\\\\':\n          if (inClass && pattern.charAt(i + 1) === '-') {\n            re += c\n            continue\n          }\n\n          clearStateChar()\n          escaping = true\n        continue\n\n        // the various stateChar values\n        // for the \"extglob\" stuff.\n        case '?':\n        case '*':\n        case '+':\n        case '@':\n        case '!':\n          this.debug('%s\\t%s %s %j <-- stateChar', pattern, i, re, c)\n\n          // all of those are literals inside a class, except that\n          // the glob [!a] means [^a] in regexp\n          if (inClass) {\n            this.debug('  in class')\n            if (c === '!' && i === classStart + 1) c = '^'\n            re += c\n            continue\n          }\n\n          // if we already have a stateChar, then it means\n          // that there was something like ** or +? in there.\n          // Handle the stateChar, then proceed with this one.\n          this.debug('call clearStateChar %j', stateChar)\n          clearStateChar()\n          stateChar = c\n          // if extglob is disabled, then +(asdf|foo) isn't a thing.\n          // just clear the statechar *now*, rather than even diving into\n          // the patternList stuff.\n          if (options.noext) clearStateChar()\n        continue\n\n        case '(': {\n          if (inClass) {\n            re += '('\n            continue\n          }\n\n          if (!stateChar) {\n            re += '\\\\('\n            continue\n          }\n\n          const plEntry = {\n            type: stateChar,\n            start: i - 1,\n            reStart: re.length,\n            open: plTypes[stateChar].open,\n            close: plTypes[stateChar].close,\n          }\n          this.debug(this.pattern, '\\t', plEntry)\n          patternListStack.push(plEntry)\n          // negation is (?:(?!(?:js)(?:<rest>))[^/]*)\n          re += plEntry.open\n          // next entry starts with a dot maybe?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          this.debug('plType %j %j', stateChar, re)\n          stateChar = false\n          continue\n        }\n\n        case ')': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\)'\n            continue\n          }\n          patternListStack.pop()\n\n          // closing an extglob\n          clearStateChar()\n          hasMagic = true\n          pl = plEntry\n          // negation is (?:(?!js)[^/]*)\n          // The others are (?:<pattern>)<type>\n          re += pl.close\n          if (pl.type === '!') {\n            negativeLists.push(Object.assign(pl, { reEnd: re.length }))\n          }\n          continue\n        }\n\n        case '|': {\n          const plEntry = patternListStack[patternListStack.length - 1]\n          if (inClass || !plEntry) {\n            re += '\\\\|'\n            continue\n          }\n\n          clearStateChar()\n          re += '|'\n          // next subpattern can start with a dot?\n          if (plEntry.start === 0 && plEntry.type !== '!') {\n            dotTravAllowed = true\n            re += subPatternStart(pattern.slice(i + 1))\n          }\n          continue\n        }\n\n        // these are mostly the same in regexp and glob\n        case '[':\n          // swallow any state-tracking char before the [\n          clearStateChar()\n\n          if (inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          inClass = true\n          classStart = i\n          reClassStart = re.length\n          re += c\n        continue\n\n        case ']':\n          //  a right bracket shall lose its special\n          //  meaning and represent itself in\n          //  a bracket expression if it occurs\n          //  first in the list.  -- POSIX.2 2.8.3.2\n          if (i === classStart + 1 || !inClass) {\n            re += '\\\\' + c\n            continue\n          }\n\n          // split where the last [ was, make sure we don't have\n          // an invalid re. if so, re-walk the contents of the\n          // would-be class to re-translate any characters that\n          // were passed through as-is\n          // TODO: It would probably be faster to determine this\n          // without a try/catch and a new RegExp, but it's tricky\n          // to do safely.  For now, this is safe and works.\n          cs = pattern.substring(classStart + 1, i)\n          try {\n            RegExp('[' + braExpEscape(charUnescape(cs)) + ']')\n            // looks good, finish up the class.\n            re += c\n          } catch (er) {\n            // out of order ranges in JS are errors, but in glob syntax,\n            // they're just a range that matches nothing.\n            re = re.substring(0, reClassStart) + '(?:$.)' // match nothing ever\n          }\n          hasMagic = true\n          inClass = false\n        continue\n\n        default:\n          // swallow any state char that wasn't consumed\n          clearStateChar()\n\n          if (reSpecials[c] && !(c === '^' && inClass)) {\n            re += '\\\\'\n          }\n\n          re += c\n          break\n\n      } // switch\n    } // for\n\n    // handle the case where we left a class open.\n    // \"[abc\" is valid, equivalent to \"\\[abc\"\n    if (inClass) {\n      // split where the last [ was, and escape it\n      // this is a huge pita.  We now have to re-walk\n      // the contents of the would-be class to re-translate\n      // any characters that were passed through as-is\n      cs = pattern.slice(classStart + 1)\n      sp = this.parse(cs, SUBPARSE)\n      re = re.substring(0, reClassStart) + '\\\\[' + sp[0]\n      hasMagic = hasMagic || sp[1]\n    }\n\n    // handle the case where we had a +( thing at the *end*\n    // of the pattern.\n    // each pattern list stack adds 3 chars, and we need to go through\n    // and escape any | chars that were passed through as-is for the regexp.\n    // Go through and escape them, taking care not to double-escape any\n    // | chars that were already escaped.\n    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {\n      let tail\n      tail = re.slice(pl.reStart + pl.open.length)\n      this.debug('setting tail', re, pl)\n      // maybe some even number of \\, then maybe 1 \\, followed by a |\n      tail = tail.replace(/((?:\\\\{2}){0,64})(\\\\?)\\|/g, (_, $1, $2) => {\n        /* istanbul ignore else - should already be done */\n        if (!$2) {\n          // the | isn't already escaped, so escape it.\n          $2 = '\\\\'\n        }\n\n        // need to escape all those slashes *again*, without escaping the\n        // one that we need for escaping the | character.  As it works out,\n        // escaping an even number of slashes can be done by simply repeating\n        // it exactly after itself.  That's why this trick works.\n        //\n        // I am sorry that you have to see this.\n        return $1 + $1 + $2 + '|'\n      })\n\n      this.debug('tail=%j\\n   %s', tail, tail, pl, re)\n      const t = pl.type === '*' ? star\n        : pl.type === '?' ? qmark\n        : '\\\\' + pl.type\n\n      hasMagic = true\n      re = re.slice(0, pl.reStart) + t + '\\\\(' + tail\n    }\n\n    // handle trailing things that only matter at the very end.\n    clearStateChar()\n    if (escaping) {\n      // trailing \\\\\n      re += '\\\\\\\\'\n    }\n\n    // only need to apply the nodot start if the re starts with\n    // something that could conceivably capture a dot\n    const addPatternStart = addPatternStartSet[re.charAt(0)]\n\n    // Hack to work around lack of negative lookbehind in JS\n    // A pattern like: *.!(x).!(y|z) needs to ensure that a name\n    // like 'a.xyz.yz' doesn't match.  So, the first negative\n    // lookahead, has to look ALL the way ahead, to the end of\n    // the pattern.\n    for (let n = negativeLists.length - 1; n > -1; n--) {\n      const nl = negativeLists[n]\n\n      const nlBefore = re.slice(0, nl.reStart)\n      const nlFirst = re.slice(nl.reStart, nl.reEnd - 8)\n      let nlAfter = re.slice(nl.reEnd)\n      const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter\n\n      // Handle nested stuff like *(*.js|!(*.json)), where open parens\n      // mean that we should *not* include the ) in the bit that is considered\n      // \"after\" the negated section.\n      const closeParensBefore = nlBefore.split(')').length\n      const openParensBefore = nlBefore.split('(').length - closeParensBefore\n      let cleanAfter = nlAfter\n      for (let i = 0; i < openParensBefore; i++) {\n        cleanAfter = cleanAfter.replace(/\\)[+*?]?/, '')\n      }\n      nlAfter = cleanAfter\n\n      const dollar = nlAfter === '' && isSub !== SUBPARSE ? '(?:$|\\\\/)' : ''\n\n      re = nlBefore + nlFirst + nlAfter + dollar + nlLast\n    }\n\n    // if the re is not \"\" at this point, then we need to make sure\n    // it doesn't match against an empty path part.\n    // Otherwise a/* will match a/, which it should not.\n    if (re !== '' && hasMagic) {\n      re = '(?=.)' + re\n    }\n\n    if (addPatternStart) {\n      re = patternStart() + re\n    }\n\n    // parsing just a piece of a larger pattern.\n    if (isSub === SUBPARSE) {\n      return [re, hasMagic]\n    }\n\n    // if it's nocase, and the lcase/uppercase don't match, it's magic\n    if (options.nocase && !hasMagic) {\n      hasMagic = pattern.toUpperCase() !== pattern.toLowerCase()\n    }\n\n    // skip the regexp for non-magical patterns\n    // unescape anything in it, though, so that it'll be\n    // an exact match against a file etc.\n    if (!hasMagic) {\n      return globUnescape(pattern)\n    }\n\n    const flags = options.nocase ? 'i' : ''\n    try {\n      return Object.assign(new RegExp('^' + re + '$', flags), {\n        _glob: pattern,\n        _src: re,\n      })\n    } catch (er) /* istanbul ignore next - should be impossible */ {\n      // If it was an invalid regular expression, then it can't match\n      // anything.  This trick looks for a character after the end of\n      // the string, which is of course impossible, except in multi-line\n      // mode, but it's not a /m regex.\n      return new RegExp('$.')\n    }\n  }\n\n  makeRe () {\n    if (this.regexp || this.regexp === false) return this.regexp\n\n    // at this point, this.set is a 2d array of partial\n    // pattern strings, or \"**\".\n    //\n    // It's better to use .match().  This function shouldn't\n    // be used, really, but it's pretty convenient sometimes,\n    // when you just want to work with a regex.\n    const set = this.set\n\n    if (!set.length) {\n      this.regexp = false\n      return this.regexp\n    }\n    const options = this.options\n\n    const twoStar = options.noglobstar ? star\n      : options.dot ? twoStarDot\n      : twoStarNoDot\n    const flags = options.nocase ? 'i' : ''\n\n    // coalesce globstars and regexpify non-globstar patterns\n    // if it's the only item, then we just do one twoStar\n    // if it's the first, and there are more, prepend (\\/|twoStar\\/)? to next\n    // if it's the last, append (\\/twoStar|) to previous\n    // if it's in the middle, append (\\/|\\/twoStar\\/) to previous\n    // then filter out GLOBSTAR symbols\n    let re = set.map(pattern => {\n      pattern = pattern.map(p =>\n        typeof p === 'string' ? regExpEscape(p)\n        : p === GLOBSTAR ? GLOBSTAR\n        : p._src\n      ).reduce((set, p) => {\n        if (!(set[set.length - 1] === GLOBSTAR && p === GLOBSTAR)) {\n          set.push(p)\n        }\n        return set\n      }, [])\n      pattern.forEach((p, i) => {\n        if (p !== GLOBSTAR || pattern[i-1] === GLOBSTAR) {\n          return\n        }\n        if (i === 0) {\n          if (pattern.length > 1) {\n            pattern[i+1] = '(?:\\\\\\/|' + twoStar + '\\\\\\/)?' + pattern[i+1]\n          } else {\n            pattern[i] = twoStar\n          }\n        } else if (i === pattern.length - 1) {\n          pattern[i-1] += '(?:\\\\\\/|' + twoStar + ')?'\n        } else {\n          pattern[i-1] += '(?:\\\\\\/|\\\\\\/' + twoStar + '\\\\\\/)' + pattern[i+1]\n          pattern[i+1] = GLOBSTAR\n        }\n      })\n      return pattern.filter(p => p !== GLOBSTAR).join('/')\n    }).join('|')\n\n    // must match entire pattern\n    // ending in a * or ** will make it less strict.\n    re = '^(?:' + re + ')$'\n\n    // can match anything, as long as it's not this.\n    if (this.negate) re = '^(?!' + re + ').*$'\n\n    try {\n      this.regexp = new RegExp(re, flags)\n    } catch (ex) /* istanbul ignore next - should be impossible */ {\n      this.regexp = false\n    }\n    return this.regexp\n  }\n\n  match (f, partial = this.partial) {\n    this.debug('match', f, this.pattern)\n    // short-circuit in the case of busted things.\n    // comments, etc.\n    if (this.comment) return false\n    if (this.empty) return f === ''\n\n    if (f === '/' && partial) return true\n\n    const options = this.options\n\n    // windows: need to use /, not \\\n    if (path.sep !== '/') {\n      f = f.split(path.sep).join('/')\n    }\n\n    // treat the test path as a set of pathparts.\n    f = f.split(slashSplit)\n    this.debug(this.pattern, 'split', f)\n\n    // just ONE of the pattern sets in this.set needs to match\n    // in order for it to be valid.  If negating, then just one\n    // match means that we have failed.\n    // Either way, return on the first hit.\n\n    const set = this.set\n    this.debug(this.pattern, 'set', set)\n\n    // Find the basename of the path by looking for the last non-empty segment\n    let filename\n    for (let i = f.length - 1; i >= 0; i--) {\n      filename = f[i]\n      if (filename) break\n    }\n\n    for (let i = 0; i < set.length; i++) {\n      const pattern = set[i]\n      let file = f\n      if (options.matchBase && pattern.length === 1) {\n        file = [filename]\n      }\n      const hit = this.matchOne(file, pattern, partial)\n      if (hit) {\n        if (options.flipNegate) return true\n        return !this.negate\n      }\n    }\n\n    // didn't get any hits.  this is success if it's a negative\n    // pattern, failure otherwise.\n    if (options.flipNegate) return false\n    return this.negate\n  }\n\n  static defaults (def) {\n    return minimatch.defaults(def).Minimatch\n  }\n}\n\nminimatch.Minimatch = Minimatch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}