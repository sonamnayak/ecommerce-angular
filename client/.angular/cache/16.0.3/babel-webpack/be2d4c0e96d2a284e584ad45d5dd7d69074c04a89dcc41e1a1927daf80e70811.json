{"ast":null,"code":"// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE\n} = require('../errors.js');\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR\n    }\n  }\n} = require('os');\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes\n} = require('../fs.js');\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath\n} = require('path');\nconst {\n  fileURLToPath\n} = require('url');\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false\n};\nfunction cp(_x, _x2, _x3) {\n  return _cp.apply(this, arguments);\n}\nfunction _cp() {\n  _cp = _asyncToGenerator(function* (src, dest, opts) {\n    if (opts != null && typeof opts !== 'object') {\n      throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts);\n    }\n    return cpFn(toNamespacedPath(getValidatedPath(src)), toNamespacedPath(getValidatedPath(dest)), {\n      ...defaultOptions,\n      ...opts\n    });\n  });\n  return _cp.apply(this, arguments);\n}\nfunction getValidatedPath(fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href && fileURLOrPath.origin ? fileURLToPath(fileURLOrPath) : fileURLOrPath;\n  return path;\n}\nfunction cpFn(_x4, _x5, _x6) {\n  return _cpFn.apply(this, arguments);\n}\nfunction _cpFn() {\n  _cpFn = _asyncToGenerator(function* (src, dest, opts) {\n    // Warn about using preserveTimestamps on 32-bit node\n    // istanbul ignore next\n    if (opts.preserveTimestamps && process.arch === 'ia32') {\n      const warning = 'Using the preserveTimestamps option in 32-bit ' + 'node is not recommended';\n      process.emitWarning(warning, 'TimestampPrecisionWarning');\n    }\n    const stats = yield checkPaths(src, dest, opts);\n    const {\n      srcStat,\n      destStat\n    } = stats;\n    yield checkParentPaths(src, srcStat, dest);\n    if (opts.filter) {\n      return handleFilter(checkParentDir, destStat, src, dest, opts);\n    }\n    return checkParentDir(destStat, src, dest, opts);\n  });\n  return _cpFn.apply(this, arguments);\n}\nfunction checkPaths(_x7, _x8, _x9) {\n  return _checkPaths.apply(this, arguments);\n}\nfunction _checkPaths() {\n  _checkPaths = _asyncToGenerator(function* (src, dest, opts) {\n    const {\n      0: srcStat,\n      1: destStat\n    } = yield getStats(src, dest, opts);\n    if (destStat) {\n      if (areIdentical(srcStat, destStat)) {\n        throw new ERR_FS_CP_EINVAL({\n          message: 'src and dest cannot be the same',\n          path: dest,\n          syscall: 'cp',\n          errno: EINVAL\n        });\n      }\n      if (srcStat.isDirectory() && !destStat.isDirectory()) {\n        throw new ERR_FS_CP_DIR_TO_NON_DIR({\n          message: `cannot overwrite directory ${src} ` + `with non-directory ${dest}`,\n          path: dest,\n          syscall: 'cp',\n          errno: EISDIR\n        });\n      }\n      if (!srcStat.isDirectory() && destStat.isDirectory()) {\n        throw new ERR_FS_CP_NON_DIR_TO_DIR({\n          message: `cannot overwrite non-directory ${src} ` + `with directory ${dest}`,\n          path: dest,\n          syscall: 'cp',\n          errno: ENOTDIR\n        });\n      }\n    }\n    if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    return {\n      srcStat,\n      destStat\n    };\n  });\n  return _checkPaths.apply(this, arguments);\n}\nfunction areIdentical(srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;\n}\nfunction getStats(src, dest, opts) {\n  const statFunc = opts.dereference ? file => stat(file, {\n    bigint: true\n  }) : file => lstat(file, {\n    bigint: true\n  });\n  return Promise.all([statFunc(src), statFunc(dest).catch(err => {\n    // istanbul ignore next: unsure how to cover.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n    // istanbul ignore next: unsure how to cover.\n    throw err;\n  })]);\n}\nfunction checkParentDir(_x10, _x11, _x12, _x13) {\n  return _checkParentDir.apply(this, arguments);\n}\nfunction _checkParentDir() {\n  _checkParentDir = _asyncToGenerator(function* (destStat, src, dest, opts) {\n    const destParent = dirname(dest);\n    const dirExists = yield pathExists(destParent);\n    if (dirExists) {\n      return getStatsForCopy(destStat, src, dest, opts);\n    }\n    yield mkdir(destParent, {\n      recursive: true\n    });\n    return getStatsForCopy(destStat, src, dest, opts);\n  });\n  return _checkParentDir.apply(this, arguments);\n}\nfunction pathExists(dest) {\n  return stat(dest).then(() => true,\n  // istanbul ignore next: not sure when this would occur\n  err => err.code === 'ENOENT' ? false : Promise.reject(err));\n}\n\n// Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nfunction checkParentPaths(_x14, _x15, _x16) {\n  return _checkParentPaths.apply(this, arguments);\n}\nfunction _checkParentPaths() {\n  _checkParentPaths = _asyncToGenerator(function* (src, srcStat, dest) {\n    const srcParent = resolve(dirname(src));\n    const destParent = resolve(dirname(dest));\n    if (destParent === srcParent || destParent === parse(destParent).root) {\n      return;\n    }\n    let destStat;\n    try {\n      destStat = yield stat(destParent, {\n        bigint: true\n      });\n    } catch (err) {\n      // istanbul ignore else: not sure when this would occur\n      if (err.code === 'ENOENT') {\n        return;\n      }\n      // istanbul ignore next: not sure when this would occur\n      throw err;\n    }\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    return checkParentPaths(src, srcStat, destParent);\n  });\n  return _checkParentPaths.apply(this, arguments);\n}\nconst normalizePathToArray = path => resolve(path).split(sep).filter(Boolean);\n\n// Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir(src, dest) {\n  const srcArr = normalizePathToArray(src);\n  const destArr = normalizePathToArray(dest);\n  return srcArr.every((cur, i) => destArr[i] === cur);\n}\nfunction handleFilter(_x17, _x18, _x19, _x20, _x21, _x22) {\n  return _handleFilter.apply(this, arguments);\n}\nfunction _handleFilter() {\n  _handleFilter = _asyncToGenerator(function* (onInclude, destStat, src, dest, opts, cb) {\n    const include = yield opts.filter(src, dest);\n    if (include) {\n      return onInclude(destStat, src, dest, opts, cb);\n    }\n  });\n  return _handleFilter.apply(this, arguments);\n}\nfunction startCopy(destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts);\n  }\n  return getStatsForCopy(destStat, src, dest, opts);\n}\nfunction getStatsForCopy(_x23, _x24, _x25, _x26) {\n  return _getStatsForCopy.apply(this, arguments);\n}\nfunction _getStatsForCopy() {\n  _getStatsForCopy = _asyncToGenerator(function* (destStat, src, dest, opts) {\n    const statFn = opts.dereference ? stat : lstat;\n    const srcStat = yield statFn(src);\n    // istanbul ignore else: can't portably test FIFO\n    if (srcStat.isDirectory() && opts.recursive) {\n      return onDir(srcStat, destStat, src, dest, opts);\n    } else if (srcStat.isDirectory()) {\n      throw new ERR_FS_EISDIR({\n        message: `${src} is a directory (not copied)`,\n        path: src,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) {\n      return onFile(srcStat, destStat, src, dest, opts);\n    } else if (srcStat.isSymbolicLink()) {\n      return onLink(destStat, src, dest);\n    } else if (srcStat.isSocket()) {\n      throw new ERR_FS_CP_SOCKET({\n        message: `cannot copy a socket file: ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    } else if (srcStat.isFIFO()) {\n      throw new ERR_FS_CP_FIFO_PIPE({\n        message: `cannot copy a FIFO pipe: ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    // istanbul ignore next: should be unreachable\n    throw new ERR_FS_CP_UNKNOWN({\n      message: `cannot copy an unknown file type: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL\n    });\n  });\n  return _getStatsForCopy.apply(this, arguments);\n}\nfunction onFile(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts);\n  }\n  return mayCopyFile(srcStat, src, dest, opts);\n}\nfunction mayCopyFile(_x27, _x28, _x29, _x30) {\n  return _mayCopyFile.apply(this, arguments);\n}\nfunction _mayCopyFile() {\n  _mayCopyFile = _asyncToGenerator(function* (srcStat, src, dest, opts) {\n    if (opts.force) {\n      yield unlink(dest);\n      return _copyFile(srcStat, src, dest, opts);\n    } else if (opts.errorOnExist) {\n      throw new ERR_FS_CP_EEXIST({\n        message: `${dest} already exists`,\n        path: dest,\n        syscall: 'cp',\n        errno: EEXIST\n      });\n    }\n  });\n  return _mayCopyFile.apply(this, arguments);\n}\nfunction _copyFile(_x31, _x32, _x33, _x34) {\n  return _copyFile2.apply(this, arguments);\n}\nfunction _copyFile2() {\n  _copyFile2 = _asyncToGenerator(function* (srcStat, src, dest, opts) {\n    yield copyFile(src, dest);\n    if (opts.preserveTimestamps) {\n      return handleTimestampsAndMode(srcStat.mode, src, dest);\n    }\n    return setDestMode(dest, srcStat.mode);\n  });\n  return _copyFile2.apply(this, arguments);\n}\nfunction handleTimestampsAndMode(_x35, _x36, _x37) {\n  return _handleTimestampsAndMode.apply(this, arguments);\n}\nfunction _handleTimestampsAndMode() {\n  _handleTimestampsAndMode = _asyncToGenerator(function* (srcMode, src, dest) {\n    // Make sure the file is writable before setting the timestamp\n    // otherwise open fails with EPERM when invoked with 'r+'\n    // (through utimes call)\n    if (fileIsNotWritable(srcMode)) {\n      yield makeFileWritable(dest, srcMode);\n      return setDestTimestampsAndMode(srcMode, src, dest);\n    }\n    return setDestTimestampsAndMode(srcMode, src, dest);\n  });\n  return _handleTimestampsAndMode.apply(this, arguments);\n}\nfunction fileIsNotWritable(srcMode) {\n  return (srcMode & 0o200) === 0;\n}\nfunction makeFileWritable(dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200);\n}\nfunction setDestTimestampsAndMode(_x38, _x39, _x40) {\n  return _setDestTimestampsAndMode.apply(this, arguments);\n}\nfunction _setDestTimestampsAndMode() {\n  _setDestTimestampsAndMode = _asyncToGenerator(function* (srcMode, src, dest) {\n    yield setDestTimestamps(src, dest);\n    return setDestMode(dest, srcMode);\n  });\n  return _setDestTimestampsAndMode.apply(this, arguments);\n}\nfunction setDestMode(dest, srcMode) {\n  return chmod(dest, srcMode);\n}\nfunction setDestTimestamps(_x41, _x42) {\n  return _setDestTimestamps.apply(this, arguments);\n}\nfunction _setDestTimestamps() {\n  _setDestTimestamps = _asyncToGenerator(function* (src, dest) {\n    // The initial srcStat.atime cannot be trusted\n    // because it is modified by the read(2) system call\n    // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n    const updatedSrcStat = yield stat(src);\n    return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime);\n  });\n  return _setDestTimestamps.apply(this, arguments);\n}\nfunction onDir(srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts);\n  }\n  return copyDir(src, dest, opts);\n}\nfunction mkDirAndCopy(_x43, _x44, _x45, _x46) {\n  return _mkDirAndCopy.apply(this, arguments);\n}\nfunction _mkDirAndCopy() {\n  _mkDirAndCopy = _asyncToGenerator(function* (srcMode, src, dest, opts) {\n    yield mkdir(dest);\n    yield copyDir(src, dest, opts);\n    return setDestMode(dest, srcMode);\n  });\n  return _mkDirAndCopy.apply(this, arguments);\n}\nfunction copyDir(_x47, _x48, _x49) {\n  return _copyDir.apply(this, arguments);\n}\nfunction _copyDir() {\n  _copyDir = _asyncToGenerator(function* (src, dest, opts) {\n    const dir = yield readdir(src);\n    for (let i = 0; i < dir.length; i++) {\n      const item = dir[i];\n      const srcItem = join(src, item);\n      const destItem = join(dest, item);\n      const {\n        destStat\n      } = yield checkPaths(srcItem, destItem, opts);\n      yield startCopy(destStat, srcItem, destItem, opts);\n    }\n  });\n  return _copyDir.apply(this, arguments);\n}\nfunction onLink(_x50, _x51, _x52) {\n  return _onLink.apply(this, arguments);\n}\nfunction _onLink() {\n  _onLink = _asyncToGenerator(function* (destStat, src, dest) {\n    let resolvedSrc = yield readlink(src);\n    if (!isAbsolute(resolvedSrc)) {\n      resolvedSrc = resolve(dirname(src), resolvedSrc);\n    }\n    if (!destStat) {\n      return symlink(resolvedSrc, dest);\n    }\n    let resolvedDest;\n    try {\n      resolvedDest = yield readlink(dest);\n    } catch (err) {\n      // Dest exists and is a regular file or directory,\n      // Windows may throw UNKNOWN error. If dest already exists,\n      // fs throws error anyway, so no need to guard against it here.\n      // istanbul ignore next: can only test on windows\n      if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n        return symlink(resolvedSrc, dest);\n      }\n      // istanbul ignore next: should not be possible\n      throw err;\n    }\n    if (!isAbsolute(resolvedDest)) {\n      resolvedDest = resolve(dirname(dest), resolvedDest);\n    }\n    if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: `cannot copy ${resolvedSrc} to a subdirectory of self ` + `${resolvedDest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    // Do not copy if src is a subdir of dest since unlinking\n    // dest in this case would result in removing src contents\n    // and therefore a broken symlink would be created.\n    const srcStat = yield stat(src);\n    if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n      throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n        message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL\n      });\n    }\n    return copyLink(resolvedSrc, dest);\n  });\n  return _onLink.apply(this, arguments);\n}\nfunction copyLink(_x53, _x54) {\n  return _copyLink.apply(this, arguments);\n}\nfunction _copyLink() {\n  _copyLink = _asyncToGenerator(function* (resolvedSrc, dest) {\n    yield unlink(dest);\n    return symlink(resolvedSrc, dest);\n  });\n  return _copyLink.apply(this, arguments);\n}\nmodule.exports = cp;","map":{"version":3,"names":["_asyncToGenerator","require","default","ERR_FS_CP_DIR_TO_NON_DIR","ERR_FS_CP_EEXIST","ERR_FS_CP_EINVAL","ERR_FS_CP_FIFO_PIPE","ERR_FS_CP_NON_DIR_TO_DIR","ERR_FS_CP_SOCKET","ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY","ERR_FS_CP_UNKNOWN","ERR_FS_EISDIR","ERR_INVALID_ARG_TYPE","constants","errno","EEXIST","EISDIR","EINVAL","ENOTDIR","chmod","copyFile","lstat","mkdir","readdir","readlink","stat","symlink","unlink","utimes","dirname","isAbsolute","join","parse","resolve","sep","toNamespacedPath","fileURLToPath","defaultOptions","dereference","errorOnExist","filter","undefined","force","preserveTimestamps","recursive","cp","_x","_x2","_x3","_cp","apply","arguments","src","dest","opts","cpFn","getValidatedPath","fileURLOrPath","path","href","origin","_x4","_x5","_x6","_cpFn","process","arch","warning","emitWarning","stats","checkPaths","srcStat","destStat","checkParentPaths","handleFilter","checkParentDir","_x7","_x8","_x9","_checkPaths","getStats","areIdentical","message","syscall","isDirectory","isSrcSubdir","ino","dev","statFunc","file","bigint","Promise","all","catch","err","code","_x10","_x11","_x12","_x13","_checkParentDir","destParent","dirExists","pathExists","getStatsForCopy","then","reject","_x14","_x15","_x16","_checkParentPaths","srcParent","root","normalizePathToArray","split","Boolean","srcArr","destArr","every","cur","i","_x17","_x18","_x19","_x20","_x21","_x22","_handleFilter","onInclude","cb","include","startCopy","_x23","_x24","_x25","_x26","_getStatsForCopy","statFn","onDir","isFile","isCharacterDevice","isBlockDevice","onFile","isSymbolicLink","onLink","isSocket","isFIFO","_copyFile","mayCopyFile","_x27","_x28","_x29","_x30","_mayCopyFile","_x31","_x32","_x33","_x34","_copyFile2","handleTimestampsAndMode","mode","setDestMode","_x35","_x36","_x37","_handleTimestampsAndMode","srcMode","fileIsNotWritable","makeFileWritable","setDestTimestampsAndMode","_x38","_x39","_x40","_setDestTimestampsAndMode","setDestTimestamps","_x41","_x42","_setDestTimestamps","updatedSrcStat","atime","mtime","mkDirAndCopy","copyDir","_x43","_x44","_x45","_x46","_mkDirAndCopy","_x47","_x48","_x49","_copyDir","dir","length","item","srcItem","destItem","_x50","_x51","_x52","_onLink","resolvedSrc","resolvedDest","copyLink","_x53","_x54","_copyLink","module","exports"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/@npmcli/fs/lib/cp/polyfill.js"],"sourcesContent":["// this file is a modified version of the code in node 17.2.0\n// which is, in turn, a modified version of the fs-extra module on npm\n// node core changes:\n// - Use of the assert module has been replaced with core's error system.\n// - All code related to the glob dependency has been removed.\n// - Bring your own custom fs module is not currently supported.\n// - Some basic code cleanup.\n// changes here:\n// - remove all callback related code\n// - drop sync support\n// - change assertions back to non-internal methods (see options.js)\n// - throws ENOTDIR when rmdir gets an ENOENT for a path that exists in Windows\n'use strict'\n\nconst {\n  ERR_FS_CP_DIR_TO_NON_DIR,\n  ERR_FS_CP_EEXIST,\n  ERR_FS_CP_EINVAL,\n  ERR_FS_CP_FIFO_PIPE,\n  ERR_FS_CP_NON_DIR_TO_DIR,\n  ERR_FS_CP_SOCKET,\n  ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY,\n  ERR_FS_CP_UNKNOWN,\n  ERR_FS_EISDIR,\n  ERR_INVALID_ARG_TYPE,\n} = require('../errors.js')\nconst {\n  constants: {\n    errno: {\n      EEXIST,\n      EISDIR,\n      EINVAL,\n      ENOTDIR,\n    },\n  },\n} = require('os')\nconst {\n  chmod,\n  copyFile,\n  lstat,\n  mkdir,\n  readdir,\n  readlink,\n  stat,\n  symlink,\n  unlink,\n  utimes,\n} = require('../fs.js')\nconst {\n  dirname,\n  isAbsolute,\n  join,\n  parse,\n  resolve,\n  sep,\n  toNamespacedPath,\n} = require('path')\nconst { fileURLToPath } = require('url')\n\nconst defaultOptions = {\n  dereference: false,\n  errorOnExist: false,\n  filter: undefined,\n  force: true,\n  preserveTimestamps: false,\n  recursive: false,\n}\n\nasync function cp (src, dest, opts) {\n  if (opts != null && typeof opts !== 'object') {\n    throw new ERR_INVALID_ARG_TYPE('options', ['Object'], opts)\n  }\n  return cpFn(\n    toNamespacedPath(getValidatedPath(src)),\n    toNamespacedPath(getValidatedPath(dest)),\n    { ...defaultOptions, ...opts })\n}\n\nfunction getValidatedPath (fileURLOrPath) {\n  const path = fileURLOrPath != null && fileURLOrPath.href\n      && fileURLOrPath.origin\n    ? fileURLToPath(fileURLOrPath)\n    : fileURLOrPath\n  return path\n}\n\nasync function cpFn (src, dest, opts) {\n  // Warn about using preserveTimestamps on 32-bit node\n  // istanbul ignore next\n  if (opts.preserveTimestamps && process.arch === 'ia32') {\n    const warning = 'Using the preserveTimestamps option in 32-bit ' +\n      'node is not recommended'\n    process.emitWarning(warning, 'TimestampPrecisionWarning')\n  }\n  const stats = await checkPaths(src, dest, opts)\n  const { srcStat, destStat } = stats\n  await checkParentPaths(src, srcStat, dest)\n  if (opts.filter) {\n    return handleFilter(checkParentDir, destStat, src, dest, opts)\n  }\n  return checkParentDir(destStat, src, dest, opts)\n}\n\nasync function checkPaths (src, dest, opts) {\n  const { 0: srcStat, 1: destStat } = await getStats(src, dest, opts)\n  if (destStat) {\n    if (areIdentical(srcStat, destStat)) {\n      throw new ERR_FS_CP_EINVAL({\n        message: 'src and dest cannot be the same',\n        path: dest,\n        syscall: 'cp',\n        errno: EINVAL,\n      })\n    }\n    if (srcStat.isDirectory() && !destStat.isDirectory()) {\n      throw new ERR_FS_CP_DIR_TO_NON_DIR({\n        message: `cannot overwrite directory ${src} ` +\n            `with non-directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: EISDIR,\n      })\n    }\n    if (!srcStat.isDirectory() && destStat.isDirectory()) {\n      throw new ERR_FS_CP_NON_DIR_TO_DIR({\n        message: `cannot overwrite non-directory ${src} ` +\n            `with directory ${dest}`,\n        path: dest,\n        syscall: 'cp',\n        errno: ENOTDIR,\n      })\n    }\n  }\n\n  if (srcStat.isDirectory() && isSrcSubdir(src, dest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return { srcStat, destStat }\n}\n\nfunction areIdentical (srcStat, destStat) {\n  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino &&\n    destStat.dev === srcStat.dev\n}\n\nfunction getStats (src, dest, opts) {\n  const statFunc = opts.dereference ?\n    (file) => stat(file, { bigint: true }) :\n    (file) => lstat(file, { bigint: true })\n  return Promise.all([\n    statFunc(src),\n    statFunc(dest).catch((err) => {\n      // istanbul ignore next: unsure how to cover.\n      if (err.code === 'ENOENT') {\n        return null\n      }\n      // istanbul ignore next: unsure how to cover.\n      throw err\n    }),\n  ])\n}\n\nasync function checkParentDir (destStat, src, dest, opts) {\n  const destParent = dirname(dest)\n  const dirExists = await pathExists(destParent)\n  if (dirExists) {\n    return getStatsForCopy(destStat, src, dest, opts)\n  }\n  await mkdir(destParent, { recursive: true })\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nfunction pathExists (dest) {\n  return stat(dest).then(\n    () => true,\n    // istanbul ignore next: not sure when this would occur\n    (err) => (err.code === 'ENOENT' ? false : Promise.reject(err)))\n}\n\n// Recursively check if dest parent is a subdirectory of src.\n// It works for all file types including symlinks since it\n// checks the src and dest inodes. It starts from the deepest\n// parent and stops once it reaches the src parent or the root path.\nasync function checkParentPaths (src, srcStat, dest) {\n  const srcParent = resolve(dirname(src))\n  const destParent = resolve(dirname(dest))\n  if (destParent === srcParent || destParent === parse(destParent).root) {\n    return\n  }\n  let destStat\n  try {\n    destStat = await stat(destParent, { bigint: true })\n  } catch (err) {\n    // istanbul ignore else: not sure when this would occur\n    if (err.code === 'ENOENT') {\n      return\n    }\n    // istanbul ignore next: not sure when this would occur\n    throw err\n  }\n  if (areIdentical(srcStat, destStat)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${src} to a subdirectory of self ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return checkParentPaths(src, srcStat, destParent)\n}\n\nconst normalizePathToArray = (path) =>\n  resolve(path).split(sep).filter(Boolean)\n\n// Return true if dest is a subdir of src, otherwise false.\n// It only checks the path strings.\nfunction isSrcSubdir (src, dest) {\n  const srcArr = normalizePathToArray(src)\n  const destArr = normalizePathToArray(dest)\n  return srcArr.every((cur, i) => destArr[i] === cur)\n}\n\nasync function handleFilter (onInclude, destStat, src, dest, opts, cb) {\n  const include = await opts.filter(src, dest)\n  if (include) {\n    return onInclude(destStat, src, dest, opts, cb)\n  }\n}\n\nfunction startCopy (destStat, src, dest, opts) {\n  if (opts.filter) {\n    return handleFilter(getStatsForCopy, destStat, src, dest, opts)\n  }\n  return getStatsForCopy(destStat, src, dest, opts)\n}\n\nasync function getStatsForCopy (destStat, src, dest, opts) {\n  const statFn = opts.dereference ? stat : lstat\n  const srcStat = await statFn(src)\n  // istanbul ignore else: can't portably test FIFO\n  if (srcStat.isDirectory() && opts.recursive) {\n    return onDir(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isDirectory()) {\n    throw new ERR_FS_EISDIR({\n      message: `${src} is a directory (not copied)`,\n      path: src,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFile() ||\n            srcStat.isCharacterDevice() ||\n            srcStat.isBlockDevice()) {\n    return onFile(srcStat, destStat, src, dest, opts)\n  } else if (srcStat.isSymbolicLink()) {\n    return onLink(destStat, src, dest)\n  } else if (srcStat.isSocket()) {\n    throw new ERR_FS_CP_SOCKET({\n      message: `cannot copy a socket file: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  } else if (srcStat.isFIFO()) {\n    throw new ERR_FS_CP_FIFO_PIPE({\n      message: `cannot copy a FIFO pipe: ${dest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // istanbul ignore next: should be unreachable\n  throw new ERR_FS_CP_UNKNOWN({\n    message: `cannot copy an unknown file type: ${dest}`,\n    path: dest,\n    syscall: 'cp',\n    errno: EINVAL,\n  })\n}\n\nfunction onFile (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return _copyFile(srcStat, src, dest, opts)\n  }\n  return mayCopyFile(srcStat, src, dest, opts)\n}\n\nasync function mayCopyFile (srcStat, src, dest, opts) {\n  if (opts.force) {\n    await unlink(dest)\n    return _copyFile(srcStat, src, dest, opts)\n  } else if (opts.errorOnExist) {\n    throw new ERR_FS_CP_EEXIST({\n      message: `${dest} already exists`,\n      path: dest,\n      syscall: 'cp',\n      errno: EEXIST,\n    })\n  }\n}\n\nasync function _copyFile (srcStat, src, dest, opts) {\n  await copyFile(src, dest)\n  if (opts.preserveTimestamps) {\n    return handleTimestampsAndMode(srcStat.mode, src, dest)\n  }\n  return setDestMode(dest, srcStat.mode)\n}\n\nasync function handleTimestampsAndMode (srcMode, src, dest) {\n  // Make sure the file is writable before setting the timestamp\n  // otherwise open fails with EPERM when invoked with 'r+'\n  // (through utimes call)\n  if (fileIsNotWritable(srcMode)) {\n    await makeFileWritable(dest, srcMode)\n    return setDestTimestampsAndMode(srcMode, src, dest)\n  }\n  return setDestTimestampsAndMode(srcMode, src, dest)\n}\n\nfunction fileIsNotWritable (srcMode) {\n  return (srcMode & 0o200) === 0\n}\n\nfunction makeFileWritable (dest, srcMode) {\n  return setDestMode(dest, srcMode | 0o200)\n}\n\nasync function setDestTimestampsAndMode (srcMode, src, dest) {\n  await setDestTimestamps(src, dest)\n  return setDestMode(dest, srcMode)\n}\n\nfunction setDestMode (dest, srcMode) {\n  return chmod(dest, srcMode)\n}\n\nasync function setDestTimestamps (src, dest) {\n  // The initial srcStat.atime cannot be trusted\n  // because it is modified by the read(2) system call\n  // (See https://nodejs.org/api/fs.html#fs_stat_time_values)\n  const updatedSrcStat = await stat(src)\n  return utimes(dest, updatedSrcStat.atime, updatedSrcStat.mtime)\n}\n\nfunction onDir (srcStat, destStat, src, dest, opts) {\n  if (!destStat) {\n    return mkDirAndCopy(srcStat.mode, src, dest, opts)\n  }\n  return copyDir(src, dest, opts)\n}\n\nasync function mkDirAndCopy (srcMode, src, dest, opts) {\n  await mkdir(dest)\n  await copyDir(src, dest, opts)\n  return setDestMode(dest, srcMode)\n}\n\nasync function copyDir (src, dest, opts) {\n  const dir = await readdir(src)\n  for (let i = 0; i < dir.length; i++) {\n    const item = dir[i]\n    const srcItem = join(src, item)\n    const destItem = join(dest, item)\n    const { destStat } = await checkPaths(srcItem, destItem, opts)\n    await startCopy(destStat, srcItem, destItem, opts)\n  }\n}\n\nasync function onLink (destStat, src, dest) {\n  let resolvedSrc = await readlink(src)\n  if (!isAbsolute(resolvedSrc)) {\n    resolvedSrc = resolve(dirname(src), resolvedSrc)\n  }\n  if (!destStat) {\n    return symlink(resolvedSrc, dest)\n  }\n  let resolvedDest\n  try {\n    resolvedDest = await readlink(dest)\n  } catch (err) {\n    // Dest exists and is a regular file or directory,\n    // Windows may throw UNKNOWN error. If dest already exists,\n    // fs throws error anyway, so no need to guard against it here.\n    // istanbul ignore next: can only test on windows\n    if (err.code === 'EINVAL' || err.code === 'UNKNOWN') {\n      return symlink(resolvedSrc, dest)\n    }\n    // istanbul ignore next: should not be possible\n    throw err\n  }\n  if (!isAbsolute(resolvedDest)) {\n    resolvedDest = resolve(dirname(dest), resolvedDest)\n  }\n  if (isSrcSubdir(resolvedSrc, resolvedDest)) {\n    throw new ERR_FS_CP_EINVAL({\n      message: `cannot copy ${resolvedSrc} to a subdirectory of self ` +\n            `${resolvedDest}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  // Do not copy if src is a subdir of dest since unlinking\n  // dest in this case would result in removing src contents\n  // and therefore a broken symlink would be created.\n  const srcStat = await stat(src)\n  if (srcStat.isDirectory() && isSrcSubdir(resolvedDest, resolvedSrc)) {\n    throw new ERR_FS_CP_SYMLINK_TO_SUBDIRECTORY({\n      message: `cannot overwrite ${resolvedDest} with ${resolvedSrc}`,\n      path: dest,\n      syscall: 'cp',\n      errno: EINVAL,\n    })\n  }\n  return copyLink(resolvedSrc, dest)\n}\n\nasync function copyLink (resolvedSrc, dest) {\n  await unlink(dest)\n  return symlink(resolvedSrc, dest)\n}\n\nmodule.exports = cp\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;AAAA,IAAAA,iBAAA,GAAAC,OAAA,0GAAAC,OAAA;AAEZ,MAAM;EACJC,wBAAwB;EACxBC,gBAAgB;EAChBC,gBAAgB;EAChBC,mBAAmB;EACnBC,wBAAwB;EACxBC,gBAAgB;EAChBC,iCAAiC;EACjCC,iBAAiB;EACjBC,aAAa;EACbC;AACF,CAAC,GAAGX,OAAO,CAAC,cAAc,CAAC;AAC3B,MAAM;EACJY,SAAS,EAAE;IACTC,KAAK,EAAE;MACLC,MAAM;MACNC,MAAM;MACNC,MAAM;MACNC;IACF;EACF;AACF,CAAC,GAAGjB,OAAO,CAAC,IAAI,CAAC;AACjB,MAAM;EACJkB,KAAK;EACLC,QAAQ;EACRC,KAAK;EACLC,KAAK;EACLC,OAAO;EACPC,QAAQ;EACRC,IAAI;EACJC,OAAO;EACPC,MAAM;EACNC;AACF,CAAC,GAAG3B,OAAO,CAAC,UAAU,CAAC;AACvB,MAAM;EACJ4B,OAAO;EACPC,UAAU;EACVC,IAAI;EACJC,KAAK;EACLC,OAAO;EACPC,GAAG;EACHC;AACF,CAAC,GAAGlC,OAAO,CAAC,MAAM,CAAC;AACnB,MAAM;EAAEmC;AAAc,CAAC,GAAGnC,OAAO,CAAC,KAAK,CAAC;AAExC,MAAMoC,cAAc,GAAG;EACrBC,WAAW,EAAE,KAAK;EAClBC,YAAY,EAAE,KAAK;EACnBC,MAAM,EAAEC,SAAS;EACjBC,KAAK,EAAE,IAAI;EACXC,kBAAkB,EAAE,KAAK;EACzBC,SAAS,EAAE;AACb,CAAC;AAAA,SAEcC,EAAEA,CAAAC,EAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,GAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,IAAA;EAAAA,GAAA,GAAAjD,iBAAA,CAAjB,WAAmBoD,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAClC,IAAIA,IAAI,IAAI,IAAI,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAAE;MAC5C,MAAM,IAAI1C,oBAAoB,CAAC,SAAS,EAAE,CAAC,QAAQ,CAAC,EAAE0C,IAAI,CAAC;IAC7D;IACA,OAAOC,IAAI,CACTpB,gBAAgB,CAACqB,gBAAgB,CAACJ,GAAG,CAAC,CAAC,EACvCjB,gBAAgB,CAACqB,gBAAgB,CAACH,IAAI,CAAC,CAAC,EACxC;MAAE,GAAGhB,cAAc;MAAE,GAAGiB;IAAK,CAAC,CAAC;EACnC,CAAC;EAAA,OAAAL,GAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAED,SAASK,gBAAgBA,CAAEC,aAAa,EAAE;EACxC,MAAMC,IAAI,GAAGD,aAAa,IAAI,IAAI,IAAIA,aAAa,CAACE,IAAI,IACjDF,aAAa,CAACG,MAAM,GACvBxB,aAAa,CAACqB,aAAa,CAAC,GAC5BA,aAAa;EACjB,OAAOC,IAAI;AACb;AAAC,SAEcH,IAAIA,CAAAM,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,KAAA,CAAAd,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAa,MAAA;EAAAA,KAAA,GAAAhE,iBAAA,CAAnB,WAAqBoD,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACpC;IACA;IACA,IAAIA,IAAI,CAACX,kBAAkB,IAAIsB,OAAO,CAACC,IAAI,KAAK,MAAM,EAAE;MACtD,MAAMC,OAAO,GAAG,gDAAgD,GAC9D,yBAAyB;MAC3BF,OAAO,CAACG,WAAW,CAACD,OAAO,EAAE,2BAA2B,CAAC;IAC3D;IACA,MAAME,KAAK,SAASC,UAAU,CAAClB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAC/C,MAAM;MAAEiB,OAAO;MAAEC;IAAS,CAAC,GAAGH,KAAK;IACnC,MAAMI,gBAAgB,CAACrB,GAAG,EAAEmB,OAAO,EAAElB,IAAI,CAAC;IAC1C,IAAIC,IAAI,CAACd,MAAM,EAAE;MACf,OAAOkC,YAAY,CAACC,cAAc,EAAEH,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAChE;IACA,OAAOqB,cAAc,CAACH,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;EAClD,CAAC;EAAA,OAAAU,KAAA,CAAAd,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEcmB,UAAUA,CAAAM,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,WAAA,CAAA7B,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA4B,YAAA;EAAAA,WAAA,GAAA/E,iBAAA,CAAzB,WAA2BoD,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAC1C,MAAM;MAAE,CAAC,EAAEiB,OAAO;MAAE,CAAC,EAAEC;IAAS,CAAC,SAASQ,QAAQ,CAAC5B,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IACnE,IAAIkB,QAAQ,EAAE;MACZ,IAAIS,YAAY,CAACV,OAAO,EAAEC,QAAQ,CAAC,EAAE;QACnC,MAAM,IAAInE,gBAAgB,CAAC;UACzB6E,OAAO,EAAE,iCAAiC;UAC1CxB,IAAI,EAAEL,IAAI;UACV8B,OAAO,EAAE,IAAI;UACbrE,KAAK,EAAEG;QACT,CAAC,CAAC;MACJ;MACA,IAAIsD,OAAO,CAACa,WAAW,EAAE,IAAI,CAACZ,QAAQ,CAACY,WAAW,EAAE,EAAE;QACpD,MAAM,IAAIjF,wBAAwB,CAAC;UACjC+E,OAAO,EAAG,8BAA6B9B,GAAI,GAAE,GACxC,sBAAqBC,IAAK,EAAC;UAChCK,IAAI,EAAEL,IAAI;UACV8B,OAAO,EAAE,IAAI;UACbrE,KAAK,EAAEE;QACT,CAAC,CAAC;MACJ;MACA,IAAI,CAACuD,OAAO,CAACa,WAAW,EAAE,IAAIZ,QAAQ,CAACY,WAAW,EAAE,EAAE;QACpD,MAAM,IAAI7E,wBAAwB,CAAC;UACjC2E,OAAO,EAAG,kCAAiC9B,GAAI,GAAE,GAC5C,kBAAiBC,IAAK,EAAC;UAC5BK,IAAI,EAAEL,IAAI;UACV8B,OAAO,EAAE,IAAI;UACbrE,KAAK,EAAEI;QACT,CAAC,CAAC;MACJ;IACF;IAEA,IAAIqD,OAAO,CAACa,WAAW,EAAE,IAAIC,WAAW,CAACjC,GAAG,EAAEC,IAAI,CAAC,EAAE;MACnD,MAAM,IAAIhD,gBAAgB,CAAC;QACzB6E,OAAO,EAAG,eAAc9B,GAAI,8BAA6BC,IAAK,EAAC;QAC/DK,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ;IACA,OAAO;MAAEsD,OAAO;MAAEC;IAAS,CAAC;EAC9B,CAAC;EAAA,OAAAO,WAAA,CAAA7B,KAAA,OAAAC,SAAA;AAAA;AAED,SAAS8B,YAAYA,CAAEV,OAAO,EAAEC,QAAQ,EAAE;EACxC,OAAOA,QAAQ,CAACc,GAAG,IAAId,QAAQ,CAACe,GAAG,IAAIf,QAAQ,CAACc,GAAG,KAAKf,OAAO,CAACe,GAAG,IACjEd,QAAQ,CAACe,GAAG,KAAKhB,OAAO,CAACgB,GAAG;AAChC;AAEA,SAASP,QAAQA,CAAE5B,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAClC,MAAMkC,QAAQ,GAAGlC,IAAI,CAAChB,WAAW,GAC9BmD,IAAI,IAAKhE,IAAI,CAACgE,IAAI,EAAE;IAAEC,MAAM,EAAE;EAAK,CAAC,CAAC,GACrCD,IAAI,IAAKpE,KAAK,CAACoE,IAAI,EAAE;IAAEC,MAAM,EAAE;EAAK,CAAC,CAAC;EACzC,OAAOC,OAAO,CAACC,GAAG,CAAC,CACjBJ,QAAQ,CAACpC,GAAG,CAAC,EACboC,QAAQ,CAACnC,IAAI,CAAC,CAACwC,KAAK,CAAEC,GAAG,IAAK;IAC5B;IACA,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;MACzB,OAAO,IAAI;IACb;IACA;IACA,MAAMD,GAAG;EACX,CAAC,CAAC,CACH,CAAC;AACJ;AAAC,SAEcnB,cAAcA,CAAAqB,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,eAAA,CAAAlD,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAiD,gBAAA;EAAAA,eAAA,GAAApG,iBAAA,CAA7B,WAA+BwE,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACxD,MAAM+C,UAAU,GAAGxE,OAAO,CAACwB,IAAI,CAAC;IAChC,MAAMiD,SAAS,SAASC,UAAU,CAACF,UAAU,CAAC;IAC9C,IAAIC,SAAS,EAAE;MACb,OAAOE,eAAe,CAAChC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IACnD;IACA,MAAMhC,KAAK,CAAC+E,UAAU,EAAE;MAAEzD,SAAS,EAAE;IAAK,CAAC,CAAC;IAC5C,OAAO4D,eAAe,CAAChC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;EACnD,CAAC;EAAA,OAAA8C,eAAA,CAAAlD,KAAA,OAAAC,SAAA;AAAA;AAED,SAASoD,UAAUA,CAAElD,IAAI,EAAE;EACzB,OAAO5B,IAAI,CAAC4B,IAAI,CAAC,CAACoD,IAAI,CACpB,MAAM,IAAI;EACV;EACCX,GAAG,IAAMA,GAAG,CAACC,IAAI,KAAK,QAAQ,GAAG,KAAK,GAAGJ,OAAO,CAACe,MAAM,CAACZ,GAAG,CAAE,CAAC;AACnE;;AAEA;AACA;AACA;AACA;AAAA,SACerB,gBAAgBA,CAAAkC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,iBAAA,CAAA5D,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA2D,kBAAA;EAAAA,iBAAA,GAAA9G,iBAAA,CAA/B,WAAiCoD,GAAG,EAAEmB,OAAO,EAAElB,IAAI,EAAE;IACnD,MAAM0D,SAAS,GAAG9E,OAAO,CAACJ,OAAO,CAACuB,GAAG,CAAC,CAAC;IACvC,MAAMiD,UAAU,GAAGpE,OAAO,CAACJ,OAAO,CAACwB,IAAI,CAAC,CAAC;IACzC,IAAIgD,UAAU,KAAKU,SAAS,IAAIV,UAAU,KAAKrE,KAAK,CAACqE,UAAU,CAAC,CAACW,IAAI,EAAE;MACrE;IACF;IACA,IAAIxC,QAAQ;IACZ,IAAI;MACFA,QAAQ,SAAS/C,IAAI,CAAC4E,UAAU,EAAE;QAAEX,MAAM,EAAE;MAAK,CAAC,CAAC;IACrD,CAAC,CAAC,OAAOI,GAAG,EAAE;MACZ;MACA,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;QACzB;MACF;MACA;MACA,MAAMD,GAAG;IACX;IACA,IAAIb,YAAY,CAACV,OAAO,EAAEC,QAAQ,CAAC,EAAE;MACnC,MAAM,IAAInE,gBAAgB,CAAC;QACzB6E,OAAO,EAAG,eAAc9B,GAAI,8BAA6BC,IAAK,EAAC;QAC/DK,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ;IACA,OAAOwD,gBAAgB,CAACrB,GAAG,EAAEmB,OAAO,EAAE8B,UAAU,CAAC;EACnD,CAAC;EAAA,OAAAS,iBAAA,CAAA5D,KAAA,OAAAC,SAAA;AAAA;AAED,MAAM8D,oBAAoB,GAAIvD,IAAI,IAChCzB,OAAO,CAACyB,IAAI,CAAC,CAACwD,KAAK,CAAChF,GAAG,CAAC,CAACM,MAAM,CAAC2E,OAAO,CAAC;;AAE1C;AACA;AACA,SAAS9B,WAAWA,CAAEjC,GAAG,EAAEC,IAAI,EAAE;EAC/B,MAAM+D,MAAM,GAAGH,oBAAoB,CAAC7D,GAAG,CAAC;EACxC,MAAMiE,OAAO,GAAGJ,oBAAoB,CAAC5D,IAAI,CAAC;EAC1C,OAAO+D,MAAM,CAACE,KAAK,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKH,OAAO,CAACG,CAAC,CAAC,KAAKD,GAAG,CAAC;AACrD;AAAC,SAEc7C,YAAYA,CAAA+C,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,aAAA,CAAA7E,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA4E,cAAA;EAAAA,aAAA,GAAA/H,iBAAA,CAA3B,WAA6BgI,SAAS,EAAExD,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE2E,EAAE,EAAE;IACrE,MAAMC,OAAO,SAAS5E,IAAI,CAACd,MAAM,CAACY,GAAG,EAAEC,IAAI,CAAC;IAC5C,IAAI6E,OAAO,EAAE;MACX,OAAOF,SAAS,CAACxD,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE2E,EAAE,CAAC;IACjD;EACF,CAAC;EAAA,OAAAF,aAAA,CAAA7E,KAAA,OAAAC,SAAA;AAAA;AAED,SAASgF,SAASA,CAAE3D,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAC7C,IAAIA,IAAI,CAACd,MAAM,EAAE;IACf,OAAOkC,YAAY,CAAC8B,eAAe,EAAEhC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;EACjE;EACA,OAAOkD,eAAe,CAAChC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;AACnD;AAAC,SAEckD,eAAeA,CAAA4B,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,gBAAA,CAAAtF,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAqF,iBAAA;EAAAA,gBAAA,GAAAxI,iBAAA,CAA9B,WAAgCwE,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACzD,MAAMmF,MAAM,GAAGnF,IAAI,CAAChB,WAAW,GAAGb,IAAI,GAAGJ,KAAK;IAC9C,MAAMkD,OAAO,SAASkE,MAAM,CAACrF,GAAG,CAAC;IACjC;IACA,IAAImB,OAAO,CAACa,WAAW,EAAE,IAAI9B,IAAI,CAACV,SAAS,EAAE;MAC3C,OAAO8F,KAAK,CAACnE,OAAO,EAAEC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAClD,CAAC,MAAM,IAAIiB,OAAO,CAACa,WAAW,EAAE,EAAE;MAChC,MAAM,IAAIzE,aAAa,CAAC;QACtBuE,OAAO,EAAG,GAAE9B,GAAI,8BAA6B;QAC7CM,IAAI,EAAEN,GAAG;QACT+B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIsD,OAAO,CAACoE,MAAM,EAAE,IACjBpE,OAAO,CAACqE,iBAAiB,EAAE,IAC3BrE,OAAO,CAACsE,aAAa,EAAE,EAAE;MACjC,OAAOC,MAAM,CAACvE,OAAO,EAAEC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IACnD,CAAC,MAAM,IAAIiB,OAAO,CAACwE,cAAc,EAAE,EAAE;MACnC,OAAOC,MAAM,CAACxE,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,CAAC;IACpC,CAAC,MAAM,IAAIkB,OAAO,CAAC0E,QAAQ,EAAE,EAAE;MAC7B,MAAM,IAAIzI,gBAAgB,CAAC;QACzB0E,OAAO,EAAG,8BAA6B7B,IAAK,EAAC;QAC7CK,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ,CAAC,MAAM,IAAIsD,OAAO,CAAC2E,MAAM,EAAE,EAAE;MAC3B,MAAM,IAAI5I,mBAAmB,CAAC;QAC5B4E,OAAO,EAAG,4BAA2B7B,IAAK,EAAC;QAC3CK,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ;IACA;IACA,MAAM,IAAIP,iBAAiB,CAAC;MAC1BwE,OAAO,EAAG,qCAAoC7B,IAAK,EAAC;MACpDK,IAAI,EAAEL,IAAI;MACV8B,OAAO,EAAE,IAAI;MACbrE,KAAK,EAAEG;IACT,CAAC,CAAC;EACJ,CAAC;EAAA,OAAAuH,gBAAA,CAAAtF,KAAA,OAAAC,SAAA;AAAA;AAED,SAAS2F,MAAMA,CAAEvE,OAAO,EAAEC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;EACnD,IAAI,CAACkB,QAAQ,EAAE;IACb,OAAO2E,SAAS,CAAC5E,OAAO,EAAEnB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;EAC5C;EACA,OAAO8F,WAAW,CAAC7E,OAAO,EAAEnB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;AAC9C;AAAC,SAEc8F,WAAWA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,YAAA,CAAAvG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAsG,aAAA;EAAAA,YAAA,GAAAzJ,iBAAA,CAA1B,WAA4BuE,OAAO,EAAEnB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACpD,IAAIA,IAAI,CAACZ,KAAK,EAAE;MACd,MAAMf,MAAM,CAAC0B,IAAI,CAAC;MAClB,OAAO8F,SAAS,CAAC5E,OAAO,EAAEnB,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAC5C,CAAC,MAAM,IAAIA,IAAI,CAACf,YAAY,EAAE;MAC5B,MAAM,IAAInC,gBAAgB,CAAC;QACzB8E,OAAO,EAAG,GAAE7B,IAAK,iBAAgB;QACjCK,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEC;MACT,CAAC,CAAC;IACJ;EACF,CAAC;EAAA,OAAA0I,YAAA,CAAAvG,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEcgG,SAASA,CAAAO,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,UAAA,CAAA5G,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA2G,WAAA;EAAAA,UAAA,GAAA9J,iBAAA,CAAxB,WAA0BuE,OAAO,EAAEnB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IAClD,MAAMlC,QAAQ,CAACgC,GAAG,EAAEC,IAAI,CAAC;IACzB,IAAIC,IAAI,CAACX,kBAAkB,EAAE;MAC3B,OAAOoH,uBAAuB,CAACxF,OAAO,CAACyF,IAAI,EAAE5G,GAAG,EAAEC,IAAI,CAAC;IACzD;IACA,OAAO4G,WAAW,CAAC5G,IAAI,EAAEkB,OAAO,CAACyF,IAAI,CAAC;EACxC,CAAC;EAAA,OAAAF,UAAA,CAAA5G,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEc4G,uBAAuBA,CAAAG,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,wBAAA,CAAAnH,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAkH,yBAAA;EAAAA,wBAAA,GAAArK,iBAAA,CAAtC,WAAwCsK,OAAO,EAAElH,GAAG,EAAEC,IAAI,EAAE;IAC1D;IACA;IACA;IACA,IAAIkH,iBAAiB,CAACD,OAAO,CAAC,EAAE;MAC9B,MAAME,gBAAgB,CAACnH,IAAI,EAAEiH,OAAO,CAAC;MACrC,OAAOG,wBAAwB,CAACH,OAAO,EAAElH,GAAG,EAAEC,IAAI,CAAC;IACrD;IACA,OAAOoH,wBAAwB,CAACH,OAAO,EAAElH,GAAG,EAAEC,IAAI,CAAC;EACrD,CAAC;EAAA,OAAAgH,wBAAA,CAAAnH,KAAA,OAAAC,SAAA;AAAA;AAED,SAASoH,iBAAiBA,CAAED,OAAO,EAAE;EACnC,OAAO,CAACA,OAAO,GAAG,KAAK,MAAM,CAAC;AAChC;AAEA,SAASE,gBAAgBA,CAAEnH,IAAI,EAAEiH,OAAO,EAAE;EACxC,OAAOL,WAAW,CAAC5G,IAAI,EAAEiH,OAAO,GAAG,KAAK,CAAC;AAC3C;AAAC,SAEcG,wBAAwBA,CAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,yBAAA,CAAA3H,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA0H,0BAAA;EAAAA,yBAAA,GAAA7K,iBAAA,CAAvC,WAAyCsK,OAAO,EAAElH,GAAG,EAAEC,IAAI,EAAE;IAC3D,MAAMyH,iBAAiB,CAAC1H,GAAG,EAAEC,IAAI,CAAC;IAClC,OAAO4G,WAAW,CAAC5G,IAAI,EAAEiH,OAAO,CAAC;EACnC,CAAC;EAAA,OAAAO,yBAAA,CAAA3H,KAAA,OAAAC,SAAA;AAAA;AAED,SAAS8G,WAAWA,CAAE5G,IAAI,EAAEiH,OAAO,EAAE;EACnC,OAAOnJ,KAAK,CAACkC,IAAI,EAAEiH,OAAO,CAAC;AAC7B;AAAC,SAEcQ,iBAAiBA,CAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,kBAAA,CAAA/H,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA8H,mBAAA;EAAAA,kBAAA,GAAAjL,iBAAA,CAAhC,WAAkCoD,GAAG,EAAEC,IAAI,EAAE;IAC3C;IACA;IACA;IACA,MAAM6H,cAAc,SAASzJ,IAAI,CAAC2B,GAAG,CAAC;IACtC,OAAOxB,MAAM,CAACyB,IAAI,EAAE6H,cAAc,CAACC,KAAK,EAAED,cAAc,CAACE,KAAK,CAAC;EACjE,CAAC;EAAA,OAAAH,kBAAA,CAAA/H,KAAA,OAAAC,SAAA;AAAA;AAED,SAASuF,KAAKA,CAAEnE,OAAO,EAAEC,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;EAClD,IAAI,CAACkB,QAAQ,EAAE;IACb,OAAO6G,YAAY,CAAC9G,OAAO,CAACyF,IAAI,EAAE5G,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;EACpD;EACA,OAAOgI,OAAO,CAAClI,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;AACjC;AAAC,SAEc+H,YAAYA,CAAAE,IAAA,EAAAC,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,aAAA,CAAAzI,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAwI,cAAA;EAAAA,aAAA,GAAA3L,iBAAA,CAA3B,WAA6BsK,OAAO,EAAElH,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACrD,MAAMhC,KAAK,CAAC+B,IAAI,CAAC;IACjB,MAAMiI,OAAO,CAAClI,GAAG,EAAEC,IAAI,EAAEC,IAAI,CAAC;IAC9B,OAAO2G,WAAW,CAAC5G,IAAI,EAAEiH,OAAO,CAAC;EACnC,CAAC;EAAA,OAAAqB,aAAA,CAAAzI,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEcmI,OAAOA,CAAAM,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,QAAA,CAAA7I,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA4I,SAAA;EAAAA,QAAA,GAAA/L,iBAAA,CAAtB,WAAwBoD,GAAG,EAAEC,IAAI,EAAEC,IAAI,EAAE;IACvC,MAAM0I,GAAG,SAASzK,OAAO,CAAC6B,GAAG,CAAC;IAC9B,KAAK,IAAIoE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGwE,GAAG,CAACC,MAAM,EAAEzE,CAAC,EAAE,EAAE;MACnC,MAAM0E,IAAI,GAAGF,GAAG,CAACxE,CAAC,CAAC;MACnB,MAAM2E,OAAO,GAAGpK,IAAI,CAACqB,GAAG,EAAE8I,IAAI,CAAC;MAC/B,MAAME,QAAQ,GAAGrK,IAAI,CAACsB,IAAI,EAAE6I,IAAI,CAAC;MACjC,MAAM;QAAE1H;MAAS,CAAC,SAASF,UAAU,CAAC6H,OAAO,EAAEC,QAAQ,EAAE9I,IAAI,CAAC;MAC9D,MAAM6E,SAAS,CAAC3D,QAAQ,EAAE2H,OAAO,EAAEC,QAAQ,EAAE9I,IAAI,CAAC;IACpD;EACF,CAAC;EAAA,OAAAyI,QAAA,CAAA7I,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEc6F,MAAMA,CAAAqD,IAAA,EAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,OAAA,CAAAtJ,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAqJ,QAAA;EAAAA,OAAA,GAAAxM,iBAAA,CAArB,WAAuBwE,QAAQ,EAAEpB,GAAG,EAAEC,IAAI,EAAE;IAC1C,IAAIoJ,WAAW,SAASjL,QAAQ,CAAC4B,GAAG,CAAC;IACrC,IAAI,CAACtB,UAAU,CAAC2K,WAAW,CAAC,EAAE;MAC5BA,WAAW,GAAGxK,OAAO,CAACJ,OAAO,CAACuB,GAAG,CAAC,EAAEqJ,WAAW,CAAC;IAClD;IACA,IAAI,CAACjI,QAAQ,EAAE;MACb,OAAO9C,OAAO,CAAC+K,WAAW,EAAEpJ,IAAI,CAAC;IACnC;IACA,IAAIqJ,YAAY;IAChB,IAAI;MACFA,YAAY,SAASlL,QAAQ,CAAC6B,IAAI,CAAC;IACrC,CAAC,CAAC,OAAOyC,GAAG,EAAE;MACZ;MACA;MACA;MACA;MACA,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,IAAID,GAAG,CAACC,IAAI,KAAK,SAAS,EAAE;QACnD,OAAOrE,OAAO,CAAC+K,WAAW,EAAEpJ,IAAI,CAAC;MACnC;MACA;MACA,MAAMyC,GAAG;IACX;IACA,IAAI,CAAChE,UAAU,CAAC4K,YAAY,CAAC,EAAE;MAC7BA,YAAY,GAAGzK,OAAO,CAACJ,OAAO,CAACwB,IAAI,CAAC,EAAEqJ,YAAY,CAAC;IACrD;IACA,IAAIrH,WAAW,CAACoH,WAAW,EAAEC,YAAY,CAAC,EAAE;MAC1C,MAAM,IAAIrM,gBAAgB,CAAC;QACzB6E,OAAO,EAAG,eAAcuH,WAAY,6BAA4B,GACzD,GAAEC,YAAa,EAAC;QACvBhJ,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ;IACA;IACA;IACA;IACA,MAAMsD,OAAO,SAAS9C,IAAI,CAAC2B,GAAG,CAAC;IAC/B,IAAImB,OAAO,CAACa,WAAW,EAAE,IAAIC,WAAW,CAACqH,YAAY,EAAED,WAAW,CAAC,EAAE;MACnE,MAAM,IAAIhM,iCAAiC,CAAC;QAC1CyE,OAAO,EAAG,oBAAmBwH,YAAa,SAAQD,WAAY,EAAC;QAC/D/I,IAAI,EAAEL,IAAI;QACV8B,OAAO,EAAE,IAAI;QACbrE,KAAK,EAAEG;MACT,CAAC,CAAC;IACJ;IACA,OAAO0L,QAAQ,CAACF,WAAW,EAAEpJ,IAAI,CAAC;EACpC,CAAC;EAAA,OAAAmJ,OAAA,CAAAtJ,KAAA,OAAAC,SAAA;AAAA;AAAA,SAEcwJ,QAAQA,CAAAC,IAAA,EAAAC,IAAA;EAAA,OAAAC,SAAA,CAAA5J,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAA2J,UAAA;EAAAA,SAAA,GAAA9M,iBAAA,CAAvB,WAAyByM,WAAW,EAAEpJ,IAAI,EAAE;IAC1C,MAAM1B,MAAM,CAAC0B,IAAI,CAAC;IAClB,OAAO3B,OAAO,CAAC+K,WAAW,EAAEpJ,IAAI,CAAC;EACnC,CAAC;EAAA,OAAAyJ,SAAA,CAAA5J,KAAA,OAAAC,SAAA;AAAA;AAED4J,MAAM,CAACC,OAAO,GAAGnK,EAAE"},"metadata":{},"sourceType":"script","externalDependencies":[]}