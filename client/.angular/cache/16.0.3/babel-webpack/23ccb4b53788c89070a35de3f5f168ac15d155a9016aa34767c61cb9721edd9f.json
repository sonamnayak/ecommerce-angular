{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst util = require('util');\nconst chownr = util.promisify(require('chownr'));\nconst mkdirp = require('mkdirp');\nconst inflight = require('promise-inflight');\nconst inferOwner = require('infer-owner');\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nconst self = {\n  uid: null,\n  gid: null\n};\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid();\n    const setuid = process.setuid;\n    process.setuid = uid => {\n      self.uid = null;\n      process.setuid = setuid;\n      return process.setuid(uid);\n    };\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid();\n    const setgid = process.setgid;\n    process.setgid = gid => {\n      self.gid = null;\n      process.setgid = setgid;\n      return process.setgid(gid);\n    };\n  }\n};\nmodule.exports.chownr = fixOwner;\nfunction fixOwner(_x, _x2) {\n  return _fixOwner.apply(this, arguments);\n}\nfunction _fixOwner() {\n  _fixOwner = _asyncToGenerator(function* (cache, filepath) {\n    if (!process.getuid) {\n      // This platform doesn't need ownership fixing\n      return;\n    }\n    getSelf();\n    if (self.uid !== 0) {\n      // almost certainly can't chown anyway\n      return;\n    }\n    const {\n      uid,\n      gid\n    } = yield inferOwner(cache);\n\n    // No need to override if it's already what we used.\n    if (self.uid === uid && self.gid === gid) {\n      return;\n    }\n    return inflight('fixOwner: fixing ownership on ' + filepath, () => chownr(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid).catch(err => {\n      if (err.code === 'ENOENT') {\n        return null;\n      }\n      throw err;\n    }));\n  });\n  return _fixOwner.apply(this, arguments);\n}\nmodule.exports.chownr.sync = fixOwnerSync;\nfunction fixOwnerSync(cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return;\n  }\n  const {\n    uid,\n    gid\n  } = inferOwner.sync(cache);\n  getSelf();\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return;\n  }\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return;\n  }\n  try {\n    chownr.sync(filepath, typeof uid === 'number' ? uid : self.uid, typeof gid === 'number' ? gid : self.gid);\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null;\n    }\n    throw err;\n  }\n}\nmodule.exports.mkdirfix = mkdirfix;\nfunction mkdirfix(_x3, _x4, _x5) {\n  return _mkdirfix.apply(this, arguments);\n}\nfunction _mkdirfix() {\n  _mkdirfix = _asyncToGenerator(function* (cache, p, cb) {\n    // we have to infer the owner _before_ making the directory, even though\n    // we aren't going to use the results, since the cache itself might not\n    // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n    // to be correct if it creates the cache folder in the process.\n    yield inferOwner(cache);\n    try {\n      const made = yield mkdirp(p);\n      if (made) {\n        yield fixOwner(cache, made);\n        return made;\n      }\n    } catch (err) {\n      if (err.code === 'EEXIST') {\n        yield fixOwner(cache, p);\n        return null;\n      }\n      throw err;\n    }\n  });\n  return _mkdirfix.apply(this, arguments);\n}\nmodule.exports.mkdirfix.sync = mkdirfixSync;\nfunction mkdirfixSync(cache, p) {\n  try {\n    inferOwner.sync(cache);\n    const made = mkdirp.sync(p);\n    if (made) {\n      fixOwnerSync(cache, made);\n      return made;\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p);\n      return null;\n    } else {\n      throw err;\n    }\n  }\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","util","chownr","promisify","mkdirp","inflight","inferOwner","self","uid","gid","getSelf","process","getuid","setuid","getgid","setgid","module","exports","fixOwner","_x","_x2","_fixOwner","apply","arguments","cache","filepath","catch","err","code","sync","fixOwnerSync","mkdirfix","_x3","_x4","_x5","_mkdirfix","p","cb","made","mkdirfixSync"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/cacache/lib/util/fix-owner.js"],"sourcesContent":["'use strict'\n\nconst util = require('util')\n\nconst chownr = util.promisify(require('chownr'))\nconst mkdirp = require('mkdirp')\nconst inflight = require('promise-inflight')\nconst inferOwner = require('infer-owner')\n\n// Memoize getuid()/getgid() calls.\n// patch process.setuid/setgid to invalidate cached value on change\nconst self = { uid: null, gid: null }\nconst getSelf = () => {\n  if (typeof self.uid !== 'number') {\n    self.uid = process.getuid()\n    const setuid = process.setuid\n    process.setuid = (uid) => {\n      self.uid = null\n      process.setuid = setuid\n      return process.setuid(uid)\n    }\n  }\n  if (typeof self.gid !== 'number') {\n    self.gid = process.getgid()\n    const setgid = process.setgid\n    process.setgid = (gid) => {\n      self.gid = null\n      process.setgid = setgid\n      return process.setgid(gid)\n    }\n  }\n}\n\nmodule.exports.chownr = fixOwner\n\nasync function fixOwner (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  const { uid, gid } = await inferOwner(cache)\n\n  // No need to override if it's already what we used.\n  if (self.uid === uid && self.gid === gid) {\n    return\n  }\n\n  return inflight('fixOwner: fixing ownership on ' + filepath, () =>\n    chownr(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    ).catch((err) => {\n      if (err.code === 'ENOENT') {\n        return null\n      }\n\n      throw err\n    })\n  )\n}\n\nmodule.exports.chownr.sync = fixOwnerSync\n\nfunction fixOwnerSync (cache, filepath) {\n  if (!process.getuid) {\n    // This platform doesn't need ownership fixing\n    return\n  }\n  const { uid, gid } = inferOwner.sync(cache)\n  getSelf()\n  if (self.uid !== 0) {\n    // almost certainly can't chown anyway\n    return\n  }\n\n  if (self.uid === uid && self.gid === gid) {\n    // No need to override if it's already what we used.\n    return\n  }\n  try {\n    chownr.sync(\n      filepath,\n      typeof uid === 'number' ? uid : self.uid,\n      typeof gid === 'number' ? gid : self.gid\n    )\n  } catch (err) {\n    // only catch ENOENT, any other error is a problem.\n    if (err.code === 'ENOENT') {\n      return null\n    }\n\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix = mkdirfix\n\nasync function mkdirfix (cache, p, cb) {\n  // we have to infer the owner _before_ making the directory, even though\n  // we aren't going to use the results, since the cache itself might not\n  // exist yet.  If we mkdirp it, then our current uid/gid will be assumed\n  // to be correct if it creates the cache folder in the process.\n  await inferOwner(cache)\n  try {\n    const made = await mkdirp(p)\n    if (made) {\n      await fixOwner(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      await fixOwner(cache, p)\n      return null\n    }\n    throw err\n  }\n}\n\nmodule.exports.mkdirfix.sync = mkdirfixSync\n\nfunction mkdirfixSync (cache, p) {\n  try {\n    inferOwner.sync(cache)\n    const made = mkdirp.sync(p)\n    if (made) {\n      fixOwnerSync(cache, made)\n      return made\n    }\n  } catch (err) {\n    if (err.code === 'EEXIST') {\n      fixOwnerSync(cache, p)\n      return null\n    } else {\n      throw err\n    }\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAAA,IAAAA,iBAAA,GAAAC,OAAA,0GAAAC,OAAA;AAEZ,MAAMC,IAAI,GAAGF,OAAO,CAAC,MAAM,CAAC;AAE5B,MAAMG,MAAM,GAAGD,IAAI,CAACE,SAAS,CAACJ,OAAO,CAAC,QAAQ,CAAC,CAAC;AAChD,MAAMK,MAAM,GAAGL,OAAO,CAAC,QAAQ,CAAC;AAChC,MAAMM,QAAQ,GAAGN,OAAO,CAAC,kBAAkB,CAAC;AAC5C,MAAMO,UAAU,GAAGP,OAAO,CAAC,aAAa,CAAC;;AAEzC;AACA;AACA,MAAMQ,IAAI,GAAG;EAAEC,GAAG,EAAE,IAAI;EAAEC,GAAG,EAAE;AAAK,CAAC;AACrC,MAAMC,OAAO,GAAGA,CAAA,KAAM;EACpB,IAAI,OAAOH,IAAI,CAACC,GAAG,KAAK,QAAQ,EAAE;IAChCD,IAAI,CAACC,GAAG,GAAGG,OAAO,CAACC,MAAM,EAAE;IAC3B,MAAMC,MAAM,GAAGF,OAAO,CAACE,MAAM;IAC7BF,OAAO,CAACE,MAAM,GAAIL,GAAG,IAAK;MACxBD,IAAI,CAACC,GAAG,GAAG,IAAI;MACfG,OAAO,CAACE,MAAM,GAAGA,MAAM;MACvB,OAAOF,OAAO,CAACE,MAAM,CAACL,GAAG,CAAC;IAC5B,CAAC;EACH;EACA,IAAI,OAAOD,IAAI,CAACE,GAAG,KAAK,QAAQ,EAAE;IAChCF,IAAI,CAACE,GAAG,GAAGE,OAAO,CAACG,MAAM,EAAE;IAC3B,MAAMC,MAAM,GAAGJ,OAAO,CAACI,MAAM;IAC7BJ,OAAO,CAACI,MAAM,GAAIN,GAAG,IAAK;MACxBF,IAAI,CAACE,GAAG,GAAG,IAAI;MACfE,OAAO,CAACI,MAAM,GAAGA,MAAM;MACvB,OAAOJ,OAAO,CAACI,MAAM,CAACN,GAAG,CAAC;IAC5B,CAAC;EACH;AACF,CAAC;AAEDO,MAAM,CAACC,OAAO,CAACf,MAAM,GAAGgB,QAAQ;AAAA,SAEjBA,QAAQA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,SAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,UAAA;EAAAA,SAAA,GAAAvB,iBAAA,CAAvB,WAAyB0B,KAAK,EAAEC,QAAQ,EAAE;IACxC,IAAI,CAACd,OAAO,CAACC,MAAM,EAAE;MACnB;MACA;IACF;IAEAF,OAAO,EAAE;IACT,IAAIH,IAAI,CAACC,GAAG,KAAK,CAAC,EAAE;MAClB;MACA;IACF;IAEA,MAAM;MAAEA,GAAG;MAAEC;IAAI,CAAC,SAASH,UAAU,CAACkB,KAAK,CAAC;;IAE5C;IACA,IAAIjB,IAAI,CAACC,GAAG,KAAKA,GAAG,IAAID,IAAI,CAACE,GAAG,KAAKA,GAAG,EAAE;MACxC;IACF;IAEA,OAAOJ,QAAQ,CAAC,gCAAgC,GAAGoB,QAAQ,EAAE,MAC3DvB,MAAM,CACJuB,QAAQ,EACR,OAAOjB,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGD,IAAI,CAACC,GAAG,EACxC,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGF,IAAI,CAACE,GAAG,CACzC,CAACiB,KAAK,CAAEC,GAAG,IAAK;MACf,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;QACzB,OAAO,IAAI;MACb;MAEA,MAAMD,GAAG;IACX,CAAC,CAAC,CACH;EACH,CAAC;EAAA,OAAAN,SAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAEDP,MAAM,CAACC,OAAO,CAACf,MAAM,CAAC2B,IAAI,GAAGC,YAAY;AAEzC,SAASA,YAAYA,CAAEN,KAAK,EAAEC,QAAQ,EAAE;EACtC,IAAI,CAACd,OAAO,CAACC,MAAM,EAAE;IACnB;IACA;EACF;EACA,MAAM;IAAEJ,GAAG;IAAEC;EAAI,CAAC,GAAGH,UAAU,CAACuB,IAAI,CAACL,KAAK,CAAC;EAC3Cd,OAAO,EAAE;EACT,IAAIH,IAAI,CAACC,GAAG,KAAK,CAAC,EAAE;IAClB;IACA;EACF;EAEA,IAAID,IAAI,CAACC,GAAG,KAAKA,GAAG,IAAID,IAAI,CAACE,GAAG,KAAKA,GAAG,EAAE;IACxC;IACA;EACF;EACA,IAAI;IACFP,MAAM,CAAC2B,IAAI,CACTJ,QAAQ,EACR,OAAOjB,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGD,IAAI,CAACC,GAAG,EACxC,OAAOC,GAAG,KAAK,QAAQ,GAAGA,GAAG,GAAGF,IAAI,CAACE,GAAG,CACzC;EACH,CAAC,CAAC,OAAOkB,GAAG,EAAE;IACZ;IACA,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;MACzB,OAAO,IAAI;IACb;IAEA,MAAMD,GAAG;EACX;AACF;AAEAX,MAAM,CAACC,OAAO,CAACc,QAAQ,GAAGA,QAAQ;AAAA,SAEnBA,QAAQA,CAAAC,GAAA,EAAAC,GAAA,EAAAC,GAAA;EAAA,OAAAC,SAAA,CAAAb,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAY,UAAA;EAAAA,SAAA,GAAArC,iBAAA,CAAvB,WAAyB0B,KAAK,EAAEY,CAAC,EAAEC,EAAE,EAAE;IACrC;IACA;IACA;IACA;IACA,MAAM/B,UAAU,CAACkB,KAAK,CAAC;IACvB,IAAI;MACF,MAAMc,IAAI,SAASlC,MAAM,CAACgC,CAAC,CAAC;MAC5B,IAAIE,IAAI,EAAE;QACR,MAAMpB,QAAQ,CAACM,KAAK,EAAEc,IAAI,CAAC;QAC3B,OAAOA,IAAI;MACb;IACF,CAAC,CAAC,OAAOX,GAAG,EAAE;MACZ,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;QACzB,MAAMV,QAAQ,CAACM,KAAK,EAAEY,CAAC,CAAC;QACxB,OAAO,IAAI;MACb;MACA,MAAMT,GAAG;IACX;EACF,CAAC;EAAA,OAAAQ,SAAA,CAAAb,KAAA,OAAAC,SAAA;AAAA;AAEDP,MAAM,CAACC,OAAO,CAACc,QAAQ,CAACF,IAAI,GAAGU,YAAY;AAE3C,SAASA,YAAYA,CAAEf,KAAK,EAAEY,CAAC,EAAE;EAC/B,IAAI;IACF9B,UAAU,CAACuB,IAAI,CAACL,KAAK,CAAC;IACtB,MAAMc,IAAI,GAAGlC,MAAM,CAACyB,IAAI,CAACO,CAAC,CAAC;IAC3B,IAAIE,IAAI,EAAE;MACRR,YAAY,CAACN,KAAK,EAAEc,IAAI,CAAC;MACzB,OAAOA,IAAI;IACb;EACF,CAAC,CAAC,OAAOX,GAAG,EAAE;IACZ,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;MACzBE,YAAY,CAACN,KAAK,EAAEY,CAAC,CAAC;MACtB,OAAO,IAAI;IACb,CAAC,MAAM;MACL,MAAMT,GAAG;IACX;EACF;AACF"},"metadata":{},"sourceType":"script","externalDependencies":[]}