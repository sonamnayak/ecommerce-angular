{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst events = require('events');\nconst util = require('util');\nconst contentPath = require('./path');\nconst fixOwner = require('../util/fix-owner');\nconst fs = require('@npmcli/fs');\nconst moveFile = require('../util/move-file');\nconst Minipass = require('minipass');\nconst Pipeline = require('minipass-pipeline');\nconst Flush = require('minipass-flush');\nconst path = require('path');\nconst rimraf = util.promisify(require('rimraf'));\nconst ssri = require('ssri');\nconst uniqueFilename = require('unique-filename');\nconst fsm = require('fs-minipass');\nmodule.exports = write;\nfunction write(_x, _x2) {\n  return _write.apply(this, arguments);\n}\nfunction _write() {\n  _write = _asyncToGenerator(function* (cache, data, opts = {}) {\n    const {\n      algorithms,\n      size,\n      integrity\n    } = opts;\n    if (algorithms && algorithms.length > 1) {\n      throw new Error('opts.algorithms only supports a single algorithm for now');\n    }\n    if (typeof size === 'number' && data.length !== size) {\n      throw sizeError(size, data.length);\n    }\n    const sri = ssri.fromData(data, algorithms ? {\n      algorithms\n    } : {});\n    if (integrity && !ssri.checkData(data, integrity, opts)) {\n      throw checksumError(integrity, sri);\n    }\n    const tmp = yield makeTmp(cache, opts);\n    try {\n      yield fs.writeFile(tmp.target, data, {\n        flag: 'wx'\n      });\n      yield moveToDestination(tmp, cache, sri, opts);\n      return {\n        integrity: sri,\n        size: data.length\n      };\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _write.apply(this, arguments);\n}\nmodule.exports.stream = writeStream;\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor(cache, opts) {\n    super();\n    this.opts = opts;\n    this.cache = cache;\n    this.inputStream = new Minipass();\n    this.inputStream.on('error', er => this.emit('error', er));\n    this.inputStream.on('drain', () => this.emit('drain'));\n    this.handleContentP = null;\n  }\n  write(chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(this.inputStream, this.cache, this.opts);\n    }\n    return this.inputStream.write(chunk, encoding, cb);\n  }\n  flush(cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty');\n        e.code = 'ENODATA';\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb);\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      this.handleContentP.then(res => {\n        res.integrity && this.emit('integrity', res.integrity);\n        // eslint-disable-next-line promise/always-return\n        res.size !== null && this.emit('size', res.size);\n        cb();\n      }, er => cb(er));\n    });\n  }\n}\nfunction writeStream(cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts);\n}\nfunction handleContent(_x3, _x4, _x5) {\n  return _handleContent.apply(this, arguments);\n}\nfunction _handleContent() {\n  _handleContent = _asyncToGenerator(function* (inputStream, cache, opts) {\n    const tmp = yield makeTmp(cache, opts);\n    try {\n      const res = yield pipeToTmp(inputStream, cache, tmp.target, opts);\n      yield moveToDestination(tmp, cache, res.integrity, opts);\n      return res;\n    } finally {\n      if (!tmp.moved) {\n        yield rimraf(tmp.target);\n      }\n    }\n  });\n  return _handleContent.apply(this, arguments);\n}\nfunction pipeToTmp(_x6, _x7, _x8, _x9) {\n  return _pipeToTmp.apply(this, arguments);\n}\nfunction _pipeToTmp() {\n  _pipeToTmp = _asyncToGenerator(function* (inputStream, cache, tmpTarget, opts) {\n    const outStream = new fsm.WriteStream(tmpTarget, {\n      flags: 'wx'\n    });\n    if (opts.integrityEmitter) {\n      // we need to create these all simultaneously since they can fire in any order\n      const [integrity, size] = yield Promise.all([events.once(opts.integrityEmitter, 'integrity').then(res => res[0]), events.once(opts.integrityEmitter, 'size').then(res => res[0]), new Pipeline(inputStream, outStream).promise()]);\n      return {\n        integrity,\n        size\n      };\n    }\n    let integrity;\n    let size;\n    const hashStream = ssri.integrityStream({\n      integrity: opts.integrity,\n      algorithms: opts.algorithms,\n      size: opts.size\n    });\n    hashStream.on('integrity', i => {\n      integrity = i;\n    });\n    hashStream.on('size', s => {\n      size = s;\n    });\n    const pipeline = new Pipeline(inputStream, hashStream, outStream);\n    yield pipeline.promise();\n    return {\n      integrity,\n      size\n    };\n  });\n  return _pipeToTmp.apply(this, arguments);\n}\nfunction makeTmp(_x10, _x11) {\n  return _makeTmp.apply(this, arguments);\n}\nfunction _makeTmp() {\n  _makeTmp = _asyncToGenerator(function* (cache, opts) {\n    const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix);\n    yield fixOwner.mkdirfix(cache, path.dirname(tmpTarget));\n    return {\n      target: tmpTarget,\n      moved: false\n    };\n  });\n  return _makeTmp.apply(this, arguments);\n}\nfunction moveToDestination(_x12, _x13, _x14, _x15) {\n  return _moveToDestination.apply(this, arguments);\n}\nfunction _moveToDestination() {\n  _moveToDestination = _asyncToGenerator(function* (tmp, cache, sri, opts) {\n    const destination = contentPath(cache, sri);\n    const destDir = path.dirname(destination);\n    yield fixOwner.mkdirfix(cache, destDir);\n    yield moveFile(tmp.target, destination);\n    tmp.moved = true;\n    yield fixOwner.chownr(cache, destination);\n  });\n  return _moveToDestination.apply(this, arguments);\n}\nfunction sizeError(expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`);\n  err.expected = expected;\n  err.found = found;\n  err.code = 'EBADSIZE';\n  return err;\n}\nfunction checksumError(expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`);\n  err.code = 'EINTEGRITY';\n  err.expected = expected;\n  err.found = found;\n  return err;\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","events","util","contentPath","fixOwner","fs","moveFile","Minipass","Pipeline","Flush","path","rimraf","promisify","ssri","uniqueFilename","fsm","module","exports","write","_x","_x2","_write","apply","arguments","cache","data","opts","algorithms","size","integrity","length","Error","sizeError","sri","fromData","checkData","checksumError","tmp","makeTmp","writeFile","target","flag","moveToDestination","moved","stream","writeStream","CacacheWriteStream","constructor","inputStream","on","er","emit","handleContentP","chunk","encoding","cb","handleContent","flush","end","e","code","Promise","reject","catch","then","res","_x3","_x4","_x5","_handleContent","pipeToTmp","_x6","_x7","_x8","_x9","_pipeToTmp","tmpTarget","outStream","WriteStream","flags","integrityEmitter","all","once","promise","hashStream","integrityStream","i","s","pipeline","_x10","_x11","_makeTmp","join","tmpPrefix","mkdirfix","dirname","_x12","_x13","_x14","_x15","_moveToDestination","destination","destDir","chownr","expected","found","err"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/cacache/lib/content/write.js"],"sourcesContent":["'use strict'\n\nconst events = require('events')\nconst util = require('util')\n\nconst contentPath = require('./path')\nconst fixOwner = require('../util/fix-owner')\nconst fs = require('@npmcli/fs')\nconst moveFile = require('../util/move-file')\nconst Minipass = require('minipass')\nconst Pipeline = require('minipass-pipeline')\nconst Flush = require('minipass-flush')\nconst path = require('path')\nconst rimraf = util.promisify(require('rimraf'))\nconst ssri = require('ssri')\nconst uniqueFilename = require('unique-filename')\nconst fsm = require('fs-minipass')\n\nmodule.exports = write\n\nasync function write (cache, data, opts = {}) {\n  const { algorithms, size, integrity } = opts\n  if (algorithms && algorithms.length > 1) {\n    throw new Error('opts.algorithms only supports a single algorithm for now')\n  }\n\n  if (typeof size === 'number' && data.length !== size) {\n    throw sizeError(size, data.length)\n  }\n\n  const sri = ssri.fromData(data, algorithms ? { algorithms } : {})\n  if (integrity && !ssri.checkData(data, integrity, opts)) {\n    throw checksumError(integrity, sri)\n  }\n\n  const tmp = await makeTmp(cache, opts)\n  try {\n    await fs.writeFile(tmp.target, data, { flag: 'wx' })\n    await moveToDestination(tmp, cache, sri, opts)\n    return { integrity: sri, size: data.length }\n  } finally {\n    if (!tmp.moved) {\n      await rimraf(tmp.target)\n    }\n  }\n}\n\nmodule.exports.stream = writeStream\n\n// writes proxied to the 'inputStream' that is passed to the Promise\n// 'end' is deferred until content is handled.\nclass CacacheWriteStream extends Flush {\n  constructor (cache, opts) {\n    super()\n    this.opts = opts\n    this.cache = cache\n    this.inputStream = new Minipass()\n    this.inputStream.on('error', er => this.emit('error', er))\n    this.inputStream.on('drain', () => this.emit('drain'))\n    this.handleContentP = null\n  }\n\n  write (chunk, encoding, cb) {\n    if (!this.handleContentP) {\n      this.handleContentP = handleContent(\n        this.inputStream,\n        this.cache,\n        this.opts\n      )\n    }\n    return this.inputStream.write(chunk, encoding, cb)\n  }\n\n  flush (cb) {\n    this.inputStream.end(() => {\n      if (!this.handleContentP) {\n        const e = new Error('Cache input stream was empty')\n        e.code = 'ENODATA'\n        // empty streams are probably emitting end right away.\n        // defer this one tick by rejecting a promise on it.\n        return Promise.reject(e).catch(cb)\n      }\n      // eslint-disable-next-line promise/catch-or-return\n      this.handleContentP.then(\n        (res) => {\n          res.integrity && this.emit('integrity', res.integrity)\n          // eslint-disable-next-line promise/always-return\n          res.size !== null && this.emit('size', res.size)\n          cb()\n        },\n        (er) => cb(er)\n      )\n    })\n  }\n}\n\nfunction writeStream (cache, opts = {}) {\n  return new CacacheWriteStream(cache, opts)\n}\n\nasync function handleContent (inputStream, cache, opts) {\n  const tmp = await makeTmp(cache, opts)\n  try {\n    const res = await pipeToTmp(inputStream, cache, tmp.target, opts)\n    await moveToDestination(\n      tmp,\n      cache,\n      res.integrity,\n      opts\n    )\n    return res\n  } finally {\n    if (!tmp.moved) {\n      await rimraf(tmp.target)\n    }\n  }\n}\n\nasync function pipeToTmp (inputStream, cache, tmpTarget, opts) {\n  const outStream = new fsm.WriteStream(tmpTarget, {\n    flags: 'wx',\n  })\n\n  if (opts.integrityEmitter) {\n    // we need to create these all simultaneously since they can fire in any order\n    const [integrity, size] = await Promise.all([\n      events.once(opts.integrityEmitter, 'integrity').then(res => res[0]),\n      events.once(opts.integrityEmitter, 'size').then(res => res[0]),\n      new Pipeline(inputStream, outStream).promise(),\n    ])\n    return { integrity, size }\n  }\n\n  let integrity\n  let size\n  const hashStream = ssri.integrityStream({\n    integrity: opts.integrity,\n    algorithms: opts.algorithms,\n    size: opts.size,\n  })\n  hashStream.on('integrity', i => {\n    integrity = i\n  })\n  hashStream.on('size', s => {\n    size = s\n  })\n\n  const pipeline = new Pipeline(inputStream, hashStream, outStream)\n  await pipeline.promise()\n  return { integrity, size }\n}\n\nasync function makeTmp (cache, opts) {\n  const tmpTarget = uniqueFilename(path.join(cache, 'tmp'), opts.tmpPrefix)\n  await fixOwner.mkdirfix(cache, path.dirname(tmpTarget))\n  return {\n    target: tmpTarget,\n    moved: false,\n  }\n}\n\nasync function moveToDestination (tmp, cache, sri, opts) {\n  const destination = contentPath(cache, sri)\n  const destDir = path.dirname(destination)\n\n  await fixOwner.mkdirfix(cache, destDir)\n  await moveFile(tmp.target, destination)\n  tmp.moved = true\n  await fixOwner.chownr(cache, destination)\n}\n\nfunction sizeError (expected, found) {\n  /* eslint-disable-next-line max-len */\n  const err = new Error(`Bad data size: expected inserted data to be ${expected} bytes, but got ${found} instead`)\n  err.expected = expected\n  err.found = found\n  err.code = 'EBADSIZE'\n  return err\n}\n\nfunction checksumError (expected, found) {\n  const err = new Error(`Integrity check failed:\n  Wanted: ${expected}\n   Found: ${found}`)\n  err.code = 'EINTEGRITY'\n  err.expected = expected\n  err.found = found\n  return err\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}