{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst index = require('./entry-index');\nconst memo = require('./memoization');\nconst write = require('./content/write');\nconst Flush = require('minipass-flush');\nconst {\n  PassThrough\n} = require('minipass-collect');\nconst Pipeline = require('minipass-pipeline');\nconst putOpts = opts => ({\n  algorithms: ['sha512'],\n  ...opts\n});\nmodule.exports = putData;\nfunction putData(_x, _x2, _x3) {\n  return _putData.apply(this, arguments);\n}\nfunction _putData() {\n  _putData = _asyncToGenerator(function* (cache, key, data, opts = {}) {\n    const {\n      memoize\n    } = opts;\n    opts = putOpts(opts);\n    const res = yield write(cache, data, opts);\n    const entry = yield index.insert(cache, key, res.integrity, {\n      ...opts,\n      size: res.size\n    });\n    if (memoize) {\n      memo.put(cache, entry, data, opts);\n    }\n    return res.integrity;\n  });\n  return _putData.apply(this, arguments);\n}\nmodule.exports.stream = putStream;\nfunction putStream(cache, key, opts = {}) {\n  const {\n    memoize\n  } = opts;\n  opts = putOpts(opts);\n  let integrity;\n  let size;\n  let error;\n  let memoData;\n  const pipeline = new Pipeline();\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data;\n    });\n    pipeline.push(memoizer);\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts).on('integrity', int => {\n    integrity = int;\n  }).on('size', s => {\n    size = s;\n  }).on('error', err => {\n    error = err;\n  });\n  pipeline.push(contentStream);\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    flush() {\n      return _asyncToGenerator(function* () {\n        if (!error) {\n          const entry = yield index.insert(cache, key, integrity, {\n            ...opts,\n            size\n          });\n          if (memoize && memoData) {\n            memo.put(cache, entry, memoData, opts);\n          }\n          pipeline.emit('integrity', integrity);\n          pipeline.emit('size', size);\n        }\n      })();\n    }\n  }));\n  return pipeline;\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","index","memo","write","Flush","PassThrough","Pipeline","putOpts","opts","algorithms","module","exports","putData","_x","_x2","_x3","_putData","apply","arguments","cache","key","data","memoize","res","entry","insert","integrity","size","put","stream","putStream","error","memoData","pipeline","memoizer","on","push","contentStream","int","s","err","flush","emit"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/cacache/lib/put.js"],"sourcesContent":["'use strict'\n\nconst index = require('./entry-index')\nconst memo = require('./memoization')\nconst write = require('./content/write')\nconst Flush = require('minipass-flush')\nconst { PassThrough } = require('minipass-collect')\nconst Pipeline = require('minipass-pipeline')\n\nconst putOpts = (opts) => ({\n  algorithms: ['sha512'],\n  ...opts,\n})\n\nmodule.exports = putData\n\nasync function putData (cache, key, data, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  const res = await write(cache, data, opts)\n  const entry = await index.insert(cache, key, res.integrity, { ...opts, size: res.size })\n  if (memoize) {\n    memo.put(cache, entry, data, opts)\n  }\n\n  return res.integrity\n}\n\nmodule.exports.stream = putStream\n\nfunction putStream (cache, key, opts = {}) {\n  const { memoize } = opts\n  opts = putOpts(opts)\n  let integrity\n  let size\n  let error\n\n  let memoData\n  const pipeline = new Pipeline()\n  // first item in the pipeline is the memoizer, because we need\n  // that to end first and get the collected data.\n  if (memoize) {\n    const memoizer = new PassThrough().on('collect', data => {\n      memoData = data\n    })\n    pipeline.push(memoizer)\n  }\n\n  // contentStream is a write-only, not a passthrough\n  // no data comes out of it.\n  const contentStream = write.stream(cache, opts)\n    .on('integrity', (int) => {\n      integrity = int\n    })\n    .on('size', (s) => {\n      size = s\n    })\n    .on('error', (err) => {\n      error = err\n    })\n\n  pipeline.push(contentStream)\n\n  // last but not least, we write the index and emit hash and size,\n  // and memoize if we're doing that\n  pipeline.push(new Flush({\n    async flush () {\n      if (!error) {\n        const entry = await index.insert(cache, key, integrity, { ...opts, size })\n        if (memoize && memoData) {\n          memo.put(cache, entry, memoData, opts)\n        }\n        pipeline.emit('integrity', integrity)\n        pipeline.emit('size', size)\n      }\n    },\n  }))\n\n  return pipeline\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}