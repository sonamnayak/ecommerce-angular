{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst fs = require('@npmcli/fs');\nconst move = require('@npmcli/move-file');\nconst pinflight = require('promise-inflight');\nmodule.exports = moveFile;\nfunction moveFile(_x, _x2) {\n  return _moveFile.apply(this, arguments);\n}\nfunction _moveFile() {\n  _moveFile = _asyncToGenerator(function* (src, dest) {\n    const isWindows = process.platform === 'win32';\n\n    // This isn't quite an fs.rename -- the assumption is that\n    // if `dest` already exists, and we get certain errors while\n    // trying to move it, we should just not bother.\n    //\n    // In the case of cache corruption, users will receive an\n    // EINTEGRITY error elsewhere, and can remove the offending\n    // content their own way.\n    //\n    // Note that, as the name suggests, this strictly only supports file moves.\n    try {\n      yield fs.link(src, dest);\n    } catch (err) {\n      if (isWindows && err.code === 'EPERM') {\n        // XXX This is a really weird way to handle this situation, as it\n        // results in the src file being deleted even though the dest\n        // might not exist.  Since we pretty much always write files to\n        // deterministic locations based on content hash, this is likely\n        // ok (or at worst, just ends in a future cache miss).  But it would\n        // be worth investigating at some time in the future if this is\n        // really what we want to do here.\n      } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n        // file already exists, so whatever\n      } else {\n        throw err;\n      }\n    }\n    try {\n      yield Promise.all([fs.unlink(src), !isWindows && fs.chmod(dest, '0444')]);\n    } catch (e) {\n      return pinflight('cacache-move-file:' + dest, /*#__PURE__*/_asyncToGenerator(function* () {\n        yield fs.stat(dest).catch(err => {\n          if (err.code !== 'ENOENT') {\n            // Something else is wrong here. Bail bail bail\n            throw err;\n          }\n        });\n        // file doesn't already exist! let's try a rename -> copy fallback\n        // only delete if it successfully copies\n        return move(src, dest);\n      }));\n    }\n  });\n  return _moveFile.apply(this, arguments);\n}","map":{"version":3,"names":["_asyncToGenerator","require","default","fs","move","pinflight","module","exports","moveFile","_x","_x2","_moveFile","apply","arguments","src","dest","isWindows","process","platform","link","err","code","Promise","all","unlink","chmod","e","stat","catch"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/node_modules/cacache/lib/util/move-file.js"],"sourcesContent":["'use strict'\n\nconst fs = require('@npmcli/fs')\nconst move = require('@npmcli/move-file')\nconst pinflight = require('promise-inflight')\n\nmodule.exports = moveFile\n\nasync function moveFile (src, dest) {\n  const isWindows = process.platform === 'win32'\n\n  // This isn't quite an fs.rename -- the assumption is that\n  // if `dest` already exists, and we get certain errors while\n  // trying to move it, we should just not bother.\n  //\n  // In the case of cache corruption, users will receive an\n  // EINTEGRITY error elsewhere, and can remove the offending\n  // content their own way.\n  //\n  // Note that, as the name suggests, this strictly only supports file moves.\n  try {\n    await fs.link(src, dest)\n  } catch (err) {\n    if (isWindows && err.code === 'EPERM') {\n      // XXX This is a really weird way to handle this situation, as it\n      // results in the src file being deleted even though the dest\n      // might not exist.  Since we pretty much always write files to\n      // deterministic locations based on content hash, this is likely\n      // ok (or at worst, just ends in a future cache miss).  But it would\n      // be worth investigating at some time in the future if this is\n      // really what we want to do here.\n    } else if (err.code === 'EEXIST' || err.code === 'EBUSY') {\n      // file already exists, so whatever\n    } else {\n      throw err\n    }\n  }\n  try {\n    await Promise.all([\n      fs.unlink(src),\n      !isWindows && fs.chmod(dest, '0444'),\n    ])\n  } catch (e) {\n    return pinflight('cacache-move-file:' + dest, async () => {\n      await fs.stat(dest).catch((err) => {\n        if (err.code !== 'ENOENT') {\n          // Something else is wrong here. Bail bail bail\n          throw err\n        }\n      })\n      // file doesn't already exist! let's try a rename -> copy fallback\n      // only delete if it successfully copies\n      return move(src, dest)\n    })\n  }\n}\n"],"mappings":"AAAA,YAAY;;AAAA,IAAAA,iBAAA,GAAAC,OAAA,0GAAAC,OAAA;AAEZ,MAAMC,EAAE,GAAGF,OAAO,CAAC,YAAY,CAAC;AAChC,MAAMG,IAAI,GAAGH,OAAO,CAAC,mBAAmB,CAAC;AACzC,MAAMI,SAAS,GAAGJ,OAAO,CAAC,kBAAkB,CAAC;AAE7CK,MAAM,CAACC,OAAO,GAAGC,QAAQ;AAAA,SAEVA,QAAQA,CAAAC,EAAA,EAAAC,GAAA;EAAA,OAAAC,SAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA;AAAA,SAAAF,UAAA;EAAAA,SAAA,GAAAX,iBAAA,CAAvB,WAAyBc,GAAG,EAAEC,IAAI,EAAE;IAClC,MAAMC,SAAS,GAAGC,OAAO,CAACC,QAAQ,KAAK,OAAO;;IAE9C;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA,IAAI;MACF,MAAMf,EAAE,CAACgB,IAAI,CAACL,GAAG,EAAEC,IAAI,CAAC;IAC1B,CAAC,CAAC,OAAOK,GAAG,EAAE;MACZ,IAAIJ,SAAS,IAAII,GAAG,CAACC,IAAI,KAAK,OAAO,EAAE;QACrC;QACA;QACA;QACA;QACA;QACA;QACA;MAAA,CACD,MAAM,IAAID,GAAG,CAACC,IAAI,KAAK,QAAQ,IAAID,GAAG,CAACC,IAAI,KAAK,OAAO,EAAE;QACxD;MAAA,CACD,MAAM;QACL,MAAMD,GAAG;MACX;IACF;IACA,IAAI;MACF,MAAME,OAAO,CAACC,GAAG,CAAC,CAChBpB,EAAE,CAACqB,MAAM,CAACV,GAAG,CAAC,EACd,CAACE,SAAS,IAAIb,EAAE,CAACsB,KAAK,CAACV,IAAI,EAAE,MAAM,CAAC,CACrC,CAAC;IACJ,CAAC,CAAC,OAAOW,CAAC,EAAE;MACV,OAAOrB,SAAS,CAAC,oBAAoB,GAAGU,IAAI,eAAAf,iBAAA,CAAE,aAAY;QACxD,MAAMG,EAAE,CAACwB,IAAI,CAACZ,IAAI,CAAC,CAACa,KAAK,CAAER,GAAG,IAAK;UACjC,IAAIA,GAAG,CAACC,IAAI,KAAK,QAAQ,EAAE;YACzB;YACA,MAAMD,GAAG;UACX;QACF,CAAC,CAAC;QACF;QACA;QACA,OAAOhB,IAAI,CAACU,GAAG,EAAEC,IAAI,CAAC;MACxB,CAAC,EAAC;IACJ;EACF,CAAC;EAAA,OAAAJ,SAAA,CAAAC,KAAA,OAAAC,SAAA;AAAA"},"metadata":{},"sourceType":"script","externalDependencies":[]}