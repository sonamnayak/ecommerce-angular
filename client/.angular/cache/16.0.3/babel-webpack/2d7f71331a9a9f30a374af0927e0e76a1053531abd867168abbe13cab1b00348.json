{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nfunction isAnyArrayBuffer(value) {\n  return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n  return Object.prototype.toString.call(value) === '[object Uint8Array]';\n}\nfunction isRegExp(d) {\n  return Object.prototype.toString.call(d) === '[object RegExp]';\n}\nfunction isMap(d) {\n  return Object.prototype.toString.call(d) === '[object Map]';\n}\nfunction isDate(d) {\n  return Object.prototype.toString.call(d) === '[object Date]';\n}\nconst BSON_MAJOR_VERSION = 5;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n  double: 1,\n  string: 2,\n  object: 3,\n  array: 4,\n  binData: 5,\n  undefined: 6,\n  objectId: 7,\n  bool: 8,\n  date: 9,\n  null: 10,\n  regex: 11,\n  dbPointer: 12,\n  javascript: 13,\n  symbol: 14,\n  javascriptWithScope: 15,\n  int: 16,\n  timestamp: 17,\n  long: 18,\n  decimal: 19,\n  minKey: -1,\n  maxKey: 127\n});\nclass BSONError extends Error {\n  get bsonError() {\n    return true;\n  }\n  get name() {\n    return 'BSONError';\n  }\n  constructor(message) {\n    super(message);\n  }\n  static isBSONError(value) {\n    return value != null && typeof value === 'object' && 'bsonError' in value && value.bsonError === true && 'name' in value && 'message' in value && 'stack' in value;\n  }\n}\nclass BSONVersionError extends BSONError {\n  get name() {\n    return 'BSONVersionError';\n  }\n  constructor() {\n    super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.0 or later`);\n  }\n}\nclass BSONRuntimeError extends BSONError {\n  get name() {\n    return 'BSONRuntimeError';\n  }\n  constructor(message) {\n    super(message);\n  }\n}\nfunction nodejsMathRandomBytes(byteLength) {\n  return nodeJsByteUtils.fromNumberArray(Array.from({\n    length: byteLength\n  }, () => Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = await _asyncToGenerator(function* () {\n  try {\n    return (yield import('crypto')).randomBytes;\n  } catch {\n    return nodejsMathRandomBytes;\n  }\n})();\nconst nodeJsByteUtils = {\n  toLocalBufferType(potentialBuffer) {\n    if (Buffer.isBuffer(potentialBuffer)) {\n      return potentialBuffer;\n    }\n    if (ArrayBuffer.isView(potentialBuffer)) {\n      return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n    }\n    const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {\n      return Buffer.from(potentialBuffer);\n    }\n    throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n  },\n  allocate(size) {\n    return Buffer.alloc(size);\n  },\n  equals(a, b) {\n    return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n  },\n  fromNumberArray(array) {\n    return Buffer.from(array);\n  },\n  fromBase64(base64) {\n    return Buffer.from(base64, 'base64');\n  },\n  toBase64(buffer) {\n    return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');\n  },\n  fromISO88591(codePoints) {\n    return Buffer.from(codePoints, 'binary');\n  },\n  toISO88591(buffer) {\n    return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');\n  },\n  fromHex(hex) {\n    return Buffer.from(hex, 'hex');\n  },\n  toHex(buffer) {\n    return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');\n  },\n  fromUTF8(text) {\n    return Buffer.from(text, 'utf8');\n  },\n  toUTF8(buffer) {\n    return nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8');\n  },\n  utf8ByteLength(input) {\n    return Buffer.byteLength(input, 'utf8');\n  },\n  encodeUTF8Into(buffer, source, byteOffset) {\n    return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');\n  },\n  randomBytes: nodejsRandomBytes\n};\nfunction isReactNative() {\n  const {\n    navigator\n  } = globalThis;\n  return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\nfunction webMathRandomBytes(byteLength) {\n  if (byteLength < 0) {\n    throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n  }\n  return webByteUtils.fromNumberArray(Array.from({\n    length: byteLength\n  }, () => Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (() => {\n  const {\n    crypto\n  } = globalThis;\n  if (crypto != null && typeof crypto.getRandomValues === 'function') {\n    return byteLength => {\n      return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n    };\n  } else {\n    if (isReactNative()) {\n      const {\n        console\n      } = globalThis;\n      console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');\n    }\n    return webMathRandomBytes;\n  }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n  toLocalBufferType(potentialUint8array) {\n    const stringTag = potentialUint8array?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialUint8array);\n    if (stringTag === 'Uint8Array') {\n      return potentialUint8array;\n    }\n    if (ArrayBuffer.isView(potentialUint8array)) {\n      return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n    }\n    if (stringTag === 'ArrayBuffer' || stringTag === 'SharedArrayBuffer' || stringTag === '[object ArrayBuffer]' || stringTag === '[object SharedArrayBuffer]') {\n      return new Uint8Array(potentialUint8array);\n    }\n    throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n  },\n  allocate(size) {\n    if (typeof size !== 'number') {\n      throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n    }\n    return new Uint8Array(size);\n  },\n  equals(a, b) {\n    if (a.byteLength !== b.byteLength) {\n      return false;\n    }\n    for (let i = 0; i < a.byteLength; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n    return true;\n  },\n  fromNumberArray(array) {\n    return Uint8Array.from(array);\n  },\n  fromBase64(base64) {\n    return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n  },\n  toBase64(uint8array) {\n    return btoa(webByteUtils.toISO88591(uint8array));\n  },\n  fromISO88591(codePoints) {\n    return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n  },\n  toISO88591(uint8array) {\n    return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n  },\n  fromHex(hex) {\n    const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n    const buffer = [];\n    for (let i = 0; i < evenLengthHex.length; i += 2) {\n      const firstDigit = evenLengthHex[i];\n      const secondDigit = evenLengthHex[i + 1];\n      if (!HEX_DIGIT.test(firstDigit)) {\n        break;\n      }\n      if (!HEX_DIGIT.test(secondDigit)) {\n        break;\n      }\n      const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n      buffer.push(hexDigit);\n    }\n    return Uint8Array.from(buffer);\n  },\n  toHex(uint8array) {\n    return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n  },\n  fromUTF8(text) {\n    return new TextEncoder().encode(text);\n  },\n  toUTF8(uint8array) {\n    return new TextDecoder('utf8', {\n      fatal: false\n    }).decode(uint8array);\n  },\n  utf8ByteLength(input) {\n    return webByteUtils.fromUTF8(input).byteLength;\n  },\n  encodeUTF8Into(buffer, source, byteOffset) {\n    const bytes = webByteUtils.fromUTF8(source);\n    buffer.set(bytes, byteOffset);\n    return bytes.byteLength;\n  },\n  randomBytes: webRandomBytes\n};\nconst hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n  static fromUint8Array(input) {\n    return new DataView(input.buffer, input.byteOffset, input.byteLength);\n  }\n}\nclass BSONValue {\n  get [Symbol.for('@@mdb.bson.version')]() {\n    return BSON_MAJOR_VERSION;\n  }\n}\nclass Binary extends BSONValue {\n  get _bsontype() {\n    return 'Binary';\n  }\n  constructor(buffer, subType) {\n    super();\n    if (!(buffer == null) && !(typeof buffer === 'string') && !ArrayBuffer.isView(buffer) && !(buffer instanceof ArrayBuffer) && !Array.isArray(buffer)) {\n      throw new BSONError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');\n    }\n    this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n    if (buffer == null) {\n      this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n      this.position = 0;\n    } else {\n      if (typeof buffer === 'string') {\n        this.buffer = ByteUtils.fromISO88591(buffer);\n      } else if (Array.isArray(buffer)) {\n        this.buffer = ByteUtils.fromNumberArray(buffer);\n      } else {\n        this.buffer = ByteUtils.toLocalBufferType(buffer);\n      }\n      this.position = this.buffer.byteLength;\n    }\n  }\n  put(byteValue) {\n    if (typeof byteValue === 'string' && byteValue.length !== 1) {\n      throw new BSONError('only accepts single character String');\n    } else if (typeof byteValue !== 'number' && byteValue.length !== 1) throw new BSONError('only accepts single character Uint8Array or Array');\n    let decodedByte;\n    if (typeof byteValue === 'string') {\n      decodedByte = byteValue.charCodeAt(0);\n    } else if (typeof byteValue === 'number') {\n      decodedByte = byteValue;\n    } else {\n      decodedByte = byteValue[0];\n    }\n    if (decodedByte < 0 || decodedByte > 255) {\n      throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n    }\n    if (this.buffer.byteLength > this.position) {\n      this.buffer[this.position++] = decodedByte;\n    } else {\n      const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n      newSpace.set(this.buffer, 0);\n      this.buffer = newSpace;\n      this.buffer[this.position++] = decodedByte;\n    }\n  }\n  write(sequence, offset) {\n    offset = typeof offset === 'number' ? offset : this.position;\n    if (this.buffer.byteLength < offset + sequence.length) {\n      const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n      newSpace.set(this.buffer, 0);\n      this.buffer = newSpace;\n    }\n    if (ArrayBuffer.isView(sequence)) {\n      this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n      this.position = offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n    } else if (typeof sequence === 'string') {\n      const bytes = ByteUtils.fromISO88591(sequence);\n      this.buffer.set(bytes, offset);\n      this.position = offset + sequence.length > this.position ? offset + sequence.length : this.position;\n    }\n  }\n  read(position, length) {\n    length = length && length > 0 ? length : this.position;\n    return this.buffer.slice(position, position + length);\n  }\n  value(asRaw) {\n    asRaw = !!asRaw;\n    if (asRaw && this.buffer.length === this.position) {\n      return this.buffer;\n    }\n    if (asRaw) {\n      return this.buffer.slice(0, this.position);\n    }\n    return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));\n  }\n  length() {\n    return this.position;\n  }\n  toJSON() {\n    return ByteUtils.toBase64(this.buffer);\n  }\n  toString(encoding) {\n    if (encoding === 'hex') return ByteUtils.toHex(this.buffer);\n    if (encoding === 'base64') return ByteUtils.toBase64(this.buffer);\n    if (encoding === 'utf8' || encoding === 'utf-8') return ByteUtils.toUTF8(this.buffer);\n    return ByteUtils.toUTF8(this.buffer);\n  }\n  toExtendedJSON(options) {\n    options = options || {};\n    const base64String = ByteUtils.toBase64(this.buffer);\n    const subType = Number(this.sub_type).toString(16);\n    if (options.legacy) {\n      return {\n        $binary: base64String,\n        $type: subType.length === 1 ? '0' + subType : subType\n      };\n    }\n    return {\n      $binary: {\n        base64: base64String,\n        subType: subType.length === 1 ? '0' + subType : subType\n      }\n    };\n  }\n  toUUID() {\n    if (this.sub_type === Binary.SUBTYPE_UUID) {\n      return new UUID(this.buffer.slice(0, this.position));\n    }\n    throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n  }\n  static createFromHexString(hex, subType) {\n    return new Binary(ByteUtils.fromHex(hex), subType);\n  }\n  static createFromBase64(base64, subType) {\n    return new Binary(ByteUtils.fromBase64(base64), subType);\n  }\n  static fromExtendedJSON(doc, options) {\n    options = options || {};\n    let data;\n    let type;\n    if ('$binary' in doc) {\n      if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n        type = doc.$type ? parseInt(doc.$type, 16) : 0;\n        data = ByteUtils.fromBase64(doc.$binary);\n      } else {\n        if (typeof doc.$binary !== 'string') {\n          type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n          data = ByteUtils.fromBase64(doc.$binary.base64);\n        }\n      }\n    } else if ('$uuid' in doc) {\n      type = 4;\n      data = UUID.bytesFromString(doc.$uuid);\n    }\n    if (!data) {\n      throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n    }\n    return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n    return `Binary.createFromBase64(\"${base64}\", ${this.sub_type})`;\n  }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n  constructor(input) {\n    let bytes;\n    if (input == null) {\n      bytes = UUID.generate();\n    } else if (input instanceof UUID) {\n      bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n    } else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n      bytes = ByteUtils.toLocalBufferType(input);\n    } else if (typeof input === 'string') {\n      bytes = UUID.bytesFromString(input);\n    } else {\n      throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n    }\n    super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n  }\n  get id() {\n    return this.buffer;\n  }\n  set id(value) {\n    this.buffer = value;\n  }\n  toHexString(includeDashes = true) {\n    if (includeDashes) {\n      return [ByteUtils.toHex(this.buffer.subarray(0, 4)), ByteUtils.toHex(this.buffer.subarray(4, 6)), ByteUtils.toHex(this.buffer.subarray(6, 8)), ByteUtils.toHex(this.buffer.subarray(8, 10)), ByteUtils.toHex(this.buffer.subarray(10, 16))].join('-');\n    }\n    return ByteUtils.toHex(this.buffer);\n  }\n  toString(encoding) {\n    if (encoding === 'hex') return ByteUtils.toHex(this.id);\n    if (encoding === 'base64') return ByteUtils.toBase64(this.id);\n    return this.toHexString();\n  }\n  toJSON() {\n    return this.toHexString();\n  }\n  equals(otherId) {\n    if (!otherId) {\n      return false;\n    }\n    if (otherId instanceof UUID) {\n      return ByteUtils.equals(otherId.id, this.id);\n    }\n    try {\n      return ByteUtils.equals(new UUID(otherId).id, this.id);\n    } catch {\n      return false;\n    }\n  }\n  toBinary() {\n    return new Binary(this.id, Binary.SUBTYPE_UUID);\n  }\n  static generate() {\n    const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n    bytes[6] = bytes[6] & 0x0f | 0x40;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    return bytes;\n  }\n  static isValid(input) {\n    if (!input) {\n      return false;\n    }\n    if (typeof input === 'string') {\n      return UUID.isValidUUIDString(input);\n    }\n    if (isUint8Array(input)) {\n      return input.byteLength === UUID_BYTE_LENGTH;\n    }\n    return input._bsontype === 'Binary' && input.sub_type === this.SUBTYPE_UUID && input.buffer.byteLength === 16;\n  }\n  static createFromHexString(hexString) {\n    const buffer = UUID.bytesFromString(hexString);\n    return new UUID(buffer);\n  }\n  static createFromBase64(base64) {\n    return new UUID(ByteUtils.fromBase64(base64));\n  }\n  static bytesFromString(representation) {\n    if (!UUID.isValidUUIDString(representation)) {\n      throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');\n    }\n    return ByteUtils.fromHex(representation.replace(/-/g, ''));\n  }\n  static isValidUUIDString(representation) {\n    return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new UUID(\"${this.toHexString()}\")`;\n  }\n}\nUUID.cacheHexString = false;\nclass Code extends BSONValue {\n  get _bsontype() {\n    return 'Code';\n  }\n  constructor(code, scope) {\n    super();\n    this.code = code.toString();\n    this.scope = scope ?? null;\n  }\n  toJSON() {\n    if (this.scope != null) {\n      return {\n        code: this.code,\n        scope: this.scope\n      };\n    }\n    return {\n      code: this.code\n    };\n  }\n  toExtendedJSON() {\n    if (this.scope) {\n      return {\n        $code: this.code,\n        $scope: this.scope\n      };\n    }\n    return {\n      $code: this.code\n    };\n  }\n  static fromExtendedJSON(doc) {\n    return new Code(doc.$code, doc.$scope);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    const codeJson = this.toJSON();\n    return `new Code(\"${String(codeJson.code)}\"${codeJson.scope != null ? `, ${JSON.stringify(codeJson.scope)}` : ''})`;\n  }\n}\nfunction isDBRefLike(value) {\n  return value != null && typeof value === 'object' && '$id' in value && value.$id != null && '$ref' in value && typeof value.$ref === 'string' && (!('$db' in value) || '$db' in value && typeof value.$db === 'string');\n}\nclass DBRef extends BSONValue {\n  get _bsontype() {\n    return 'DBRef';\n  }\n  constructor(collection, oid, db, fields) {\n    super();\n    const parts = collection.split('.');\n    if (parts.length === 2) {\n      db = parts.shift();\n      collection = parts.shift();\n    }\n    this.collection = collection;\n    this.oid = oid;\n    this.db = db;\n    this.fields = fields || {};\n  }\n  get namespace() {\n    return this.collection;\n  }\n  set namespace(value) {\n    this.collection = value;\n  }\n  toJSON() {\n    const o = Object.assign({\n      $ref: this.collection,\n      $id: this.oid\n    }, this.fields);\n    if (this.db != null) o.$db = this.db;\n    return o;\n  }\n  toExtendedJSON(options) {\n    options = options || {};\n    let o = {\n      $ref: this.collection,\n      $id: this.oid\n    };\n    if (options.legacy) {\n      return o;\n    }\n    if (this.db) o.$db = this.db;\n    o = Object.assign(o, this.fields);\n    return o;\n  }\n  static fromExtendedJSON(doc) {\n    const copy = Object.assign({}, doc);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\n    return `new DBRef(\"${this.namespace}\", new ObjectId(\"${String(oid)}\")${this.db ? `, \"${this.db}\"` : ''})`;\n  }\n}\nlet wasm = undefined;\ntry {\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n} catch {}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n  get _bsontype() {\n    return 'Long';\n  }\n  get __isLong__() {\n    return true;\n  }\n  constructor(low = 0, high, unsigned) {\n    super();\n    if (typeof low === 'bigint') {\n      Object.assign(this, Long.fromBigInt(low, !!high));\n    } else if (typeof low === 'string') {\n      Object.assign(this, Long.fromString(low, !!high));\n    } else {\n      this.low = low | 0;\n      this.high = high | 0;\n      this.unsigned = !!unsigned;\n    }\n  }\n  static fromBits(lowBits, highBits, unsigned) {\n    return new Long(lowBits, highBits, unsigned);\n  }\n  static fromInt(value, unsigned) {\n    let obj, cachedObj, cache;\n    if (unsigned) {\n      value >>>= 0;\n      if (cache = 0 <= value && value < 256) {\n        cachedObj = UINT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n      obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n      if (cache) UINT_CACHE[value] = obj;\n      return obj;\n    } else {\n      value |= 0;\n      if (cache = -128 <= value && value < 128) {\n        cachedObj = INT_CACHE[value];\n        if (cachedObj) return cachedObj;\n      }\n      obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n      if (cache) INT_CACHE[value] = obj;\n      return obj;\n    }\n  }\n  static fromNumber(value, unsigned) {\n    if (isNaN(value)) return unsigned ? Long.UZERO : Long.ZERO;\n    if (unsigned) {\n      if (value < 0) return Long.UZERO;\n      if (value >= TWO_PWR_64_DBL) return Long.MAX_UNSIGNED_VALUE;\n    } else {\n      if (value <= -TWO_PWR_63_DBL) return Long.MIN_VALUE;\n      if (value + 1 >= TWO_PWR_63_DBL) return Long.MAX_VALUE;\n    }\n    if (value < 0) return Long.fromNumber(-value, unsigned).neg();\n    return Long.fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);\n  }\n  static fromBigInt(value, unsigned) {\n    return Long.fromString(value.toString(), unsigned);\n  }\n  static fromString(str, unsigned, radix) {\n    if (str.length === 0) throw new BSONError('empty string');\n    if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity') return Long.ZERO;\n    if (typeof unsigned === 'number') {\n      radix = unsigned, unsigned = false;\n    } else {\n      unsigned = !!unsigned;\n    }\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw new BSONError('radix');\n    let p;\n    if ((p = str.indexOf('-')) > 0) throw new BSONError('interior hyphen');else if (p === 0) {\n      return Long.fromString(str.substring(1), unsigned, radix).neg();\n    }\n    const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n    let result = Long.ZERO;\n    for (let i = 0; i < str.length; i += 8) {\n      const size = Math.min(8, str.length - i),\n        value = parseInt(str.substring(i, i + size), radix);\n      if (size < 8) {\n        const power = Long.fromNumber(Math.pow(radix, size));\n        result = result.mul(power).add(Long.fromNumber(value));\n      } else {\n        result = result.mul(radixToPower);\n        result = result.add(Long.fromNumber(value));\n      }\n    }\n    result.unsigned = unsigned;\n    return result;\n  }\n  static fromBytes(bytes, unsigned, le) {\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n  }\n  static fromBytesLE(bytes, unsigned) {\n    return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);\n  }\n  static fromBytesBE(bytes, unsigned) {\n    return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);\n  }\n  static isLong(value) {\n    return value != null && typeof value === 'object' && '__isLong__' in value && value.__isLong__ === true;\n  }\n  static fromValue(val, unsigned) {\n    if (typeof val === 'number') return Long.fromNumber(val, unsigned);\n    if (typeof val === 'string') return Long.fromString(val, unsigned);\n    return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n  }\n  add(addend) {\n    if (!Long.isLong(addend)) addend = Long.fromValue(addend);\n    const a48 = this.high >>> 16;\n    const a32 = this.high & 0xffff;\n    const a16 = this.low >>> 16;\n    const a00 = this.low & 0xffff;\n    const b48 = addend.high >>> 16;\n    const b32 = addend.high & 0xffff;\n    const b16 = addend.low >>> 16;\n    const b00 = addend.low & 0xffff;\n    let c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n    c00 += a00 + b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xffff;\n    c16 += a16 + b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c32 += a32 + b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c48 += a48 + b48;\n    c48 &= 0xffff;\n    return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  }\n  and(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n  }\n  compare(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.eq(other)) return 0;\n    const thisNeg = this.isNegative(),\n      otherNeg = other.isNegative();\n    if (thisNeg && !otherNeg) return -1;\n    if (!thisNeg && otherNeg) return 1;\n    if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;\n    return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;\n  }\n  comp(other) {\n    return this.compare(other);\n  }\n  divide(divisor) {\n    if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n    if (divisor.isZero()) throw new BSONError('division by zero');\n    if (wasm) {\n      if (!this.unsigned && this.high === -0x80000000 && divisor.low === -1 && divisor.high === -1) {\n        return this;\n      }\n      const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n      return Long.fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    if (this.isZero()) return this.unsigned ? Long.UZERO : Long.ZERO;\n    let approx, rem, res;\n    if (!this.unsigned) {\n      if (this.eq(Long.MIN_VALUE)) {\n        if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE)) return Long.MIN_VALUE;else if (divisor.eq(Long.MIN_VALUE)) return Long.ONE;else {\n          const halfThis = this.shr(1);\n          approx = halfThis.div(divisor).shl(1);\n          if (approx.eq(Long.ZERO)) {\n            return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n          } else {\n            rem = this.sub(divisor.mul(approx));\n            res = approx.add(rem.div(divisor));\n            return res;\n          }\n        }\n      } else if (divisor.eq(Long.MIN_VALUE)) return this.unsigned ? Long.UZERO : Long.ZERO;\n      if (this.isNegative()) {\n        if (divisor.isNegative()) return this.neg().div(divisor.neg());\n        return this.neg().div(divisor).neg();\n      } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();\n      res = Long.ZERO;\n    } else {\n      if (!divisor.unsigned) divisor = divisor.toUnsigned();\n      if (divisor.gt(this)) return Long.UZERO;\n      if (divisor.gt(this.shru(1))) return Long.UONE;\n      res = Long.UZERO;\n    }\n    rem = this;\n    while (rem.gte(divisor)) {\n      approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n      const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n      const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n      let approxRes = Long.fromNumber(approx);\n      let approxRem = approxRes.mul(divisor);\n      while (approxRem.isNegative() || approxRem.gt(rem)) {\n        approx -= delta;\n        approxRes = Long.fromNumber(approx, this.unsigned);\n        approxRem = approxRes.mul(divisor);\n      }\n      if (approxRes.isZero()) approxRes = Long.ONE;\n      res = res.add(approxRes);\n      rem = rem.sub(approxRem);\n    }\n    return res;\n  }\n  div(divisor) {\n    return this.divide(divisor);\n  }\n  equals(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;\n    return this.high === other.high && this.low === other.low;\n  }\n  eq(other) {\n    return this.equals(other);\n  }\n  getHighBits() {\n    return this.high;\n  }\n  getHighBitsUnsigned() {\n    return this.high >>> 0;\n  }\n  getLowBits() {\n    return this.low;\n  }\n  getLowBitsUnsigned() {\n    return this.low >>> 0;\n  }\n  getNumBitsAbs() {\n    if (this.isNegative()) {\n      return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n    }\n    const val = this.high !== 0 ? this.high : this.low;\n    let bit;\n    for (bit = 31; bit > 0; bit--) if ((val & 1 << bit) !== 0) break;\n    return this.high !== 0 ? bit + 33 : bit + 1;\n  }\n  greaterThan(other) {\n    return this.comp(other) > 0;\n  }\n  gt(other) {\n    return this.greaterThan(other);\n  }\n  greaterThanOrEqual(other) {\n    return this.comp(other) >= 0;\n  }\n  gte(other) {\n    return this.greaterThanOrEqual(other);\n  }\n  ge(other) {\n    return this.greaterThanOrEqual(other);\n  }\n  isEven() {\n    return (this.low & 1) === 0;\n  }\n  isNegative() {\n    return !this.unsigned && this.high < 0;\n  }\n  isOdd() {\n    return (this.low & 1) === 1;\n  }\n  isPositive() {\n    return this.unsigned || this.high >= 0;\n  }\n  isZero() {\n    return this.high === 0 && this.low === 0;\n  }\n  lessThan(other) {\n    return this.comp(other) < 0;\n  }\n  lt(other) {\n    return this.lessThan(other);\n  }\n  lessThanOrEqual(other) {\n    return this.comp(other) <= 0;\n  }\n  lte(other) {\n    return this.lessThanOrEqual(other);\n  }\n  modulo(divisor) {\n    if (!Long.isLong(divisor)) divisor = Long.fromValue(divisor);\n    if (wasm) {\n      const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n      return Long.fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    return this.sub(this.div(divisor).mul(divisor));\n  }\n  mod(divisor) {\n    return this.modulo(divisor);\n  }\n  rem(divisor) {\n    return this.modulo(divisor);\n  }\n  multiply(multiplier) {\n    if (this.isZero()) return Long.ZERO;\n    if (!Long.isLong(multiplier)) multiplier = Long.fromValue(multiplier);\n    if (wasm) {\n      const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n      return Long.fromBits(low, wasm.get_high(), this.unsigned);\n    }\n    if (multiplier.isZero()) return Long.ZERO;\n    if (this.eq(Long.MIN_VALUE)) return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n    if (multiplier.eq(Long.MIN_VALUE)) return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n    if (this.isNegative()) {\n      if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());else return this.neg().mul(multiplier).neg();\n    } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();\n    if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24)) return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n    const a48 = this.high >>> 16;\n    const a32 = this.high & 0xffff;\n    const a16 = this.low >>> 16;\n    const a00 = this.low & 0xffff;\n    const b48 = multiplier.high >>> 16;\n    const b32 = multiplier.high & 0xffff;\n    const b16 = multiplier.low >>> 16;\n    const b00 = multiplier.low & 0xffff;\n    let c48 = 0,\n      c32 = 0,\n      c16 = 0,\n      c00 = 0;\n    c00 += a00 * b00;\n    c16 += c00 >>> 16;\n    c00 &= 0xffff;\n    c16 += a16 * b00;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c16 += a00 * b16;\n    c32 += c16 >>> 16;\n    c16 &= 0xffff;\n    c32 += a32 * b00;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c32 += a16 * b16;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c32 += a00 * b32;\n    c48 += c32 >>> 16;\n    c32 &= 0xffff;\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n    c48 &= 0xffff;\n    return Long.fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);\n  }\n  mul(multiplier) {\n    return this.multiply(multiplier);\n  }\n  negate() {\n    if (!this.unsigned && this.eq(Long.MIN_VALUE)) return Long.MIN_VALUE;\n    return this.not().add(Long.ONE);\n  }\n  neg() {\n    return this.negate();\n  }\n  not() {\n    return Long.fromBits(~this.low, ~this.high, this.unsigned);\n  }\n  notEquals(other) {\n    return !this.equals(other);\n  }\n  neq(other) {\n    return this.notEquals(other);\n  }\n  ne(other) {\n    return this.notEquals(other);\n  }\n  or(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n  }\n  shiftLeft(numBits) {\n    if (Long.isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);else return Long.fromBits(0, this.low << numBits - 32, this.unsigned);\n  }\n  shl(numBits) {\n    return this.shiftLeft(numBits);\n  }\n  shiftRight(numBits) {\n    if (Long.isLong(numBits)) numBits = numBits.toInt();\n    if ((numBits &= 63) === 0) return this;else if (numBits < 32) return Long.fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);else return Long.fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);\n  }\n  shr(numBits) {\n    return this.shiftRight(numBits);\n  }\n  shiftRightUnsigned(numBits) {\n    if (Long.isLong(numBits)) numBits = numBits.toInt();\n    numBits &= 63;\n    if (numBits === 0) return this;else {\n      const high = this.high;\n      if (numBits < 32) {\n        const low = this.low;\n        return Long.fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);\n      } else if (numBits === 32) return Long.fromBits(high, 0, this.unsigned);else return Long.fromBits(high >>> numBits - 32, 0, this.unsigned);\n    }\n  }\n  shr_u(numBits) {\n    return this.shiftRightUnsigned(numBits);\n  }\n  shru(numBits) {\n    return this.shiftRightUnsigned(numBits);\n  }\n  subtract(subtrahend) {\n    if (!Long.isLong(subtrahend)) subtrahend = Long.fromValue(subtrahend);\n    return this.add(subtrahend.neg());\n  }\n  sub(subtrahend) {\n    return this.subtract(subtrahend);\n  }\n  toInt() {\n    return this.unsigned ? this.low >>> 0 : this.low;\n  }\n  toNumber() {\n    if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n  }\n  toBigInt() {\n    return BigInt(this.toString());\n  }\n  toBytes(le) {\n    return le ? this.toBytesLE() : this.toBytesBE();\n  }\n  toBytesLE() {\n    const hi = this.high,\n      lo = this.low;\n    return [lo & 0xff, lo >>> 8 & 0xff, lo >>> 16 & 0xff, lo >>> 24, hi & 0xff, hi >>> 8 & 0xff, hi >>> 16 & 0xff, hi >>> 24];\n  }\n  toBytesBE() {\n    const hi = this.high,\n      lo = this.low;\n    return [hi >>> 24, hi >>> 16 & 0xff, hi >>> 8 & 0xff, hi & 0xff, lo >>> 24, lo >>> 16 & 0xff, lo >>> 8 & 0xff, lo & 0xff];\n  }\n  toSigned() {\n    if (!this.unsigned) return this;\n    return Long.fromBits(this.low, this.high, false);\n  }\n  toString(radix) {\n    radix = radix || 10;\n    if (radix < 2 || 36 < radix) throw new BSONError('radix');\n    if (this.isZero()) return '0';\n    if (this.isNegative()) {\n      if (this.eq(Long.MIN_VALUE)) {\n        const radixLong = Long.fromNumber(radix),\n          div = this.div(radixLong),\n          rem1 = div.mul(radixLong).sub(this);\n        return div.toString(radix) + rem1.toInt().toString(radix);\n      } else return '-' + this.neg().toString(radix);\n    }\n    const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n    let rem = this;\n    let result = '';\n    while (true) {\n      const remDiv = rem.div(radixToPower);\n      const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n      let digits = intval.toString(radix);\n      rem = remDiv;\n      if (rem.isZero()) {\n        return digits + result;\n      } else {\n        while (digits.length < 6) digits = '0' + digits;\n        result = '' + digits + result;\n      }\n    }\n  }\n  toUnsigned() {\n    if (this.unsigned) return this;\n    return Long.fromBits(this.low, this.high, true);\n  }\n  xor(other) {\n    if (!Long.isLong(other)) other = Long.fromValue(other);\n    return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n  }\n  eqz() {\n    return this.isZero();\n  }\n  le(other) {\n    return this.lessThanOrEqual(other);\n  }\n  toExtendedJSON(options) {\n    if (options && options.relaxed) return this.toNumber();\n    return {\n      $numberLong: this.toString()\n    };\n  }\n  static fromExtendedJSON(doc, options) {\n    const {\n      useBigInt64 = false,\n      relaxed = true\n    } = {\n      ...options\n    };\n    if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n      throw new BSONError('$numberLong string is too long');\n    }\n    if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n      throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n    }\n    if (useBigInt64) {\n      const bigIntResult = BigInt(doc.$numberLong);\n      return BigInt.asIntN(64, bigIntResult);\n    }\n    const longResult = Long.fromString(doc.$numberLong);\n    if (relaxed) {\n      return longResult.toNumber();\n    }\n    return longResult;\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new Long(\"${this.toString()}\"${this.unsigned ? ', true' : ''})`;\n  }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n  return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n  const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n  let _rem = Long.fromNumber(0);\n  if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n    return {\n      quotient: value,\n      rem: _rem\n    };\n  }\n  for (let i = 0; i <= 3; i++) {\n    _rem = _rem.shiftLeft(32);\n    _rem = _rem.add(new Long(value.parts[i], 0));\n    value.parts[i] = _rem.div(DIVISOR).low;\n    _rem = _rem.modulo(DIVISOR);\n  }\n  return {\n    quotient: value,\n    rem: _rem\n  };\n}\nfunction multiply64x2(left, right) {\n  if (!left && !right) {\n    return {\n      high: Long.fromNumber(0),\n      low: Long.fromNumber(0)\n    };\n  }\n  const leftHigh = left.shiftRightUnsigned(32);\n  const leftLow = new Long(left.getLowBits(), 0);\n  const rightHigh = right.shiftRightUnsigned(32);\n  const rightLow = new Long(right.getLowBits(), 0);\n  let productHigh = leftHigh.multiply(rightHigh);\n  let productMid = leftHigh.multiply(rightLow);\n  const productMid2 = leftLow.multiply(rightHigh);\n  let productLow = leftLow.multiply(rightLow);\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productMid = new Long(productMid.getLowBits(), 0).add(productMid2).add(productLow.shiftRightUnsigned(32));\n  productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n  productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n  return {\n    high: productHigh,\n    low: productLow\n  };\n}\nfunction lessThan(left, right) {\n  const uhleft = left.high >>> 0;\n  const uhright = right.high >>> 0;\n  if (uhleft < uhright) {\n    return true;\n  } else if (uhleft === uhright) {\n    const ulleft = left.low >>> 0;\n    const ulright = right.low >>> 0;\n    if (ulleft < ulright) return true;\n  }\n  return false;\n}\nfunction invalidErr(string, message) {\n  throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n  get _bsontype() {\n    return 'Decimal128';\n  }\n  constructor(bytes) {\n    super();\n    if (typeof bytes === 'string') {\n      this.bytes = Decimal128.fromString(bytes).bytes;\n    } else if (isUint8Array(bytes)) {\n      if (bytes.byteLength !== 16) {\n        throw new BSONError('Decimal128 must take a Buffer of 16 bytes');\n      }\n      this.bytes = bytes;\n    } else {\n      throw new BSONError('Decimal128 must take a Buffer or string');\n    }\n  }\n  static fromString(representation) {\n    let isNegative = false;\n    let sawRadix = false;\n    let foundNonZero = false;\n    let significantDigits = 0;\n    let nDigitsRead = 0;\n    let nDigits = 0;\n    let radixPosition = 0;\n    let firstNonZero = 0;\n    const digits = [0];\n    let nDigitsStored = 0;\n    let digitsInsert = 0;\n    let firstDigit = 0;\n    let lastDigit = 0;\n    let exponent = 0;\n    let i = 0;\n    let significandHigh = new Long(0, 0);\n    let significandLow = new Long(0, 0);\n    let biasedExponent = 0;\n    let index = 0;\n    if (representation.length >= 7000) {\n      throw new BSONError('' + representation + ' not a valid Decimal128 string');\n    }\n    const stringMatch = representation.match(PARSE_STRING_REGEXP);\n    const infMatch = representation.match(PARSE_INF_REGEXP);\n    const nanMatch = representation.match(PARSE_NAN_REGEXP);\n    if (!stringMatch && !infMatch && !nanMatch || representation.length === 0) {\n      throw new BSONError('' + representation + ' not a valid Decimal128 string');\n    }\n    if (stringMatch) {\n      const unsignedNumber = stringMatch[2];\n      const e = stringMatch[4];\n      const expSign = stringMatch[5];\n      const expNumber = stringMatch[6];\n      if (e && expNumber === undefined) invalidErr(representation, 'missing exponent power');\n      if (e && unsignedNumber === undefined) invalidErr(representation, 'missing exponent base');\n      if (e === undefined && (expSign || expNumber)) {\n        invalidErr(representation, 'missing e before exponent');\n      }\n    }\n    if (representation[index] === '+' || representation[index] === '-') {\n      isNegative = representation[index++] === '-';\n    }\n    if (!isDigit(representation[index]) && representation[index] !== '.') {\n      if (representation[index] === 'i' || representation[index] === 'I') {\n        return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n      } else if (representation[index] === 'N') {\n        return new Decimal128(NAN_BUFFER);\n      }\n    }\n    while (isDigit(representation[index]) || representation[index] === '.') {\n      if (representation[index] === '.') {\n        if (sawRadix) invalidErr(representation, 'contains multiple periods');\n        sawRadix = true;\n        index = index + 1;\n        continue;\n      }\n      if (nDigitsStored < 34) {\n        if (representation[index] !== '0' || foundNonZero) {\n          if (!foundNonZero) {\n            firstNonZero = nDigitsRead;\n          }\n          foundNonZero = true;\n          digits[digitsInsert++] = parseInt(representation[index], 10);\n          nDigitsStored = nDigitsStored + 1;\n        }\n      }\n      if (foundNonZero) nDigits = nDigits + 1;\n      if (sawRadix) radixPosition = radixPosition + 1;\n      nDigitsRead = nDigitsRead + 1;\n      index = index + 1;\n    }\n    if (sawRadix && !nDigitsRead) throw new BSONError('' + representation + ' not a valid Decimal128 string');\n    if (representation[index] === 'e' || representation[index] === 'E') {\n      const match = representation.substr(++index).match(EXPONENT_REGEX);\n      if (!match || !match[2]) return new Decimal128(NAN_BUFFER);\n      exponent = parseInt(match[0], 10);\n      index = index + match[0].length;\n    }\n    if (representation[index]) return new Decimal128(NAN_BUFFER);\n    firstDigit = 0;\n    if (!nDigitsStored) {\n      firstDigit = 0;\n      lastDigit = 0;\n      digits[0] = 0;\n      nDigits = 1;\n      nDigitsStored = 1;\n      significantDigits = 0;\n    } else {\n      lastDigit = nDigitsStored - 1;\n      significantDigits = nDigits;\n      if (significantDigits !== 1) {\n        while (digits[firstNonZero + significantDigits - 1] === 0) {\n          significantDigits = significantDigits - 1;\n        }\n      }\n    }\n    if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\n      exponent = EXPONENT_MIN;\n    } else {\n      exponent = exponent - radixPosition;\n    }\n    while (exponent > EXPONENT_MAX) {\n      lastDigit = lastDigit + 1;\n      if (lastDigit - firstDigit > MAX_DIGITS) {\n        const digitsString = digits.join('');\n        if (digitsString.match(/^0+$/)) {\n          exponent = EXPONENT_MAX;\n          break;\n        }\n        invalidErr(representation, 'overflow');\n      }\n      exponent = exponent - 1;\n    }\n    while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n      if (lastDigit === 0 && significantDigits < nDigitsStored) {\n        exponent = EXPONENT_MIN;\n        significantDigits = 0;\n        break;\n      }\n      if (nDigitsStored < nDigits) {\n        nDigits = nDigits - 1;\n      } else {\n        lastDigit = lastDigit - 1;\n      }\n      if (exponent < EXPONENT_MAX) {\n        exponent = exponent + 1;\n      } else {\n        const digitsString = digits.join('');\n        if (digitsString.match(/^0+$/)) {\n          exponent = EXPONENT_MAX;\n          break;\n        }\n        invalidErr(representation, 'overflow');\n      }\n    }\n    if (lastDigit - firstDigit + 1 < significantDigits) {\n      let endOfString = nDigitsRead;\n      if (sawRadix) {\n        firstNonZero = firstNonZero + 1;\n        endOfString = endOfString + 1;\n      }\n      if (isNegative) {\n        firstNonZero = firstNonZero + 1;\n        endOfString = endOfString + 1;\n      }\n      const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n      let roundBit = 0;\n      if (roundDigit >= 5) {\n        roundBit = 1;\n        if (roundDigit === 5) {\n          roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n          for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n            if (parseInt(representation[i], 10)) {\n              roundBit = 1;\n              break;\n            }\n          }\n        }\n      }\n      if (roundBit) {\n        let dIdx = lastDigit;\n        for (; dIdx >= 0; dIdx--) {\n          if (++digits[dIdx] > 9) {\n            digits[dIdx] = 0;\n            if (dIdx === 0) {\n              if (exponent < EXPONENT_MAX) {\n                exponent = exponent + 1;\n                digits[dIdx] = 1;\n              } else {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n              }\n            }\n          }\n        }\n      }\n    }\n    significandHigh = Long.fromNumber(0);\n    significandLow = Long.fromNumber(0);\n    if (significantDigits === 0) {\n      significandHigh = Long.fromNumber(0);\n      significandLow = Long.fromNumber(0);\n    } else if (lastDigit - firstDigit < 17) {\n      let dIdx = firstDigit;\n      significandLow = Long.fromNumber(digits[dIdx++]);\n      significandHigh = new Long(0, 0);\n      for (; dIdx <= lastDigit; dIdx++) {\n        significandLow = significandLow.multiply(Long.fromNumber(10));\n        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n      }\n    } else {\n      let dIdx = firstDigit;\n      significandHigh = Long.fromNumber(digits[dIdx++]);\n      for (; dIdx <= lastDigit - 17; dIdx++) {\n        significandHigh = significandHigh.multiply(Long.fromNumber(10));\n        significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n      }\n      significandLow = Long.fromNumber(digits[dIdx++]);\n      for (; dIdx <= lastDigit; dIdx++) {\n        significandLow = significandLow.multiply(Long.fromNumber(10));\n        significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n      }\n    }\n    const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\n    significand.low = significand.low.add(significandLow);\n    if (lessThan(significand.low, significandLow)) {\n      significand.high = significand.high.add(Long.fromNumber(1));\n    }\n    biasedExponent = exponent + EXPONENT_BIAS;\n    const dec = {\n      low: Long.fromNumber(0),\n      high: Long.fromNumber(0)\n    };\n    if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n      dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n      dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n      dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n    } else {\n      dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n      dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n    }\n    dec.low = significand.low;\n    if (isNegative) {\n      dec.high = dec.high.or(Long.fromString('9223372036854775808'));\n    }\n    const buffer = ByteUtils.allocate(16);\n    index = 0;\n    buffer[index++] = dec.low.low & 0xff;\n    buffer[index++] = dec.low.low >> 8 & 0xff;\n    buffer[index++] = dec.low.low >> 16 & 0xff;\n    buffer[index++] = dec.low.low >> 24 & 0xff;\n    buffer[index++] = dec.low.high & 0xff;\n    buffer[index++] = dec.low.high >> 8 & 0xff;\n    buffer[index++] = dec.low.high >> 16 & 0xff;\n    buffer[index++] = dec.low.high >> 24 & 0xff;\n    buffer[index++] = dec.high.low & 0xff;\n    buffer[index++] = dec.high.low >> 8 & 0xff;\n    buffer[index++] = dec.high.low >> 16 & 0xff;\n    buffer[index++] = dec.high.low >> 24 & 0xff;\n    buffer[index++] = dec.high.high & 0xff;\n    buffer[index++] = dec.high.high >> 8 & 0xff;\n    buffer[index++] = dec.high.high >> 16 & 0xff;\n    buffer[index++] = dec.high.high >> 24 & 0xff;\n    return new Decimal128(buffer);\n  }\n  toString() {\n    let biased_exponent;\n    let significand_digits = 0;\n    const significand = new Array(36);\n    for (let i = 0; i < significand.length; i++) significand[i] = 0;\n    let index = 0;\n    let is_zero = false;\n    let significand_msb;\n    let significand128 = {\n      parts: [0, 0, 0, 0]\n    };\n    let j, k;\n    const string = [];\n    index = 0;\n    const buffer = this.bytes;\n    const low = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    const midl = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    const midh = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    const high = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    index = 0;\n    const dec = {\n      low: new Long(low, midl),\n      high: new Long(midh, high)\n    };\n    if (dec.high.lessThan(Long.ZERO)) {\n      string.push('-');\n    }\n    const combination = high >> 26 & COMBINATION_MASK;\n    if (combination >> 3 === 3) {\n      if (combination === COMBINATION_INFINITY) {\n        return string.join('') + 'Infinity';\n      } else if (combination === COMBINATION_NAN) {\n        return 'NaN';\n      } else {\n        biased_exponent = high >> 15 & EXPONENT_MASK;\n        significand_msb = 0x08 + (high >> 14 & 0x01);\n      }\n    } else {\n      significand_msb = high >> 14 & 0x07;\n      biased_exponent = high >> 17 & EXPONENT_MASK;\n    }\n    const exponent = biased_exponent - EXPONENT_BIAS;\n    significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n    significand128.parts[1] = midh;\n    significand128.parts[2] = midl;\n    significand128.parts[3] = low;\n    if (significand128.parts[0] === 0 && significand128.parts[1] === 0 && significand128.parts[2] === 0 && significand128.parts[3] === 0) {\n      is_zero = true;\n    } else {\n      for (k = 3; k >= 0; k--) {\n        let least_digits = 0;\n        const result = divideu128(significand128);\n        significand128 = result.quotient;\n        least_digits = result.rem.low;\n        if (!least_digits) continue;\n        for (j = 8; j >= 0; j--) {\n          significand[k * 9 + j] = least_digits % 10;\n          least_digits = Math.floor(least_digits / 10);\n        }\n      }\n    }\n    if (is_zero) {\n      significand_digits = 1;\n      significand[index] = 0;\n    } else {\n      significand_digits = 36;\n      while (!significand[index]) {\n        significand_digits = significand_digits - 1;\n        index = index + 1;\n      }\n    }\n    const scientific_exponent = significand_digits - 1 + exponent;\n    if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n      if (significand_digits > 34) {\n        string.push(`${0}`);\n        if (exponent > 0) string.push(`E+${exponent}`);else if (exponent < 0) string.push(`E${exponent}`);\n        return string.join('');\n      }\n      string.push(`${significand[index++]}`);\n      significand_digits = significand_digits - 1;\n      if (significand_digits) {\n        string.push('.');\n      }\n      for (let i = 0; i < significand_digits; i++) {\n        string.push(`${significand[index++]}`);\n      }\n      string.push('E');\n      if (scientific_exponent > 0) {\n        string.push(`+${scientific_exponent}`);\n      } else {\n        string.push(`${scientific_exponent}`);\n      }\n    } else {\n      if (exponent >= 0) {\n        for (let i = 0; i < significand_digits; i++) {\n          string.push(`${significand[index++]}`);\n        }\n      } else {\n        let radix_position = significand_digits + exponent;\n        if (radix_position > 0) {\n          for (let i = 0; i < radix_position; i++) {\n            string.push(`${significand[index++]}`);\n          }\n        } else {\n          string.push('0');\n        }\n        string.push('.');\n        while (radix_position++ < 0) {\n          string.push('0');\n        }\n        for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n          string.push(`${significand[index++]}`);\n        }\n      }\n    }\n    return string.join('');\n  }\n  toJSON() {\n    return {\n      $numberDecimal: this.toString()\n    };\n  }\n  toExtendedJSON() {\n    return {\n      $numberDecimal: this.toString()\n    };\n  }\n  static fromExtendedJSON(doc) {\n    return Decimal128.fromString(doc.$numberDecimal);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new Decimal128(\"${this.toString()}\")`;\n  }\n}\nclass Double extends BSONValue {\n  get _bsontype() {\n    return 'Double';\n  }\n  constructor(value) {\n    super();\n    if (value instanceof Number) {\n      value = value.valueOf();\n    }\n    this.value = +value;\n  }\n  valueOf() {\n    return this.value;\n  }\n  toJSON() {\n    return this.value;\n  }\n  toString(radix) {\n    return this.value.toString(radix);\n  }\n  toExtendedJSON(options) {\n    if (options && (options.legacy || options.relaxed && isFinite(this.value))) {\n      return this.value;\n    }\n    if (Object.is(Math.sign(this.value), -0)) {\n      return {\n        $numberDouble: '-0.0'\n      };\n    }\n    return {\n      $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n    };\n  }\n  static fromExtendedJSON(doc, options) {\n    const doubleValue = parseFloat(doc.$numberDouble);\n    return options && options.relaxed ? doubleValue : new Double(doubleValue);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    const eJSON = this.toExtendedJSON();\n    return `new Double(${eJSON.$numberDouble})`;\n  }\n}\nclass Int32 extends BSONValue {\n  get _bsontype() {\n    return 'Int32';\n  }\n  constructor(value) {\n    super();\n    if (value instanceof Number) {\n      value = value.valueOf();\n    }\n    this.value = +value | 0;\n  }\n  valueOf() {\n    return this.value;\n  }\n  toString(radix) {\n    return this.value.toString(radix);\n  }\n  toJSON() {\n    return this.value;\n  }\n  toExtendedJSON(options) {\n    if (options && (options.relaxed || options.legacy)) return this.value;\n    return {\n      $numberInt: this.value.toString()\n    };\n  }\n  static fromExtendedJSON(doc, options) {\n    return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new Int32(${this.valueOf()})`;\n  }\n}\nclass MaxKey extends BSONValue {\n  get _bsontype() {\n    return 'MaxKey';\n  }\n  toExtendedJSON() {\n    return {\n      $maxKey: 1\n    };\n  }\n  static fromExtendedJSON() {\n    return new MaxKey();\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return 'new MaxKey()';\n  }\n}\nclass MinKey extends BSONValue {\n  get _bsontype() {\n    return 'MinKey';\n  }\n  toExtendedJSON() {\n    return {\n      $minKey: 1\n    };\n  }\n  static fromExtendedJSON() {\n    return new MinKey();\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return 'new MinKey()';\n  }\n}\nconst checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol('id');\nclass ObjectId extends BSONValue {\n  get _bsontype() {\n    return 'ObjectId';\n  }\n  constructor(inputId) {\n    super();\n    let workingId;\n    if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n      if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n        throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n      }\n      if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n        workingId = ByteUtils.fromHex(inputId.toHexString());\n      } else {\n        workingId = inputId.id;\n      }\n    } else {\n      workingId = inputId;\n    }\n    if (workingId == null || typeof workingId === 'number') {\n      this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n    } else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n      this[kId] = ByteUtils.toLocalBufferType(workingId);\n    } else if (typeof workingId === 'string') {\n      if (workingId.length === 12) {\n        const bytes = ByteUtils.fromUTF8(workingId);\n        if (bytes.byteLength === 12) {\n          this[kId] = bytes;\n        } else {\n          throw new BSONError('Argument passed in must be a string of 12 bytes');\n        }\n      } else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n        this[kId] = ByteUtils.fromHex(workingId);\n      } else {\n        throw new BSONError('Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer');\n      }\n    } else {\n      throw new BSONError('Argument passed in does not match the accepted types');\n    }\n    if (ObjectId.cacheHexString) {\n      this.__id = ByteUtils.toHex(this.id);\n    }\n  }\n  get id() {\n    return this[kId];\n  }\n  set id(value) {\n    this[kId] = value;\n    if (ObjectId.cacheHexString) {\n      this.__id = ByteUtils.toHex(value);\n    }\n  }\n  toHexString() {\n    if (ObjectId.cacheHexString && this.__id) {\n      return this.__id;\n    }\n    const hexString = ByteUtils.toHex(this.id);\n    if (ObjectId.cacheHexString && !this.__id) {\n      this.__id = hexString;\n    }\n    return hexString;\n  }\n  static getInc() {\n    return ObjectId.index = (ObjectId.index + 1) % 0xffffff;\n  }\n  static generate(time) {\n    if ('number' !== typeof time) {\n      time = Math.floor(Date.now() / 1000);\n    }\n    const inc = ObjectId.getInc();\n    const buffer = ByteUtils.allocate(12);\n    BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n    if (PROCESS_UNIQUE === null) {\n      PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n    }\n    buffer[4] = PROCESS_UNIQUE[0];\n    buffer[5] = PROCESS_UNIQUE[1];\n    buffer[6] = PROCESS_UNIQUE[2];\n    buffer[7] = PROCESS_UNIQUE[3];\n    buffer[8] = PROCESS_UNIQUE[4];\n    buffer[11] = inc & 0xff;\n    buffer[10] = inc >> 8 & 0xff;\n    buffer[9] = inc >> 16 & 0xff;\n    return buffer;\n  }\n  toString(encoding) {\n    if (encoding === 'base64') return ByteUtils.toBase64(this.id);\n    if (encoding === 'hex') return this.toHexString();\n    return this.toHexString();\n  }\n  toJSON() {\n    return this.toHexString();\n  }\n  equals(otherId) {\n    if (otherId === undefined || otherId === null) {\n      return false;\n    }\n    if (otherId instanceof ObjectId) {\n      return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12 && isUint8Array(this.id)) {\n      return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {\n      return otherId.toLowerCase() === this.toHexString();\n    }\n    if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {\n      return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);\n    }\n    if (typeof otherId === 'object' && 'toHexString' in otherId && typeof otherId.toHexString === 'function') {\n      const otherIdString = otherId.toHexString();\n      const thisIdString = this.toHexString().toLowerCase();\n      return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n    }\n    return false;\n  }\n  getTimestamp() {\n    const timestamp = new Date();\n    const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n    timestamp.setTime(Math.floor(time) * 1000);\n    return timestamp;\n  }\n  static createPk() {\n    return new ObjectId();\n  }\n  static createFromTime(time) {\n    const buffer = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n    BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n    return new ObjectId(buffer);\n  }\n  static createFromHexString(hexString) {\n    if (hexString?.length !== 24) {\n      throw new BSONError('hex string must be 24 characters');\n    }\n    return new ObjectId(ByteUtils.fromHex(hexString));\n  }\n  static createFromBase64(base64) {\n    if (base64?.length !== 16) {\n      throw new BSONError('base64 string must be 16 characters');\n    }\n    return new ObjectId(ByteUtils.fromBase64(base64));\n  }\n  static isValid(id) {\n    if (id == null) return false;\n    try {\n      new ObjectId(id);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  toExtendedJSON() {\n    if (this.toHexString) return {\n      $oid: this.toHexString()\n    };\n    return {\n      $oid: this.toString('hex')\n    };\n  }\n  static fromExtendedJSON(doc) {\n    return new ObjectId(doc.$oid);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new ObjectId(\"${this.toHexString()}\")`;\n  }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n  let totalLength = 4 + 1;\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; i++) {\n      totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n    }\n  } else {\n    if (typeof object?.toBSON === 'function') {\n      object = object.toBSON();\n    }\n    for (const key of Object.keys(object)) {\n      totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n    }\n  }\n  return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n  if (typeof value?.toBSON === 'function') {\n    value = value.toBSON();\n  }\n  switch (typeof value) {\n    case 'string':\n      return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n    case 'number':\n      if (Math.floor(value) === value && value >= JS_INT_MIN && value <= JS_INT_MAX) {\n        if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n        } else {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n        }\n      } else {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n      }\n    case 'undefined':\n      if (isArray || !ignoreUndefined) return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n      return 0;\n    case 'boolean':\n      return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n    case 'object':\n      if (value != null && typeof value._bsontype === 'string' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n      } else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n      } else if (value._bsontype === 'ObjectId') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n      } else if (value instanceof Date || isDate(value)) {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n      } else if (ArrayBuffer.isView(value) || value instanceof ArrayBuffer || isAnyArrayBuffer(value)) {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength;\n      } else if (value._bsontype === 'Long' || value._bsontype === 'Double' || value._bsontype === 'Timestamp') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n      } else if (value._bsontype === 'Decimal128') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n      } else if (value._bsontype === 'Code') {\n        if (value.scope != null && Object.keys(value.scope).length > 0) {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1 + internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined);\n        } else {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.code.toString()) + 1;\n        }\n      } else if (value._bsontype === 'Binary') {\n        const binary = value;\n        if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1 + 4);\n        } else {\n          return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1);\n        }\n      } else if (value._bsontype === 'Symbol') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + ByteUtils.utf8ByteLength(value.value) + 4 + 1 + 1;\n      } else if (value._bsontype === 'DBRef') {\n        const ordered_values = Object.assign({\n          $ref: value.collection,\n          $id: value.oid\n        }, value.fields);\n        if (value.db != null) {\n          ordered_values['$db'] = value.db;\n        }\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.source) + 1 + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1;\n      } else if (value._bsontype === 'BSONRegExp') {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + ByteUtils.utf8ByteLength(value.pattern) + 1 + ByteUtils.utf8ByteLength(value.options) + 1;\n      } else {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) + 1;\n      }\n    case 'function':\n      if (serializeFunctions) {\n        return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1 + 4 + ByteUtils.utf8ByteLength(value.toString()) + 1;\n      }\n  }\n  return 0;\n}\nfunction alphabetize(str) {\n  return str.split('').sort().join('');\n}\nclass BSONRegExp extends BSONValue {\n  get _bsontype() {\n    return 'BSONRegExp';\n  }\n  constructor(pattern, options) {\n    super();\n    this.pattern = pattern;\n    this.options = alphabetize(options ?? '');\n    if (this.pattern.indexOf('\\x00') !== -1) {\n      throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n    }\n    if (this.options.indexOf('\\x00') !== -1) {\n      throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n    }\n    for (let i = 0; i < this.options.length; i++) {\n      if (!(this.options[i] === 'i' || this.options[i] === 'm' || this.options[i] === 'x' || this.options[i] === 'l' || this.options[i] === 's' || this.options[i] === 'u')) {\n        throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n      }\n    }\n  }\n  static parseOptions(options) {\n    return options ? options.split('').sort().join('') : '';\n  }\n  toExtendedJSON(options) {\n    options = options || {};\n    if (options.legacy) {\n      return {\n        $regex: this.pattern,\n        $options: this.options\n      };\n    }\n    return {\n      $regularExpression: {\n        pattern: this.pattern,\n        options: this.options\n      }\n    };\n  }\n  static fromExtendedJSON(doc) {\n    if ('$regex' in doc) {\n      if (typeof doc.$regex !== 'string') {\n        if (doc.$regex._bsontype === 'BSONRegExp') {\n          return doc;\n        }\n      } else {\n        return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n      }\n    }\n    if ('$regularExpression' in doc) {\n      return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n    }\n    throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;\n  }\n}\nclass BSONSymbol extends BSONValue {\n  get _bsontype() {\n    return 'BSONSymbol';\n  }\n  constructor(value) {\n    super();\n    this.value = value;\n  }\n  valueOf() {\n    return this.value;\n  }\n  toString() {\n    return this.value;\n  }\n  inspect() {\n    return `new BSONSymbol(\"${this.value}\")`;\n  }\n  toJSON() {\n    return this.value;\n  }\n  toExtendedJSON() {\n    return {\n      $symbol: this.value\n    };\n  }\n  static fromExtendedJSON(doc) {\n    return new BSONSymbol(doc.$symbol);\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n}\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n  get _bsontype() {\n    return 'Timestamp';\n  }\n  constructor(low) {\n    if (low == null) {\n      super(0, 0, true);\n    } else if (typeof low === 'bigint') {\n      super(low, true);\n    } else if (Long.isLong(low)) {\n      super(low.low, low.high, true);\n    } else if (typeof low === 'object' && 't' in low && 'i' in low) {\n      if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');\n      }\n      if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');\n      }\n      if (low.t < 0) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');\n      }\n      if (low.i < 0) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');\n      }\n      if (low.t > 4294967295) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');\n      }\n      if (low.i > 4294967295) {\n        throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');\n      }\n      super(low.i.valueOf(), low.t.valueOf(), true);\n    } else {\n      throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');\n    }\n  }\n  toJSON() {\n    return {\n      $timestamp: this.toString()\n    };\n  }\n  static fromInt(value) {\n    return new Timestamp(Long.fromInt(value, true));\n  }\n  static fromNumber(value) {\n    return new Timestamp(Long.fromNumber(value, true));\n  }\n  static fromBits(lowBits, highBits) {\n    return new Timestamp({\n      i: lowBits,\n      t: highBits\n    });\n  }\n  static fromString(str, optRadix) {\n    return new Timestamp(Long.fromString(str, true, optRadix));\n  }\n  toExtendedJSON() {\n    return {\n      $timestamp: {\n        t: this.high >>> 0,\n        i: this.low >>> 0\n      }\n    };\n  }\n  static fromExtendedJSON(doc) {\n    const i = Long.isLong(doc.$timestamp.i) ? doc.$timestamp.i.getLowBitsUnsigned() : doc.$timestamp.i;\n    const t = Long.isLong(doc.$timestamp.t) ? doc.$timestamp.t.getLowBitsUnsigned() : doc.$timestamp.t;\n    return new Timestamp({\n      t,\n      i\n    });\n  }\n  [Symbol.for('nodejs.util.inspect.custom')]() {\n    return this.inspect();\n  }\n  inspect() {\n    return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;\n  }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n  let continuation = 0;\n  for (let i = start; i < end; i += 1) {\n    const byte = bytes[i];\n    if (continuation) {\n      if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n        return false;\n      }\n      continuation -= 1;\n    } else if (byte & FIRST_BIT) {\n      if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n        continuation = 1;\n      } else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n        continuation = 2;\n      } else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n        continuation = 3;\n      } else {\n        return false;\n      }\n    }\n  }\n  return !continuation;\n}\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n  options = options == null ? {} : options;\n  const index = options && options.index ? options.index : 0;\n  const size = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n  if (size < 5) {\n    throw new BSONError(`bson size must be >= 5, is ${size}`);\n  }\n  if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n    throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n  }\n  if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n    throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n  }\n  if (size + index > buffer.byteLength) {\n    throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n  }\n  if (buffer[index + size - 1] !== 0) {\n    throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n  }\n  return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n  const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n  const raw = options['raw'] == null ? false : options['raw'];\n  const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n  const promoteBuffers = options.promoteBuffers ?? false;\n  const promoteLongs = options.promoteLongs ?? true;\n  const promoteValues = options.promoteValues ?? true;\n  const useBigInt64 = options.useBigInt64 ?? false;\n  if (useBigInt64 && !promoteValues) {\n    throw new BSONError('Must either request bigint or Long for int64 deserialization');\n  }\n  if (useBigInt64 && !promoteLongs) {\n    throw new BSONError('Must either request bigint or Long for int64 deserialization');\n  }\n  const validation = options.validation == null ? {\n    utf8: true\n  } : options.validation;\n  let globalUTFValidation = true;\n  let validationSetting;\n  const utf8KeysSet = new Set();\n  const utf8ValidatedKeys = validation.utf8;\n  if (typeof utf8ValidatedKeys === 'boolean') {\n    validationSetting = utf8ValidatedKeys;\n  } else {\n    globalUTFValidation = false;\n    const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n      return utf8ValidatedKeys[key];\n    });\n    if (utf8ValidationValues.length === 0) {\n      throw new BSONError('UTF-8 validation setting cannot be empty');\n    }\n    if (typeof utf8ValidationValues[0] !== 'boolean') {\n      throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n    }\n    validationSetting = utf8ValidationValues[0];\n    if (!utf8ValidationValues.every(item => item === validationSetting)) {\n      throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n    }\n  }\n  if (!globalUTFValidation) {\n    for (const key of Object.keys(utf8ValidatedKeys)) {\n      utf8KeysSet.add(key);\n    }\n  }\n  const startIndex = index;\n  if (buffer.length < 5) throw new BSONError('corrupt bson message < 5 bytes long');\n  const size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n  if (size < 5 || size > buffer.length) throw new BSONError('corrupt bson message');\n  const object = isArray ? [] : {};\n  let arrayIndex = 0;\n  const done = false;\n  let isPossibleDBRef = isArray ? false : null;\n  const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  while (!done) {\n    const elementType = buffer[index++];\n    if (elementType === 0) break;\n    let i = index;\n    while (buffer[i] !== 0x00 && i < buffer.length) {\n      i++;\n    }\n    if (i >= buffer.byteLength) throw new BSONError('Bad BSON Document: illegal CString');\n    const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer.subarray(index, i));\n    let shouldValidateKey = true;\n    if (globalUTFValidation || utf8KeysSet.has(name)) {\n      shouldValidateKey = validationSetting;\n    } else {\n      shouldValidateKey = !validationSetting;\n    }\n    if (isPossibleDBRef !== false && name[0] === '$') {\n      isPossibleDBRef = allowedDBRefKeys.test(name);\n    }\n    let value;\n    index = i + 1;\n    if (elementType === BSON_DATA_STRING) {\n      const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new BSONError('bad string length in bson');\n      }\n      value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_OID) {\n      const oid = ByteUtils.allocate(12);\n      oid.set(buffer.subarray(index, index + 12));\n      value = new ObjectId(oid);\n      index = index + 12;\n    } else if (elementType === BSON_DATA_INT && promoteValues === false) {\n      value = new Int32(buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24);\n    } else if (elementType === BSON_DATA_INT) {\n      value = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n    } else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n      value = new Double(dataview.getFloat64(index, true));\n      index = index + 8;\n    } else if (elementType === BSON_DATA_NUMBER) {\n      value = dataview.getFloat64(index, true);\n      index = index + 8;\n    } else if (elementType === BSON_DATA_DATE) {\n      const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      value = new Date(new Long(lowBits, highBits).toNumber());\n    } else if (elementType === BSON_DATA_BOOLEAN) {\n      if (buffer[index] !== 0 && buffer[index] !== 1) throw new BSONError('illegal boolean type value');\n      value = buffer[index++] === 1;\n    } else if (elementType === BSON_DATA_OBJECT) {\n      const _index = index;\n      const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      if (objectSize <= 0 || objectSize > buffer.length - index) throw new BSONError('bad embedded document length in bson');\n      if (raw) {\n        value = buffer.slice(index, index + objectSize);\n      } else {\n        let objectOptions = options;\n        if (!globalUTFValidation) {\n          objectOptions = {\n            ...options,\n            validation: {\n              utf8: shouldValidateKey\n            }\n          };\n        }\n        value = deserializeObject(buffer, _index, objectOptions, false);\n      }\n      index = index + objectSize;\n    } else if (elementType === BSON_DATA_ARRAY) {\n      const _index = index;\n      const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      let arrayOptions = options;\n      const stopIndex = index + objectSize;\n      if (fieldsAsRaw && fieldsAsRaw[name]) {\n        arrayOptions = {\n          ...options,\n          raw: true\n        };\n      }\n      if (!globalUTFValidation) {\n        arrayOptions = {\n          ...arrayOptions,\n          validation: {\n            utf8: shouldValidateKey\n          }\n        };\n      }\n      value = deserializeObject(buffer, _index, arrayOptions, true);\n      index = index + objectSize;\n      if (buffer[index - 1] !== 0) throw new BSONError('invalid array terminator byte');\n      if (index !== stopIndex) throw new BSONError('corrupted array bson');\n    } else if (elementType === BSON_DATA_UNDEFINED) {\n      value = undefined;\n    } else if (elementType === BSON_DATA_NULL) {\n      value = null;\n    } else if (elementType === BSON_DATA_LONG) {\n      const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n      const lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      const highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      const long = new Long(lowBits, highBits);\n      if (useBigInt64) {\n        value = dataview.getBigInt64(0, true);\n      } else if (promoteLongs && promoteValues === true) {\n        value = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;\n      } else {\n        value = long;\n      }\n    } else if (elementType === BSON_DATA_DECIMAL128) {\n      const bytes = ByteUtils.allocate(16);\n      bytes.set(buffer.subarray(index, index + 16), 0);\n      index = index + 16;\n      value = new Decimal128(bytes);\n    } else if (elementType === BSON_DATA_BINARY) {\n      let binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      const totalBinarySize = binarySize;\n      const subType = buffer[index++];\n      if (binarySize < 0) throw new BSONError('Negative binary type element size found');\n      if (binarySize > buffer.byteLength) throw new BSONError('Binary type size larger than document size');\n      if (buffer['slice'] != null) {\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n        }\n        if (promoteBuffers && promoteValues) {\n          value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n        } else {\n          value = new Binary(buffer.slice(index, index + binarySize), subType);\n          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n            value = value.toUUID();\n          }\n        }\n      } else {\n        const _buffer = ByteUtils.allocate(binarySize);\n        if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n          binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n          if (binarySize < 0) throw new BSONError('Negative binary type element size found for subtype 0x02');\n          if (binarySize > totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n          if (binarySize < totalBinarySize - 4) throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n        }\n        for (i = 0; i < binarySize; i++) {\n          _buffer[i] = buffer[index + i];\n        }\n        if (promoteBuffers && promoteValues) {\n          value = _buffer;\n        } else {\n          value = new Binary(buffer.slice(index, index + binarySize), subType);\n          if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n            value = value.toUUID();\n          }\n        }\n      }\n      index = index + binarySize;\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n      i = index;\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      const source = ByteUtils.toUTF8(buffer.subarray(index, i));\n      index = i + 1;\n      i = index;\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      const regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));\n      index = i + 1;\n      const optionsArray = new Array(regExpOptions.length);\n      for (i = 0; i < regExpOptions.length; i++) {\n        switch (regExpOptions[i]) {\n          case 'm':\n            optionsArray[i] = 'm';\n            break;\n          case 's':\n            optionsArray[i] = 'g';\n            break;\n          case 'i':\n            optionsArray[i] = 'i';\n            break;\n        }\n      }\n      value = new RegExp(source, optionsArray.join(''));\n    } else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n      i = index;\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      const source = ByteUtils.toUTF8(buffer.subarray(index, i));\n      index = i + 1;\n      i = index;\n      while (buffer[i] !== 0x00 && i < buffer.length) {\n        i++;\n      }\n      if (i >= buffer.length) throw new BSONError('Bad BSON Document: illegal CString');\n      const regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));\n      index = i + 1;\n      value = new BSONRegExp(source, regExpOptions);\n    } else if (elementType === BSON_DATA_SYMBOL) {\n      const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new BSONError('bad string length in bson');\n      }\n      const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      value = promoteValues ? symbol : new BSONSymbol(symbol);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_TIMESTAMP) {\n      const i = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n      const t = buffer[index++] + buffer[index++] * (1 << 8) + buffer[index++] * (1 << 16) + buffer[index++] * (1 << 24);\n      value = new Timestamp({\n        i,\n        t\n      });\n    } else if (elementType === BSON_DATA_MIN_KEY) {\n      value = new MinKey();\n    } else if (elementType === BSON_DATA_MAX_KEY) {\n      value = new MaxKey();\n    } else if (elementType === BSON_DATA_CODE) {\n      const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new BSONError('bad string length in bson');\n      }\n      const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      value = new Code(functionString);\n      index = index + stringSize;\n    } else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n      const totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (totalSize < 4 + 4 + 4 + 1) {\n        throw new BSONError('code_w_scope total size shorter minimum expected length');\n      }\n      const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) {\n        throw new BSONError('bad string length in bson');\n      }\n      const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n      index = index + stringSize;\n      const _index = index;\n      const objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;\n      const scopeObject = deserializeObject(buffer, _index, options, false);\n      index = index + objectSize;\n      if (totalSize < 4 + 4 + objectSize + stringSize) {\n        throw new BSONError('code_w_scope total size is too short, truncating scope');\n      }\n      if (totalSize > 4 + 4 + objectSize + stringSize) {\n        throw new BSONError('code_w_scope total size is too long, clips outer document');\n      }\n      value = new Code(functionString, scopeObject);\n    } else if (elementType === BSON_DATA_DBPOINTER) {\n      const stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;\n      if (stringSize <= 0 || stringSize > buffer.length - index || buffer[index + stringSize - 1] !== 0) throw new BSONError('bad string length in bson');\n      if (validation != null && validation.utf8) {\n        if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n          throw new BSONError('Invalid UTF-8 string in BSON document');\n        }\n      }\n      const namespace = ByteUtils.toUTF8(buffer.subarray(index, index + stringSize - 1));\n      index = index + stringSize;\n      const oidBuffer = ByteUtils.allocate(12);\n      oidBuffer.set(buffer.subarray(index, index + 12), 0);\n      const oid = new ObjectId(oidBuffer);\n      index = index + 12;\n      value = new DBRef(namespace, oid);\n    } else {\n      throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n    }\n    if (name === '__proto__') {\n      Object.defineProperty(object, name, {\n        value,\n        writable: true,\n        enumerable: true,\n        configurable: true\n      });\n    } else {\n      object[name] = value;\n    }\n  }\n  if (size !== index - startIndex) {\n    if (isArray) throw new BSONError('corrupt array bson');\n    throw new BSONError('corrupt object bson');\n  }\n  if (!isPossibleDBRef) return object;\n  if (isDBRefLike(object)) {\n    const copy = Object.assign({}, object);\n    delete copy.$ref;\n    delete copy.$id;\n    delete copy.$db;\n    return new DBRef(object.$ref, object.$id, object.$db, copy);\n  }\n  return object;\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n  const value = ByteUtils.toUTF8(buffer.subarray(start, end));\n  if (shouldValidateUtf8) {\n    for (let i = 0; i < value.length; i++) {\n      if (value.charCodeAt(i) === 0xfffd) {\n        if (!validateUtf8(buffer, start, end)) {\n          throw new BSONError('Invalid UTF-8 string in BSON document');\n        }\n        break;\n      }\n    }\n  }\n  return value;\n}\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\nfunction serializeString(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_STRING;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes + 1;\n  buffer[index - 1] = 0;\n  const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n  buffer[index + 3] = size + 1 >> 24 & 0xff;\n  buffer[index + 2] = size + 1 >> 16 & 0xff;\n  buffer[index + 1] = size + 1 >> 8 & 0xff;\n  buffer[index] = size + 1 & 0xff;\n  index = index + 4 + size;\n  buffer[index++] = 0;\n  return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n  const isNegativeZero = Object.is(value, -0);\n  const type = !isNegativeZero && Number.isSafeInteger(value) && value <= BSON_INT32_MAX && value >= BSON_INT32_MIN ? BSON_DATA_INT : BSON_DATA_NUMBER;\n  if (type === BSON_DATA_INT) {\n    NUMBER_SPACE.setInt32(0, value, true);\n  } else {\n    NUMBER_SPACE.setFloat64(0, value, true);\n  }\n  const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n  buffer[index++] = type;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0x00;\n  buffer.set(bytes, index);\n  index += bytes.byteLength;\n  return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_LONG;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index += numberOfWrittenBytes;\n  buffer[index++] = 0;\n  NUMBER_SPACE.setBigInt64(0, value, true);\n  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n  index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n  return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n  buffer[index++] = BSON_DATA_NULL;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_BOOLEAN;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  buffer[index++] = value ? 1 : 0;\n  return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_DATE;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const dateInMilis = Long.fromNumber(value.getTime());\n  const lowBits = dateInMilis.getLowBits();\n  const highBits = dateInMilis.getHighBits();\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_REGEXP;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.source && value.source.match(regexp) != null) {\n    throw new BSONError('value ' + value.source + ' must not contain null bytes');\n  }\n  index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n  buffer[index++] = 0x00;\n  if (value.ignoreCase) buffer[index++] = 0x69;\n  if (value.global) buffer[index++] = 0x73;\n  if (value.multiline) buffer[index++] = 0x6d;\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_REGEXP;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (value.pattern.match(regexp) != null) {\n    throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n  }\n  index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n  buffer[index++] = 0x00;\n  const sortedOptions = value.options.split('').sort().join('');\n  index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n  if (value === null) {\n    buffer[index++] = BSON_DATA_NULL;\n  } else if (value._bsontype === 'MinKey') {\n    buffer[index++] = BSON_DATA_MIN_KEY;\n  } else {\n    buffer[index++] = BSON_DATA_MAX_KEY;\n  }\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_OID;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  if (isUint8Array(value.id)) {\n    buffer.set(value.id.subarray(0, 12), index);\n  } else {\n    throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n  }\n  return index + 12;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_BINARY;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const size = value.length;\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n  buffer.set(value, index);\n  index = index + size;\n  return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n  if (path.has(value)) {\n    throw new BSONError('Cannot convert circular structure to BSON');\n  }\n  path.add(value);\n  buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n  path.delete(value);\n  return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_DECIMAL128;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  buffer.set(value.bytes.subarray(0, 16), index);\n  return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n  buffer[index++] = value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const lowBits = value.getLowBits();\n  const highBits = value.getHighBits();\n  buffer[index++] = lowBits & 0xff;\n  buffer[index++] = lowBits >> 8 & 0xff;\n  buffer[index++] = lowBits >> 16 & 0xff;\n  buffer[index++] = lowBits >> 24 & 0xff;\n  buffer[index++] = highBits & 0xff;\n  buffer[index++] = highBits >> 8 & 0xff;\n  buffer[index++] = highBits >> 16 & 0xff;\n  buffer[index++] = highBits >> 24 & 0xff;\n  return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n  value = value.valueOf();\n  buffer[index++] = BSON_DATA_INT;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  buffer[index++] = value & 0xff;\n  buffer[index++] = value >> 8 & 0xff;\n  buffer[index++] = value >> 16 & 0xff;\n  buffer[index++] = value >> 24 & 0xff;\n  return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_NUMBER;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  NUMBER_SPACE.setFloat64(0, value.value, true);\n  buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n  index = index + 8;\n  return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_CODE;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const functionString = value.toString();\n  const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  index = index + 4 + size - 1;\n  buffer[index++] = 0;\n  return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n  if (value.scope && typeof value.scope === 'object') {\n    buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    const functionString = value.code;\n    index = index + 4;\n    const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = codeSize & 0xff;\n    buffer[index + 1] = codeSize >> 8 & 0xff;\n    buffer[index + 2] = codeSize >> 16 & 0xff;\n    buffer[index + 3] = codeSize >> 24 & 0xff;\n    buffer[index + 4 + codeSize - 1] = 0;\n    index = index + codeSize + 4;\n    const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    index = endIndex - 1;\n    const totalSize = endIndex - startIndex;\n    buffer[startIndex++] = totalSize & 0xff;\n    buffer[startIndex++] = totalSize >> 8 & 0xff;\n    buffer[startIndex++] = totalSize >> 16 & 0xff;\n    buffer[startIndex++] = totalSize >> 24 & 0xff;\n    buffer[index++] = 0;\n  } else {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.code.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = size >> 8 & 0xff;\n    buffer[index + 2] = size >> 16 & 0xff;\n    buffer[index + 3] = size >> 24 & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n  }\n  return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_BINARY;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const data = value.buffer;\n  let size = value.position;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) size = size + 4;\n  buffer[index++] = size & 0xff;\n  buffer[index++] = size >> 8 & 0xff;\n  buffer[index++] = size >> 16 & 0xff;\n  buffer[index++] = size >> 24 & 0xff;\n  buffer[index++] = value.sub_type;\n  if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n    size = size - 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = size >> 8 & 0xff;\n    buffer[index++] = size >> 16 & 0xff;\n    buffer[index++] = size >> 24 & 0xff;\n  }\n  buffer.set(data, index);\n  index = index + value.position;\n  return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n  buffer[index++] = BSON_DATA_SYMBOL;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n  buffer[index] = size & 0xff;\n  buffer[index + 1] = size >> 8 & 0xff;\n  buffer[index + 2] = size >> 16 & 0xff;\n  buffer[index + 3] = size >> 24 & 0xff;\n  index = index + 4 + size - 1;\n  buffer[index++] = 0x00;\n  return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n  buffer[index++] = BSON_DATA_OBJECT;\n  const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n  index = index + numberOfWrittenBytes;\n  buffer[index++] = 0;\n  let startIndex = index;\n  let output = {\n    $ref: value.collection || value.namespace,\n    $id: value.oid\n  };\n  if (value.db != null) {\n    output.$db = value.db;\n  }\n  output = Object.assign(output, value.fields);\n  const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n  const size = endIndex - startIndex;\n  buffer[startIndex++] = size & 0xff;\n  buffer[startIndex++] = size >> 8 & 0xff;\n  buffer[startIndex++] = size >> 16 & 0xff;\n  buffer[startIndex++] = size >> 24 & 0xff;\n  return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n  if (path == null) {\n    if (object == null) {\n      buffer[0] = 0x05;\n      buffer[1] = 0x00;\n      buffer[2] = 0x00;\n      buffer[3] = 0x00;\n      buffer[4] = 0x00;\n      return 5;\n    }\n    if (Array.isArray(object)) {\n      throw new BSONError('serialize does not support an array as the root input');\n    }\n    if (typeof object !== 'object') {\n      throw new BSONError('serialize does not support non-object as the root input');\n    } else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n      throw new BSONError(`BSON types cannot be serialized as a document`);\n    } else if (isDate(object) || isRegExp(object) || isUint8Array(object) || isAnyArrayBuffer(object)) {\n      throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n    }\n    path = new Set();\n  }\n  path.add(object);\n  let index = startingIndex + 4;\n  if (Array.isArray(object)) {\n    for (let i = 0; i < object.length; i++) {\n      const key = `${i}`;\n      let value = object[i];\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n      if (typeof value === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (typeof value === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (typeof value === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (typeof value === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (typeof value === 'object' && value._bsontype == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n      } else if (value._bsontype === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (value._bsontype === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value._bsontype === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      } else if (value._bsontype === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (value._bsontype === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value._bsontype === 'BSONSymbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value._bsontype === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n      } else if (value._bsontype === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value._bsontype === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value._bsontype !== 'undefined') {\n        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n      }\n    }\n  } else if (object instanceof Map || isMap(object)) {\n    const iterator = object.entries();\n    let done = false;\n    while (!done) {\n      const entry = iterator.next();\n      done = !!entry.done;\n      if (done) continue;\n      const key = entry.value[0];\n      let value = entry.value[1];\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n      const type = typeof value;\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw new BSONError('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw new BSONError('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw new BSONError('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === null || value === undefined && ignoreUndefined === false) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n      } else if (value._bsontype === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value._bsontype === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value._bsontype === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      } else if (value._bsontype === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value._bsontype === 'BSONSymbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value._bsontype === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n      } else if (value._bsontype === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value._bsontype === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value._bsontype !== 'undefined') {\n        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n      }\n    }\n  } else {\n    if (typeof object?.toBSON === 'function') {\n      object = object.toBSON();\n      if (object != null && typeof object !== 'object') {\n        throw new BSONError('toBSON function did not return an object');\n      }\n    }\n    for (const key of Object.keys(object)) {\n      let value = object[key];\n      if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n      }\n      const type = typeof value;\n      if (typeof key === 'string' && !ignoreKeys.has(key)) {\n        if (key.match(regexp) != null) {\n          throw new BSONError('key ' + key + ' must not contain null bytes');\n        }\n        if (checkKeys) {\n          if ('$' === key[0]) {\n            throw new BSONError('key ' + key + \" must not start with '$'\");\n          } else if (~key.indexOf('.')) {\n            throw new BSONError('key ' + key + \" must not contain '.'\");\n          }\n        }\n      }\n      if (type === 'string') {\n        index = serializeString(buffer, key, value, index);\n      } else if (type === 'number') {\n        index = serializeNumber(buffer, key, value, index);\n      } else if (type === 'bigint') {\n        index = serializeBigInt(buffer, key, value, index);\n      } else if (type === 'boolean') {\n        index = serializeBoolean(buffer, key, value, index);\n      } else if (value instanceof Date || isDate(value)) {\n        index = serializeDate(buffer, key, value, index);\n      } else if (value === undefined) {\n        if (ignoreUndefined === false) index = serializeNull(buffer, key, value, index);\n      } else if (value === null) {\n        index = serializeNull(buffer, key, value, index);\n      } else if (isUint8Array(value)) {\n        index = serializeBuffer(buffer, key, value, index);\n      } else if (value instanceof RegExp || isRegExp(value)) {\n        index = serializeRegExp(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype == null) {\n        index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (typeof value === 'object' && value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n      } else if (value._bsontype === 'ObjectId') {\n        index = serializeObjectId(buffer, key, value, index);\n      } else if (type === 'object' && value._bsontype === 'Decimal128') {\n        index = serializeDecimal128(buffer, key, value, index);\n      } else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n        index = serializeLong(buffer, key, value, index);\n      } else if (value._bsontype === 'Double') {\n        index = serializeDouble(buffer, key, value, index);\n      } else if (value._bsontype === 'Code') {\n        index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n      } else if (typeof value === 'function' && serializeFunctions) {\n        index = serializeFunction(buffer, key, value, index);\n      } else if (value._bsontype === 'Binary') {\n        index = serializeBinary(buffer, key, value, index);\n      } else if (value._bsontype === 'BSONSymbol') {\n        index = serializeSymbol(buffer, key, value, index);\n      } else if (value._bsontype === 'DBRef') {\n        index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n      } else if (value._bsontype === 'BSONRegExp') {\n        index = serializeBSONRegExp(buffer, key, value, index);\n      } else if (value._bsontype === 'Int32') {\n        index = serializeInt32(buffer, key, value, index);\n      } else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n        index = serializeMinMax(buffer, key, value, index);\n      } else if (typeof value._bsontype !== 'undefined') {\n        throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n      }\n    }\n  }\n  path.delete(object);\n  buffer[index++] = 0x00;\n  const size = index - startingIndex;\n  buffer[startingIndex++] = size & 0xff;\n  buffer[startingIndex++] = size >> 8 & 0xff;\n  buffer[startingIndex++] = size >> 16 & 0xff;\n  buffer[startingIndex++] = size >> 24 & 0xff;\n  return index;\n}\nfunction isBSONType(value) {\n  return value != null && typeof value === 'object' && '_bsontype' in value && typeof value._bsontype === 'string';\n}\nconst keysToCodecs = {\n  $oid: ObjectId,\n  $binary: Binary,\n  $uuid: Binary,\n  $symbol: BSONSymbol,\n  $numberInt: Int32,\n  $numberDecimal: Decimal128,\n  $numberDouble: Double,\n  $numberLong: Long,\n  $minKey: MinKey,\n  $maxKey: MaxKey,\n  $regex: BSONRegExp,\n  $regularExpression: BSONRegExp,\n  $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n  if (typeof value === 'number') {\n    const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n    const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n    if (options.relaxed || options.legacy) {\n      return value;\n    }\n    if (Number.isInteger(value) && !Object.is(value, -0)) {\n      if (in32BitRange) {\n        return new Int32(value);\n      }\n      if (in64BitRange) {\n        if (options.useBigInt64) {\n          return BigInt(value);\n        }\n        return Long.fromNumber(value);\n      }\n    }\n    return new Double(value);\n  }\n  if (value == null || typeof value !== 'object') return value;\n  if (value.$undefined) return null;\n  const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);\n  for (let i = 0; i < keys.length; i++) {\n    const c = keysToCodecs[keys[i]];\n    if (c) return c.fromExtendedJSON(value, options);\n  }\n  if (value.$date != null) {\n    const d = value.$date;\n    const date = new Date();\n    if (options.legacy) {\n      if (typeof d === 'number') date.setTime(d);else if (typeof d === 'string') date.setTime(Date.parse(d));else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n    } else {\n      if (typeof d === 'string') date.setTime(Date.parse(d));else if (Long.isLong(d)) date.setTime(d.toNumber());else if (typeof d === 'number' && options.relaxed) date.setTime(d);else if (typeof d === 'bigint') date.setTime(Number(d));else throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n    }\n    return date;\n  }\n  if (value.$code != null) {\n    const copy = Object.assign({}, value);\n    if (value.$scope) {\n      copy.$scope = deserializeValue(value.$scope);\n    }\n    return Code.fromExtendedJSON(value);\n  }\n  if (isDBRefLike(value) || value.$dbPointer) {\n    const v = value.$ref ? value : value.$dbPointer;\n    if (v instanceof DBRef) return v;\n    const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\n    let valid = true;\n    dollarKeys.forEach(k => {\n      if (['$ref', '$id', '$db'].indexOf(k) === -1) valid = false;\n    });\n    if (valid) return DBRef.fromExtendedJSON(v);\n  }\n  return value;\n}\nfunction serializeArray(array, options) {\n  return array.map((v, index) => {\n    options.seenObjects.push({\n      propertyName: `index ${index}`,\n      obj: null\n    });\n    try {\n      return serializeValue(v, options);\n    } finally {\n      options.seenObjects.pop();\n    }\n  });\n}\nfunction getISOString(date) {\n  const isoStr = date.toISOString();\n  return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\nfunction serializeValue(value, options) {\n  if (value instanceof Map || isMap(value)) {\n    const obj = Object.create(null);\n    for (const [k, v] of value) {\n      if (typeof k !== 'string') {\n        throw new BSONError('Can only serialize maps with string keys');\n      }\n      obj[k] = v;\n    }\n    return serializeValue(obj, options);\n  }\n  if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n    const index = options.seenObjects.findIndex(entry => entry.obj === value);\n    if (index !== -1) {\n      const props = options.seenObjects.map(entry => entry.propertyName);\n      const leadingPart = props.slice(0, index).map(prop => `${prop} -> `).join('');\n      const alreadySeen = props[index];\n      const circularPart = ' -> ' + props.slice(index + 1, props.length - 1).map(prop => `${prop} -> `).join('');\n      const current = props[props.length - 1];\n      const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n      const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n      throw new BSONError('Converting circular structure to EJSON:\\n' + `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` + `    ${leadingSpace}\\\\${dashes}/`);\n    }\n    options.seenObjects[options.seenObjects.length - 1].obj = value;\n  }\n  if (Array.isArray(value)) return serializeArray(value, options);\n  if (value === undefined) return null;\n  if (value instanceof Date || isDate(value)) {\n    const dateNum = value.getTime(),\n      inRange = dateNum > -1 && dateNum < 253402318800000;\n    if (options.legacy) {\n      return options.relaxed && inRange ? {\n        $date: value.getTime()\n      } : {\n        $date: getISOString(value)\n      };\n    }\n    return options.relaxed && inRange ? {\n      $date: getISOString(value)\n    } : {\n      $date: {\n        $numberLong: value.getTime().toString()\n      }\n    };\n  }\n  if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n    if (Number.isInteger(value) && !Object.is(value, -0)) {\n      if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n        return {\n          $numberInt: value.toString()\n        };\n      }\n      if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n        return {\n          $numberLong: value.toString()\n        };\n      }\n    }\n    return {\n      $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString()\n    };\n  }\n  if (typeof value === 'bigint') {\n    if (!options.relaxed) {\n      return {\n        $numberLong: BigInt.asIntN(64, value).toString()\n      };\n    }\n    return Number(BigInt.asIntN(64, value));\n  }\n  if (value instanceof RegExp || isRegExp(value)) {\n    let flags = value.flags;\n    if (flags === undefined) {\n      const match = value.toString().match(/[gimuy]*$/);\n      if (match) {\n        flags = match[0];\n      }\n    }\n    const rx = new BSONRegExp(value.source, flags);\n    return rx.toExtendedJSON(options);\n  }\n  if (value != null && typeof value === 'object') return serializeDocument(value, options);\n  return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n  Binary: o => new Binary(o.value(), o.sub_type),\n  Code: o => new Code(o.code, o.scope),\n  DBRef: o => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n  Decimal128: o => new Decimal128(o.bytes),\n  Double: o => new Double(o.value),\n  Int32: o => new Int32(o.value),\n  Long: o => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n  MaxKey: () => new MaxKey(),\n  MinKey: () => new MinKey(),\n  ObjectId: o => new ObjectId(o),\n  BSONRegExp: o => new BSONRegExp(o.pattern, o.options),\n  BSONSymbol: o => new BSONSymbol(o.value),\n  Timestamp: o => Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n  if (doc == null || typeof doc !== 'object') throw new BSONError('not an object instance');\n  const bsontype = doc._bsontype;\n  if (typeof bsontype === 'undefined') {\n    const _doc = {};\n    for (const name of Object.keys(doc)) {\n      options.seenObjects.push({\n        propertyName: name,\n        obj: null\n      });\n      try {\n        const value = serializeValue(doc[name], options);\n        if (name === '__proto__') {\n          Object.defineProperty(_doc, name, {\n            value,\n            writable: true,\n            enumerable: true,\n            configurable: true\n          });\n        } else {\n          _doc[name] = value;\n        }\n      } finally {\n        options.seenObjects.pop();\n      }\n    }\n    return _doc;\n  } else if (doc != null && typeof doc === 'object' && typeof doc._bsontype === 'string' && doc[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n    throw new BSONVersionError();\n  } else if (isBSONType(doc)) {\n    let outDoc = doc;\n    if (typeof outDoc.toExtendedJSON !== 'function') {\n      const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n      if (!mapper) {\n        throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n      }\n      outDoc = mapper(outDoc);\n    }\n    if (bsontype === 'Code' && outDoc.scope) {\n      outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n    } else if (bsontype === 'DBRef' && outDoc.oid) {\n      outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n    }\n    return outDoc.toExtendedJSON(options);\n  } else {\n    throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n  }\n}\nfunction parse(text, options) {\n  const ejsonOptions = {\n    useBigInt64: options?.useBigInt64 ?? false,\n    relaxed: options?.relaxed ?? true,\n    legacy: options?.legacy ?? false\n  };\n  return JSON.parse(text, (key, value) => {\n    if (key.indexOf('\\x00') !== -1) {\n      throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n    }\n    return deserializeValue(value, ejsonOptions);\n  });\n}\nfunction stringify(value, replacer, space, options) {\n  if (space != null && typeof space === 'object') {\n    options = space;\n    space = 0;\n  }\n  if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n    options = replacer;\n    replacer = undefined;\n    space = 0;\n  }\n  const serializeOptions = Object.assign({\n    relaxed: true,\n    legacy: false\n  }, options, {\n    seenObjects: [{\n      propertyName: '(root)',\n      obj: null\n    }]\n  });\n  const doc = serializeValue(value, serializeOptions);\n  return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n  options = options || {};\n  return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n  options = options || {};\n  return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n  if (buffer.length < size) {\n    buffer = ByteUtils.allocate(size);\n  }\n}\nfunction serialize(object, options = {}) {\n  const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n  const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;\n  if (buffer.length < minInternalBufferSize) {\n    buffer = ByteUtils.allocate(minInternalBufferSize);\n  }\n  const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n  const finishedBuffer = ByteUtils.allocate(serializationIndex);\n  finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n  return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n  const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n  const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  const startIndex = typeof options.index === 'number' ? options.index : 0;\n  const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n  finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n  return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n  return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n  options = options || {};\n  const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n  const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n  return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n  const internalOptions = Object.assign({\n    allowObjectSmallerThanBufferSize: true,\n    index: 0\n  }, options);\n  const bufferData = ByteUtils.toLocalBufferType(data);\n  let index = startIndex;\n  for (let i = 0; i < numberOfDocuments; i++) {\n    const size = bufferData[index] | bufferData[index + 1] << 8 | bufferData[index + 2] << 16 | bufferData[index + 3] << 24;\n    internalOptions.index = index;\n    documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n    index = index + size;\n  }\n  return index;\n}\nvar bson = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  BSONError: BSONError,\n  BSONRegExp: BSONRegExp,\n  BSONRuntimeError: BSONRuntimeError,\n  BSONSymbol: BSONSymbol,\n  BSONType: BSONType,\n  BSONValue: BSONValue,\n  BSONVersionError: BSONVersionError,\n  Binary: Binary,\n  Code: Code,\n  DBRef: DBRef,\n  Decimal128: Decimal128,\n  Double: Double,\n  EJSON: EJSON,\n  Int32: Int32,\n  Long: Long,\n  MaxKey: MaxKey,\n  MinKey: MinKey,\n  ObjectId: ObjectId,\n  Timestamp: Timestamp,\n  UUID: UUID,\n  calculateObjectSize: calculateObjectSize,\n  deserialize: deserialize,\n  deserializeStream: deserializeStream,\n  serialize: serialize,\n  serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n  setInternalBufferSize: setInternalBufferSize\n});\nexport { bson as BSON, BSONError, BSONRegExp, BSONRuntimeError, BSONSymbol, BSONType, BSONValue, BSONVersionError, Binary, Code, DBRef, Decimal128, Double, EJSON, Int32, Long, MaxKey, MinKey, ObjectId, Timestamp, UUID, calculateObjectSize, deserialize, deserializeStream, serialize, serializeWithBufferAndIndex, setInternalBufferSize };","map":{"version":3,"names":["isAnyArrayBuffer","value","includes","Object","prototype","toString","call","isUint8Array","isRegExp","d","isMap","isDate","BSON_MAJOR_VERSION","BSON_INT32_MAX","BSON_INT32_MIN","BSON_INT64_MAX","Math","pow","BSON_INT64_MIN","JS_INT_MAX","JS_INT_MIN","BSON_DATA_NUMBER","BSON_DATA_STRING","BSON_DATA_OBJECT","BSON_DATA_ARRAY","BSON_DATA_BINARY","BSON_DATA_UNDEFINED","BSON_DATA_OID","BSON_DATA_BOOLEAN","BSON_DATA_DATE","BSON_DATA_NULL","BSON_DATA_REGEXP","BSON_DATA_DBPOINTER","BSON_DATA_CODE","BSON_DATA_SYMBOL","BSON_DATA_CODE_W_SCOPE","BSON_DATA_INT","BSON_DATA_TIMESTAMP","BSON_DATA_LONG","BSON_DATA_DECIMAL128","BSON_DATA_MIN_KEY","BSON_DATA_MAX_KEY","BSON_BINARY_SUBTYPE_DEFAULT","BSON_BINARY_SUBTYPE_UUID_NEW","BSONType","freeze","double","string","object","array","binData","undefined","objectId","bool","date","null","regex","dbPointer","javascript","symbol","javascriptWithScope","int","timestamp","long","decimal","minKey","maxKey","BSONError","Error","bsonError","name","constructor","message","isBSONError","BSONVersionError","BSONRuntimeError","nodejsMathRandomBytes","byteLength","nodeJsByteUtils","fromNumberArray","Array","from","length","floor","random","nodejsRandomBytes","_asyncToGenerator","randomBytes","toLocalBufferType","potentialBuffer","Buffer","isBuffer","ArrayBuffer","isView","buffer","byteOffset","stringTag","Symbol","toStringTag","String","allocate","size","alloc","equals","a","b","fromBase64","base64","toBase64","fromISO88591","codePoints","toISO88591","fromHex","hex","toHex","fromUTF8","text","toUTF8","utf8ByteLength","input","encodeUTF8Into","source","write","isReactNative","navigator","globalThis","product","webMathRandomBytes","RangeError","webByteUtils","webRandomBytes","crypto","getRandomValues","console","warn","HEX_DIGIT","potentialUint8array","Uint8Array","slice","TypeError","i","atob","c","charCodeAt","uint8array","btoa","Uint16Array","fromCharCode","join","evenLengthHex","firstDigit","secondDigit","test","hexDigit","Number","parseInt","push","byte","padStart","TextEncoder","encode","TextDecoder","fatal","decode","bytes","set","hasGlobalBuffer","_isBuffer","ByteUtils","BSONDataView","DataView","fromUint8Array","BSONValue","for","Binary","_bsontype","subType","isArray","sub_type","BUFFER_SIZE","position","put","byteValue","decodedByte","newSpace","sequence","offset","read","asRaw","subarray","toJSON","encoding","toExtendedJSON","options","base64String","legacy","$binary","$type","toUUID","SUBTYPE_UUID","UUID","createFromHexString","createFromBase64","fromExtendedJSON","doc","data","type","bytesFromString","$uuid","JSON","stringify","inspect","SUBTYPE_DEFAULT","SUBTYPE_FUNCTION","SUBTYPE_BYTE_ARRAY","SUBTYPE_UUID_OLD","SUBTYPE_MD5","SUBTYPE_ENCRYPTED","SUBTYPE_COLUMN","SUBTYPE_USER_DEFINED","UUID_BYTE_LENGTH","UUID_WITHOUT_DASHES","UUID_WITH_DASHES","generate","id","toHexString","includeDashes","otherId","toBinary","isValid","isValidUUIDString","hexString","representation","replace","cacheHexString","Code","code","scope","$code","$scope","codeJson","isDBRefLike","$id","$ref","$db","DBRef","collection","oid","db","fields","parts","split","shift","namespace","o","assign","copy","wasm","WebAssembly","Instance","Module","exports","TWO_PWR_16_DBL","TWO_PWR_24_DBL","TWO_PWR_32_DBL","TWO_PWR_64_DBL","TWO_PWR_63_DBL","INT_CACHE","UINT_CACHE","MAX_INT64_STRING_LENGTH","DECIMAL_REG_EX","Long","__isLong__","low","high","unsigned","fromBigInt","fromString","fromBits","lowBits","highBits","fromInt","obj","cachedObj","cache","fromNumber","isNaN","UZERO","ZERO","MAX_UNSIGNED_VALUE","MIN_VALUE","MAX_VALUE","neg","str","radix","p","indexOf","substring","radixToPower","result","min","power","mul","add","fromBytes","le","fromBytesLE","fromBytesBE","isLong","fromValue","val","addend","a48","a32","a16","a00","b48","b32","b16","b00","c48","c32","c16","c00","and","other","compare","eq","thisNeg","isNegative","otherNeg","sub","comp","divide","divisor","isZero","div_u","div_s","get_high","approx","rem","res","ONE","NEG_ONE","halfThis","shr","div","shl","toUnsigned","gt","shru","UONE","gte","max","toNumber","log2","ceil","log","LN2","delta","approxRes","approxRem","getHighBits","getHighBitsUnsigned","getLowBits","getLowBitsUnsigned","getNumBitsAbs","bit","greaterThan","greaterThanOrEqual","ge","isEven","isOdd","isPositive","lessThan","lt","lessThanOrEqual","lte","modulo","rem_u","rem_s","mod","multiply","multiplier","TWO_PWR_24","negate","not","notEquals","neq","ne","or","shiftLeft","numBits","toInt","shiftRight","shiftRightUnsigned","shr_u","subtract","subtrahend","toBigInt","BigInt","toBytes","toBytesLE","toBytesBE","hi","lo","toSigned","radixLong","rem1","remDiv","intval","digits","xor","eqz","relaxed","$numberLong","useBigInt64","bigIntResult","asIntN","longResult","PARSE_STRING_REGEXP","PARSE_INF_REGEXP","PARSE_NAN_REGEXP","EXPONENT_MAX","EXPONENT_MIN","EXPONENT_BIAS","MAX_DIGITS","NAN_BUFFER","reverse","INF_NEGATIVE_BUFFER","INF_POSITIVE_BUFFER","EXPONENT_REGEX","COMBINATION_MASK","EXPONENT_MASK","COMBINATION_INFINITY","COMBINATION_NAN","isDigit","divideu128","DIVISOR","_rem","quotient","multiply64x2","left","right","leftHigh","leftLow","rightHigh","rightLow","productHigh","productMid","productMid2","productLow","uhleft","uhright","ulleft","ulright","invalidErr","Decimal128","sawRadix","foundNonZero","significantDigits","nDigitsRead","nDigits","radixPosition","firstNonZero","nDigitsStored","digitsInsert","lastDigit","exponent","significandHigh","significandLow","biasedExponent","index","stringMatch","match","infMatch","nanMatch","unsignedNumber","e","expSign","expNumber","substr","digitsString","endOfString","roundDigit","roundBit","dIdx","significand","dec","biased_exponent","significand_digits","is_zero","significand_msb","significand128","j","k","midl","midh","combination","least_digits","scientific_exponent","radix_position","$numberDecimal","Double","valueOf","isFinite","is","sign","$numberDouble","isInteger","toFixed","doubleValue","parseFloat","eJSON","Int32","$numberInt","MaxKey","$maxKey","MinKey","$minKey","checkForHexRegExp","RegExp","PROCESS_UNIQUE","kId","ObjectId","inputId","workingId","__id","getInc","time","Date","now","inc","setUint32","toLowerCase","otherIdString","thisIdString","getTimestamp","getUint32","setTime","createPk","createFromTime","$oid","internalCalculateObjectSize","serializeFunctions","ignoreUndefined","totalLength","calculateElement","toBSON","key","keys","binary","ordered_values","global","ignoreCase","multiline","pattern","alphabetize","sort","BSONRegExp","parseOptions","$regex","$options","$regularExpression","BSONSymbol","$symbol","LongWithoutOverridesClass","Timestamp","t","$timestamp","optRadix","FIRST_BIT","FIRST_TWO_BITS","FIRST_THREE_BITS","FIRST_FOUR_BITS","FIRST_FIVE_BITS","TWO_BIT_CHAR","THREE_BIT_CHAR","FOUR_BIT_CHAR","CONTINUING_CHAR","validateUtf8","start","end","continuation","JS_INT_MAX_LONG","JS_INT_MIN_LONG","internalDeserialize","allowObjectSmallerThanBufferSize","deserializeObject","allowedDBRefKeys","fieldsAsRaw","raw","bsonRegExp","promoteBuffers","promoteLongs","promoteValues","validation","utf8","globalUTFValidation","validationSetting","utf8KeysSet","Set","utf8ValidatedKeys","utf8ValidationValues","map","every","item","startIndex","arrayIndex","done","isPossibleDBRef","dataview","elementType","shouldValidateKey","has","stringSize","getValidatedString","getFloat64","_index","objectSize","objectOptions","arrayOptions","stopIndex","getBigInt64","binarySize","totalBinarySize","_buffer","regExpOptions","optionsArray","functionString","totalSize","scopeObject","oidBuffer","defineProperty","writable","enumerable","configurable","shouldValidateUtf8","regexp","ignoreKeys","serializeString","numberOfWrittenBytes","NUMBER_SPACE","FOUR_BYTE_VIEW_ON_NUMBER","EIGHT_BYTE_VIEW_ON_NUMBER","serializeNumber","isNegativeZero","isSafeInteger","setInt32","setFloat64","serializeBigInt","setBigInt64","serializeNull","_","serializeBoolean","serializeDate","dateInMilis","getTime","serializeRegExp","serializeBSONRegExp","sortedOptions","serializeMinMax","serializeObjectId","serializeBuffer","serializeObject","checkKeys","depth","path","endIndex","serializeInto","delete","serializeDecimal128","serializeLong","serializeInt32","serializeDouble","serializeFunction","serializeCode","codeSize","serializeBinary","serializeSymbol","serializeDBRef","output","startingIndex","Map","iterator","entries","entry","next","isBSONType","keysToCodecs","deserializeValue","in32BitRange","in64BitRange","$undefined","filter","startsWith","$date","parse","$dbPointer","v","dollarKeys","valid","forEach","serializeArray","seenObjects","propertyName","serializeValue","pop","getISOString","isoStr","toISOString","getUTCMilliseconds","create","findIndex","props","leadingPart","prop","alreadySeen","circularPart","current","leadingSpace","repeat","dashes","dateNum","inRange","flags","rx","serializeDocument","BSON_TYPE_MAPPINGS","low_","high_","unsigned_","bsontype","_doc","outDoc","mapper","ejsonOptions","replacer","space","serializeOptions","EJSONserialize","EJSONdeserialize","ejson","EJSON","serialize","deserialize","MAXSIZE","setInternalBufferSize","minInternalBufferSize","serializationIndex","finishedBuffer","serializeWithBufferAndIndex","finalBuffer","calculateObjectSize","deserializeStream","numberOfDocuments","documents","docStartIndex","internalOptions","bufferData","bson","__proto__","BSON"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/client/node_modules/bson/lib/bson.mjs"],"sourcesContent":["function isAnyArrayBuffer(value) {\n    return ['[object ArrayBuffer]', '[object SharedArrayBuffer]'].includes(Object.prototype.toString.call(value));\n}\nfunction isUint8Array(value) {\n    return Object.prototype.toString.call(value) === '[object Uint8Array]';\n}\nfunction isRegExp(d) {\n    return Object.prototype.toString.call(d) === '[object RegExp]';\n}\nfunction isMap(d) {\n    return Object.prototype.toString.call(d) === '[object Map]';\n}\nfunction isDate(d) {\n    return Object.prototype.toString.call(d) === '[object Date]';\n}\n\nconst BSON_MAJOR_VERSION = 5;\nconst BSON_INT32_MAX = 0x7fffffff;\nconst BSON_INT32_MIN = -0x80000000;\nconst BSON_INT64_MAX = Math.pow(2, 63) - 1;\nconst BSON_INT64_MIN = -Math.pow(2, 63);\nconst JS_INT_MAX = Math.pow(2, 53);\nconst JS_INT_MIN = -Math.pow(2, 53);\nconst BSON_DATA_NUMBER = 1;\nconst BSON_DATA_STRING = 2;\nconst BSON_DATA_OBJECT = 3;\nconst BSON_DATA_ARRAY = 4;\nconst BSON_DATA_BINARY = 5;\nconst BSON_DATA_UNDEFINED = 6;\nconst BSON_DATA_OID = 7;\nconst BSON_DATA_BOOLEAN = 8;\nconst BSON_DATA_DATE = 9;\nconst BSON_DATA_NULL = 10;\nconst BSON_DATA_REGEXP = 11;\nconst BSON_DATA_DBPOINTER = 12;\nconst BSON_DATA_CODE = 13;\nconst BSON_DATA_SYMBOL = 14;\nconst BSON_DATA_CODE_W_SCOPE = 15;\nconst BSON_DATA_INT = 16;\nconst BSON_DATA_TIMESTAMP = 17;\nconst BSON_DATA_LONG = 18;\nconst BSON_DATA_DECIMAL128 = 19;\nconst BSON_DATA_MIN_KEY = 0xff;\nconst BSON_DATA_MAX_KEY = 0x7f;\nconst BSON_BINARY_SUBTYPE_DEFAULT = 0;\nconst BSON_BINARY_SUBTYPE_UUID_NEW = 4;\nconst BSONType = Object.freeze({\n    double: 1,\n    string: 2,\n    object: 3,\n    array: 4,\n    binData: 5,\n    undefined: 6,\n    objectId: 7,\n    bool: 8,\n    date: 9,\n    null: 10,\n    regex: 11,\n    dbPointer: 12,\n    javascript: 13,\n    symbol: 14,\n    javascriptWithScope: 15,\n    int: 16,\n    timestamp: 17,\n    long: 18,\n    decimal: 19,\n    minKey: -1,\n    maxKey: 127\n});\n\nclass BSONError extends Error {\n    get bsonError() {\n        return true;\n    }\n    get name() {\n        return 'BSONError';\n    }\n    constructor(message) {\n        super(message);\n    }\n    static isBSONError(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            'bsonError' in value &&\n            value.bsonError === true &&\n            'name' in value &&\n            'message' in value &&\n            'stack' in value);\n    }\n}\nclass BSONVersionError extends BSONError {\n    get name() {\n        return 'BSONVersionError';\n    }\n    constructor() {\n        super(`Unsupported BSON version, bson types must be from bson ${BSON_MAJOR_VERSION}.0 or later`);\n    }\n}\nclass BSONRuntimeError extends BSONError {\n    get name() {\n        return 'BSONRuntimeError';\n    }\n    constructor(message) {\n        super(message);\n    }\n}\n\nfunction nodejsMathRandomBytes(byteLength) {\n    return nodeJsByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst nodejsRandomBytes = await (async () => {\n    try {\n        return (await import('crypto')).randomBytes;\n    }\n    catch {\n        return nodejsMathRandomBytes;\n    }\n})();\nconst nodeJsByteUtils = {\n    toLocalBufferType(potentialBuffer) {\n        if (Buffer.isBuffer(potentialBuffer)) {\n            return potentialBuffer;\n        }\n        if (ArrayBuffer.isView(potentialBuffer)) {\n            return Buffer.from(potentialBuffer.buffer, potentialBuffer.byteOffset, potentialBuffer.byteLength);\n        }\n        const stringTag = potentialBuffer?.[Symbol.toStringTag] ?? Object.prototype.toString.call(potentialBuffer);\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return Buffer.from(potentialBuffer);\n        }\n        throw new BSONError(`Cannot create Buffer from ${String(potentialBuffer)}`);\n    },\n    allocate(size) {\n        return Buffer.alloc(size);\n    },\n    equals(a, b) {\n        return nodeJsByteUtils.toLocalBufferType(a).equals(b);\n    },\n    fromNumberArray(array) {\n        return Buffer.from(array);\n    },\n    fromBase64(base64) {\n        return Buffer.from(base64, 'base64');\n    },\n    toBase64(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('base64');\n    },\n    fromISO88591(codePoints) {\n        return Buffer.from(codePoints, 'binary');\n    },\n    toISO88591(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('binary');\n    },\n    fromHex(hex) {\n        return Buffer.from(hex, 'hex');\n    },\n    toHex(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('hex');\n    },\n    fromUTF8(text) {\n        return Buffer.from(text, 'utf8');\n    },\n    toUTF8(buffer) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).toString('utf8');\n    },\n    utf8ByteLength(input) {\n        return Buffer.byteLength(input, 'utf8');\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        return nodeJsByteUtils.toLocalBufferType(buffer).write(source, byteOffset, undefined, 'utf8');\n    },\n    randomBytes: nodejsRandomBytes\n};\n\nfunction isReactNative() {\n    const { navigator } = globalThis;\n    return typeof navigator === 'object' && navigator.product === 'ReactNative';\n}\nfunction webMathRandomBytes(byteLength) {\n    if (byteLength < 0) {\n        throw new RangeError(`The argument 'byteLength' is invalid. Received ${byteLength}`);\n    }\n    return webByteUtils.fromNumberArray(Array.from({ length: byteLength }, () => Math.floor(Math.random() * 256)));\n}\nconst webRandomBytes = (() => {\n    const { crypto } = globalThis;\n    if (crypto != null && typeof crypto.getRandomValues === 'function') {\n        return (byteLength) => {\n            return crypto.getRandomValues(webByteUtils.allocate(byteLength));\n        };\n    }\n    else {\n        if (isReactNative()) {\n            const { console } = globalThis;\n            console?.warn?.('BSON: For React Native please polyfill crypto.getRandomValues, e.g. using: https://www.npmjs.com/package/react-native-get-random-values.');\n        }\n        return webMathRandomBytes;\n    }\n})();\nconst HEX_DIGIT = /(\\d|[a-f])/i;\nconst webByteUtils = {\n    toLocalBufferType(potentialUint8array) {\n        const stringTag = potentialUint8array?.[Symbol.toStringTag] ??\n            Object.prototype.toString.call(potentialUint8array);\n        if (stringTag === 'Uint8Array') {\n            return potentialUint8array;\n        }\n        if (ArrayBuffer.isView(potentialUint8array)) {\n            return new Uint8Array(potentialUint8array.buffer.slice(potentialUint8array.byteOffset, potentialUint8array.byteOffset + potentialUint8array.byteLength));\n        }\n        if (stringTag === 'ArrayBuffer' ||\n            stringTag === 'SharedArrayBuffer' ||\n            stringTag === '[object ArrayBuffer]' ||\n            stringTag === '[object SharedArrayBuffer]') {\n            return new Uint8Array(potentialUint8array);\n        }\n        throw new BSONError(`Cannot make a Uint8Array from ${String(potentialUint8array)}`);\n    },\n    allocate(size) {\n        if (typeof size !== 'number') {\n            throw new TypeError(`The \"size\" argument must be of type number. Received ${String(size)}`);\n        }\n        return new Uint8Array(size);\n    },\n    equals(a, b) {\n        if (a.byteLength !== b.byteLength) {\n            return false;\n        }\n        for (let i = 0; i < a.byteLength; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    },\n    fromNumberArray(array) {\n        return Uint8Array.from(array);\n    },\n    fromBase64(base64) {\n        return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n    },\n    toBase64(uint8array) {\n        return btoa(webByteUtils.toISO88591(uint8array));\n    },\n    fromISO88591(codePoints) {\n        return Uint8Array.from(codePoints, c => c.charCodeAt(0) & 0xff);\n    },\n    toISO88591(uint8array) {\n        return Array.from(Uint16Array.from(uint8array), b => String.fromCharCode(b)).join('');\n    },\n    fromHex(hex) {\n        const evenLengthHex = hex.length % 2 === 0 ? hex : hex.slice(0, hex.length - 1);\n        const buffer = [];\n        for (let i = 0; i < evenLengthHex.length; i += 2) {\n            const firstDigit = evenLengthHex[i];\n            const secondDigit = evenLengthHex[i + 1];\n            if (!HEX_DIGIT.test(firstDigit)) {\n                break;\n            }\n            if (!HEX_DIGIT.test(secondDigit)) {\n                break;\n            }\n            const hexDigit = Number.parseInt(`${firstDigit}${secondDigit}`, 16);\n            buffer.push(hexDigit);\n        }\n        return Uint8Array.from(buffer);\n    },\n    toHex(uint8array) {\n        return Array.from(uint8array, byte => byte.toString(16).padStart(2, '0')).join('');\n    },\n    fromUTF8(text) {\n        return new TextEncoder().encode(text);\n    },\n    toUTF8(uint8array) {\n        return new TextDecoder('utf8', { fatal: false }).decode(uint8array);\n    },\n    utf8ByteLength(input) {\n        return webByteUtils.fromUTF8(input).byteLength;\n    },\n    encodeUTF8Into(buffer, source, byteOffset) {\n        const bytes = webByteUtils.fromUTF8(source);\n        buffer.set(bytes, byteOffset);\n        return bytes.byteLength;\n    },\n    randomBytes: webRandomBytes\n};\n\nconst hasGlobalBuffer = typeof Buffer === 'function' && Buffer.prototype?._isBuffer !== true;\nconst ByteUtils = hasGlobalBuffer ? nodeJsByteUtils : webByteUtils;\nclass BSONDataView extends DataView {\n    static fromUint8Array(input) {\n        return new DataView(input.buffer, input.byteOffset, input.byteLength);\n    }\n}\n\nclass BSONValue {\n    get [Symbol.for('@@mdb.bson.version')]() {\n        return BSON_MAJOR_VERSION;\n    }\n}\n\nclass Binary extends BSONValue {\n    get _bsontype() {\n        return 'Binary';\n    }\n    constructor(buffer, subType) {\n        super();\n        if (!(buffer == null) &&\n            !(typeof buffer === 'string') &&\n            !ArrayBuffer.isView(buffer) &&\n            !(buffer instanceof ArrayBuffer) &&\n            !Array.isArray(buffer)) {\n            throw new BSONError('Binary can only be constructed from string, Buffer, TypedArray, or Array<number>');\n        }\n        this.sub_type = subType ?? Binary.BSON_BINARY_SUBTYPE_DEFAULT;\n        if (buffer == null) {\n            this.buffer = ByteUtils.allocate(Binary.BUFFER_SIZE);\n            this.position = 0;\n        }\n        else {\n            if (typeof buffer === 'string') {\n                this.buffer = ByteUtils.fromISO88591(buffer);\n            }\n            else if (Array.isArray(buffer)) {\n                this.buffer = ByteUtils.fromNumberArray(buffer);\n            }\n            else {\n                this.buffer = ByteUtils.toLocalBufferType(buffer);\n            }\n            this.position = this.buffer.byteLength;\n        }\n    }\n    put(byteValue) {\n        if (typeof byteValue === 'string' && byteValue.length !== 1) {\n            throw new BSONError('only accepts single character String');\n        }\n        else if (typeof byteValue !== 'number' && byteValue.length !== 1)\n            throw new BSONError('only accepts single character Uint8Array or Array');\n        let decodedByte;\n        if (typeof byteValue === 'string') {\n            decodedByte = byteValue.charCodeAt(0);\n        }\n        else if (typeof byteValue === 'number') {\n            decodedByte = byteValue;\n        }\n        else {\n            decodedByte = byteValue[0];\n        }\n        if (decodedByte < 0 || decodedByte > 255) {\n            throw new BSONError('only accepts number in a valid unsigned byte range 0-255');\n        }\n        if (this.buffer.byteLength > this.position) {\n            this.buffer[this.position++] = decodedByte;\n        }\n        else {\n            const newSpace = ByteUtils.allocate(Binary.BUFFER_SIZE + this.buffer.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n            this.buffer[this.position++] = decodedByte;\n        }\n    }\n    write(sequence, offset) {\n        offset = typeof offset === 'number' ? offset : this.position;\n        if (this.buffer.byteLength < offset + sequence.length) {\n            const newSpace = ByteUtils.allocate(this.buffer.byteLength + sequence.length);\n            newSpace.set(this.buffer, 0);\n            this.buffer = newSpace;\n        }\n        if (ArrayBuffer.isView(sequence)) {\n            this.buffer.set(ByteUtils.toLocalBufferType(sequence), offset);\n            this.position =\n                offset + sequence.byteLength > this.position ? offset + sequence.length : this.position;\n        }\n        else if (typeof sequence === 'string') {\n            const bytes = ByteUtils.fromISO88591(sequence);\n            this.buffer.set(bytes, offset);\n            this.position =\n                offset + sequence.length > this.position ? offset + sequence.length : this.position;\n        }\n    }\n    read(position, length) {\n        length = length && length > 0 ? length : this.position;\n        return this.buffer.slice(position, position + length);\n    }\n    value(asRaw) {\n        asRaw = !!asRaw;\n        if (asRaw && this.buffer.length === this.position) {\n            return this.buffer;\n        }\n        if (asRaw) {\n            return this.buffer.slice(0, this.position);\n        }\n        return ByteUtils.toISO88591(this.buffer.subarray(0, this.position));\n    }\n    length() {\n        return this.position;\n    }\n    toJSON() {\n        return ByteUtils.toBase64(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.buffer);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.buffer);\n        if (encoding === 'utf8' || encoding === 'utf-8')\n            return ByteUtils.toUTF8(this.buffer);\n        return ByteUtils.toUTF8(this.buffer);\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        const base64String = ByteUtils.toBase64(this.buffer);\n        const subType = Number(this.sub_type).toString(16);\n        if (options.legacy) {\n            return {\n                $binary: base64String,\n                $type: subType.length === 1 ? '0' + subType : subType\n            };\n        }\n        return {\n            $binary: {\n                base64: base64String,\n                subType: subType.length === 1 ? '0' + subType : subType\n            }\n        };\n    }\n    toUUID() {\n        if (this.sub_type === Binary.SUBTYPE_UUID) {\n            return new UUID(this.buffer.slice(0, this.position));\n        }\n        throw new BSONError(`Binary sub_type \"${this.sub_type}\" is not supported for converting to UUID. Only \"${Binary.SUBTYPE_UUID}\" is currently supported.`);\n    }\n    static createFromHexString(hex, subType) {\n        return new Binary(ByteUtils.fromHex(hex), subType);\n    }\n    static createFromBase64(base64, subType) {\n        return new Binary(ByteUtils.fromBase64(base64), subType);\n    }\n    static fromExtendedJSON(doc, options) {\n        options = options || {};\n        let data;\n        let type;\n        if ('$binary' in doc) {\n            if (options.legacy && typeof doc.$binary === 'string' && '$type' in doc) {\n                type = doc.$type ? parseInt(doc.$type, 16) : 0;\n                data = ByteUtils.fromBase64(doc.$binary);\n            }\n            else {\n                if (typeof doc.$binary !== 'string') {\n                    type = doc.$binary.subType ? parseInt(doc.$binary.subType, 16) : 0;\n                    data = ByteUtils.fromBase64(doc.$binary.base64);\n                }\n            }\n        }\n        else if ('$uuid' in doc) {\n            type = 4;\n            data = UUID.bytesFromString(doc.$uuid);\n        }\n        if (!data) {\n            throw new BSONError(`Unexpected Binary Extended JSON format ${JSON.stringify(doc)}`);\n        }\n        return type === BSON_BINARY_SUBTYPE_UUID_NEW ? new UUID(data) : new Binary(data, type);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const base64 = ByteUtils.toBase64(this.buffer.subarray(0, this.position));\n        return `Binary.createFromBase64(\"${base64}\", ${this.sub_type})`;\n    }\n}\nBinary.BSON_BINARY_SUBTYPE_DEFAULT = 0;\nBinary.BUFFER_SIZE = 256;\nBinary.SUBTYPE_DEFAULT = 0;\nBinary.SUBTYPE_FUNCTION = 1;\nBinary.SUBTYPE_BYTE_ARRAY = 2;\nBinary.SUBTYPE_UUID_OLD = 3;\nBinary.SUBTYPE_UUID = 4;\nBinary.SUBTYPE_MD5 = 5;\nBinary.SUBTYPE_ENCRYPTED = 6;\nBinary.SUBTYPE_COLUMN = 7;\nBinary.SUBTYPE_USER_DEFINED = 128;\nconst UUID_BYTE_LENGTH = 16;\nconst UUID_WITHOUT_DASHES = /^[0-9A-F]{32}$/i;\nconst UUID_WITH_DASHES = /^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i;\nclass UUID extends Binary {\n    constructor(input) {\n        let bytes;\n        if (input == null) {\n            bytes = UUID.generate();\n        }\n        else if (input instanceof UUID) {\n            bytes = ByteUtils.toLocalBufferType(new Uint8Array(input.buffer));\n        }\n        else if (ArrayBuffer.isView(input) && input.byteLength === UUID_BYTE_LENGTH) {\n            bytes = ByteUtils.toLocalBufferType(input);\n        }\n        else if (typeof input === 'string') {\n            bytes = UUID.bytesFromString(input);\n        }\n        else {\n            throw new BSONError('Argument passed in UUID constructor must be a UUID, a 16 byte Buffer or a 32/36 character hex string (dashes excluded/included, format: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx).');\n        }\n        super(bytes, BSON_BINARY_SUBTYPE_UUID_NEW);\n    }\n    get id() {\n        return this.buffer;\n    }\n    set id(value) {\n        this.buffer = value;\n    }\n    toHexString(includeDashes = true) {\n        if (includeDashes) {\n            return [\n                ByteUtils.toHex(this.buffer.subarray(0, 4)),\n                ByteUtils.toHex(this.buffer.subarray(4, 6)),\n                ByteUtils.toHex(this.buffer.subarray(6, 8)),\n                ByteUtils.toHex(this.buffer.subarray(8, 10)),\n                ByteUtils.toHex(this.buffer.subarray(10, 16))\n            ].join('-');\n        }\n        return ByteUtils.toHex(this.buffer);\n    }\n    toString(encoding) {\n        if (encoding === 'hex')\n            return ByteUtils.toHex(this.id);\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (!otherId) {\n            return false;\n        }\n        if (otherId instanceof UUID) {\n            return ByteUtils.equals(otherId.id, this.id);\n        }\n        try {\n            return ByteUtils.equals(new UUID(otherId).id, this.id);\n        }\n        catch {\n            return false;\n        }\n    }\n    toBinary() {\n        return new Binary(this.id, Binary.SUBTYPE_UUID);\n    }\n    static generate() {\n        const bytes = ByteUtils.randomBytes(UUID_BYTE_LENGTH);\n        bytes[6] = (bytes[6] & 0x0f) | 0x40;\n        bytes[8] = (bytes[8] & 0x3f) | 0x80;\n        return bytes;\n    }\n    static isValid(input) {\n        if (!input) {\n            return false;\n        }\n        if (typeof input === 'string') {\n            return UUID.isValidUUIDString(input);\n        }\n        if (isUint8Array(input)) {\n            return input.byteLength === UUID_BYTE_LENGTH;\n        }\n        return (input._bsontype === 'Binary' &&\n            input.sub_type === this.SUBTYPE_UUID &&\n            input.buffer.byteLength === 16);\n    }\n    static createFromHexString(hexString) {\n        const buffer = UUID.bytesFromString(hexString);\n        return new UUID(buffer);\n    }\n    static createFromBase64(base64) {\n        return new UUID(ByteUtils.fromBase64(base64));\n    }\n    static bytesFromString(representation) {\n        if (!UUID.isValidUUIDString(representation)) {\n            throw new BSONError('UUID string representation must be 32 hex digits or canonical hyphenated representation');\n        }\n        return ByteUtils.fromHex(representation.replace(/-/g, ''));\n    }\n    static isValidUUIDString(representation) {\n        return UUID_WITHOUT_DASHES.test(representation) || UUID_WITH_DASHES.test(representation);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new UUID(\"${this.toHexString()}\")`;\n    }\n}\nUUID.cacheHexString = false;\n\nclass Code extends BSONValue {\n    get _bsontype() {\n        return 'Code';\n    }\n    constructor(code, scope) {\n        super();\n        this.code = code.toString();\n        this.scope = scope ?? null;\n    }\n    toJSON() {\n        if (this.scope != null) {\n            return { code: this.code, scope: this.scope };\n        }\n        return { code: this.code };\n    }\n    toExtendedJSON() {\n        if (this.scope) {\n            return { $code: this.code, $scope: this.scope };\n        }\n        return { $code: this.code };\n    }\n    static fromExtendedJSON(doc) {\n        return new Code(doc.$code, doc.$scope);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const codeJson = this.toJSON();\n        return `new Code(\"${String(codeJson.code)}\"${codeJson.scope != null ? `, ${JSON.stringify(codeJson.scope)}` : ''})`;\n    }\n}\n\nfunction isDBRefLike(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '$id' in value &&\n        value.$id != null &&\n        '$ref' in value &&\n        typeof value.$ref === 'string' &&\n        (!('$db' in value) || ('$db' in value && typeof value.$db === 'string')));\n}\nclass DBRef extends BSONValue {\n    get _bsontype() {\n        return 'DBRef';\n    }\n    constructor(collection, oid, db, fields) {\n        super();\n        const parts = collection.split('.');\n        if (parts.length === 2) {\n            db = parts.shift();\n            collection = parts.shift();\n        }\n        this.collection = collection;\n        this.oid = oid;\n        this.db = db;\n        this.fields = fields || {};\n    }\n    get namespace() {\n        return this.collection;\n    }\n    set namespace(value) {\n        this.collection = value;\n    }\n    toJSON() {\n        const o = Object.assign({\n            $ref: this.collection,\n            $id: this.oid\n        }, this.fields);\n        if (this.db != null)\n            o.$db = this.db;\n        return o;\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        let o = {\n            $ref: this.collection,\n            $id: this.oid\n        };\n        if (options.legacy) {\n            return o;\n        }\n        if (this.db)\n            o.$db = this.db;\n        o = Object.assign(o, this.fields);\n        return o;\n    }\n    static fromExtendedJSON(doc) {\n        const copy = Object.assign({}, doc);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(doc.$ref, doc.$id, doc.$db, copy);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const oid = this.oid === undefined || this.oid.toString === undefined ? this.oid : this.oid.toString();\n        return `new DBRef(\"${this.namespace}\", new ObjectId(\"${String(oid)}\")${this.db ? `, \"${this.db}\"` : ''})`;\n    }\n}\n\nlet wasm = undefined;\ntry {\n    wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;\n}\ncatch {\n}\nconst TWO_PWR_16_DBL = 1 << 16;\nconst TWO_PWR_24_DBL = 1 << 24;\nconst TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\nconst TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\nconst TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\nconst INT_CACHE = {};\nconst UINT_CACHE = {};\nconst MAX_INT64_STRING_LENGTH = 20;\nconst DECIMAL_REG_EX = /^(\\+?0|(\\+|-)?[1-9][0-9]*)$/;\nclass Long extends BSONValue {\n    get _bsontype() {\n        return 'Long';\n    }\n    get __isLong__() {\n        return true;\n    }\n    constructor(low = 0, high, unsigned) {\n        super();\n        if (typeof low === 'bigint') {\n            Object.assign(this, Long.fromBigInt(low, !!high));\n        }\n        else if (typeof low === 'string') {\n            Object.assign(this, Long.fromString(low, !!high));\n        }\n        else {\n            this.low = low | 0;\n            this.high = high | 0;\n            this.unsigned = !!unsigned;\n        }\n    }\n    static fromBits(lowBits, highBits, unsigned) {\n        return new Long(lowBits, highBits, unsigned);\n    }\n    static fromInt(value, unsigned) {\n        let obj, cachedObj, cache;\n        if (unsigned) {\n            value >>>= 0;\n            if ((cache = 0 <= value && value < 256)) {\n                cachedObj = UINT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, (value | 0) < 0 ? -1 : 0, true);\n            if (cache)\n                UINT_CACHE[value] = obj;\n            return obj;\n        }\n        else {\n            value |= 0;\n            if ((cache = -128 <= value && value < 128)) {\n                cachedObj = INT_CACHE[value];\n                if (cachedObj)\n                    return cachedObj;\n            }\n            obj = Long.fromBits(value, value < 0 ? -1 : 0, false);\n            if (cache)\n                INT_CACHE[value] = obj;\n            return obj;\n        }\n    }\n    static fromNumber(value, unsigned) {\n        if (isNaN(value))\n            return unsigned ? Long.UZERO : Long.ZERO;\n        if (unsigned) {\n            if (value < 0)\n                return Long.UZERO;\n            if (value >= TWO_PWR_64_DBL)\n                return Long.MAX_UNSIGNED_VALUE;\n        }\n        else {\n            if (value <= -TWO_PWR_63_DBL)\n                return Long.MIN_VALUE;\n            if (value + 1 >= TWO_PWR_63_DBL)\n                return Long.MAX_VALUE;\n        }\n        if (value < 0)\n            return Long.fromNumber(-value, unsigned).neg();\n        return Long.fromBits(value % TWO_PWR_32_DBL | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\n    }\n    static fromBigInt(value, unsigned) {\n        return Long.fromString(value.toString(), unsigned);\n    }\n    static fromString(str, unsigned, radix) {\n        if (str.length === 0)\n            throw new BSONError('empty string');\n        if (str === 'NaN' || str === 'Infinity' || str === '+Infinity' || str === '-Infinity')\n            return Long.ZERO;\n        if (typeof unsigned === 'number') {\n            (radix = unsigned), (unsigned = false);\n        }\n        else {\n            unsigned = !!unsigned;\n        }\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        let p;\n        if ((p = str.indexOf('-')) > 0)\n            throw new BSONError('interior hyphen');\n        else if (p === 0) {\n            return Long.fromString(str.substring(1), unsigned, radix).neg();\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 8));\n        let result = Long.ZERO;\n        for (let i = 0; i < str.length; i += 8) {\n            const size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);\n            if (size < 8) {\n                const power = Long.fromNumber(Math.pow(radix, size));\n                result = result.mul(power).add(Long.fromNumber(value));\n            }\n            else {\n                result = result.mul(radixToPower);\n                result = result.add(Long.fromNumber(value));\n            }\n        }\n        result.unsigned = unsigned;\n        return result;\n    }\n    static fromBytes(bytes, unsigned, le) {\n        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\n    }\n    static fromBytesLE(bytes, unsigned) {\n        return new Long(bytes[0] | (bytes[1] << 8) | (bytes[2] << 16) | (bytes[3] << 24), bytes[4] | (bytes[5] << 8) | (bytes[6] << 16) | (bytes[7] << 24), unsigned);\n    }\n    static fromBytesBE(bytes, unsigned) {\n        return new Long((bytes[4] << 24) | (bytes[5] << 16) | (bytes[6] << 8) | bytes[7], (bytes[0] << 24) | (bytes[1] << 16) | (bytes[2] << 8) | bytes[3], unsigned);\n    }\n    static isLong(value) {\n        return (value != null &&\n            typeof value === 'object' &&\n            '__isLong__' in value &&\n            value.__isLong__ === true);\n    }\n    static fromValue(val, unsigned) {\n        if (typeof val === 'number')\n            return Long.fromNumber(val, unsigned);\n        if (typeof val === 'string')\n            return Long.fromString(val, unsigned);\n        return Long.fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\n    }\n    add(addend) {\n        if (!Long.isLong(addend))\n            addend = Long.fromValue(addend);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = addend.high >>> 16;\n        const b32 = addend.high & 0xffff;\n        const b16 = addend.low >>> 16;\n        const b00 = addend.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 + b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 + b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 + b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 + b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    and(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low & other.low, this.high & other.high, this.unsigned);\n    }\n    compare(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.eq(other))\n            return 0;\n        const thisNeg = this.isNegative(), otherNeg = other.isNegative();\n        if (thisNeg && !otherNeg)\n            return -1;\n        if (!thisNeg && otherNeg)\n            return 1;\n        if (!this.unsigned)\n            return this.sub(other).isNegative() ? -1 : 1;\n        return other.high >>> 0 > this.high >>> 0 ||\n            (other.high === this.high && other.low >>> 0 > this.low >>> 0)\n            ? -1\n            : 1;\n    }\n    comp(other) {\n        return this.compare(other);\n    }\n    divide(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (divisor.isZero())\n            throw new BSONError('division by zero');\n        if (wasm) {\n            if (!this.unsigned &&\n                this.high === -0x80000000 &&\n                divisor.low === -1 &&\n                divisor.high === -1) {\n                return this;\n            }\n            const low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (this.isZero())\n            return this.unsigned ? Long.UZERO : Long.ZERO;\n        let approx, rem, res;\n        if (!this.unsigned) {\n            if (this.eq(Long.MIN_VALUE)) {\n                if (divisor.eq(Long.ONE) || divisor.eq(Long.NEG_ONE))\n                    return Long.MIN_VALUE;\n                else if (divisor.eq(Long.MIN_VALUE))\n                    return Long.ONE;\n                else {\n                    const halfThis = this.shr(1);\n                    approx = halfThis.div(divisor).shl(1);\n                    if (approx.eq(Long.ZERO)) {\n                        return divisor.isNegative() ? Long.ONE : Long.NEG_ONE;\n                    }\n                    else {\n                        rem = this.sub(divisor.mul(approx));\n                        res = approx.add(rem.div(divisor));\n                        return res;\n                    }\n                }\n            }\n            else if (divisor.eq(Long.MIN_VALUE))\n                return this.unsigned ? Long.UZERO : Long.ZERO;\n            if (this.isNegative()) {\n                if (divisor.isNegative())\n                    return this.neg().div(divisor.neg());\n                return this.neg().div(divisor).neg();\n            }\n            else if (divisor.isNegative())\n                return this.div(divisor.neg()).neg();\n            res = Long.ZERO;\n        }\n        else {\n            if (!divisor.unsigned)\n                divisor = divisor.toUnsigned();\n            if (divisor.gt(this))\n                return Long.UZERO;\n            if (divisor.gt(this.shru(1)))\n                return Long.UONE;\n            res = Long.UZERO;\n        }\n        rem = this;\n        while (rem.gte(divisor)) {\n            approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\n            const log2 = Math.ceil(Math.log(approx) / Math.LN2);\n            const delta = log2 <= 48 ? 1 : Math.pow(2, log2 - 48);\n            let approxRes = Long.fromNumber(approx);\n            let approxRem = approxRes.mul(divisor);\n            while (approxRem.isNegative() || approxRem.gt(rem)) {\n                approx -= delta;\n                approxRes = Long.fromNumber(approx, this.unsigned);\n                approxRem = approxRes.mul(divisor);\n            }\n            if (approxRes.isZero())\n                approxRes = Long.ONE;\n            res = res.add(approxRes);\n            rem = rem.sub(approxRem);\n        }\n        return res;\n    }\n    div(divisor) {\n        return this.divide(divisor);\n    }\n    equals(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)\n            return false;\n        return this.high === other.high && this.low === other.low;\n    }\n    eq(other) {\n        return this.equals(other);\n    }\n    getHighBits() {\n        return this.high;\n    }\n    getHighBitsUnsigned() {\n        return this.high >>> 0;\n    }\n    getLowBits() {\n        return this.low;\n    }\n    getLowBitsUnsigned() {\n        return this.low >>> 0;\n    }\n    getNumBitsAbs() {\n        if (this.isNegative()) {\n            return this.eq(Long.MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\n        }\n        const val = this.high !== 0 ? this.high : this.low;\n        let bit;\n        for (bit = 31; bit > 0; bit--)\n            if ((val & (1 << bit)) !== 0)\n                break;\n        return this.high !== 0 ? bit + 33 : bit + 1;\n    }\n    greaterThan(other) {\n        return this.comp(other) > 0;\n    }\n    gt(other) {\n        return this.greaterThan(other);\n    }\n    greaterThanOrEqual(other) {\n        return this.comp(other) >= 0;\n    }\n    gte(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    ge(other) {\n        return this.greaterThanOrEqual(other);\n    }\n    isEven() {\n        return (this.low & 1) === 0;\n    }\n    isNegative() {\n        return !this.unsigned && this.high < 0;\n    }\n    isOdd() {\n        return (this.low & 1) === 1;\n    }\n    isPositive() {\n        return this.unsigned || this.high >= 0;\n    }\n    isZero() {\n        return this.high === 0 && this.low === 0;\n    }\n    lessThan(other) {\n        return this.comp(other) < 0;\n    }\n    lt(other) {\n        return this.lessThan(other);\n    }\n    lessThanOrEqual(other) {\n        return this.comp(other) <= 0;\n    }\n    lte(other) {\n        return this.lessThanOrEqual(other);\n    }\n    modulo(divisor) {\n        if (!Long.isLong(divisor))\n            divisor = Long.fromValue(divisor);\n        if (wasm) {\n            const low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        return this.sub(this.div(divisor).mul(divisor));\n    }\n    mod(divisor) {\n        return this.modulo(divisor);\n    }\n    rem(divisor) {\n        return this.modulo(divisor);\n    }\n    multiply(multiplier) {\n        if (this.isZero())\n            return Long.ZERO;\n        if (!Long.isLong(multiplier))\n            multiplier = Long.fromValue(multiplier);\n        if (wasm) {\n            const low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);\n            return Long.fromBits(low, wasm.get_high(), this.unsigned);\n        }\n        if (multiplier.isZero())\n            return Long.ZERO;\n        if (this.eq(Long.MIN_VALUE))\n            return multiplier.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (multiplier.eq(Long.MIN_VALUE))\n            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;\n        if (this.isNegative()) {\n            if (multiplier.isNegative())\n                return this.neg().mul(multiplier.neg());\n            else\n                return this.neg().mul(multiplier).neg();\n        }\n        else if (multiplier.isNegative())\n            return this.mul(multiplier.neg()).neg();\n        if (this.lt(Long.TWO_PWR_24) && multiplier.lt(Long.TWO_PWR_24))\n            return Long.fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\n        const a48 = this.high >>> 16;\n        const a32 = this.high & 0xffff;\n        const a16 = this.low >>> 16;\n        const a00 = this.low & 0xffff;\n        const b48 = multiplier.high >>> 16;\n        const b32 = multiplier.high & 0xffff;\n        const b16 = multiplier.low >>> 16;\n        const b00 = multiplier.low & 0xffff;\n        let c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n        c00 += a00 * b00;\n        c16 += c00 >>> 16;\n        c00 &= 0xffff;\n        c16 += a16 * b00;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c16 += a00 * b16;\n        c32 += c16 >>> 16;\n        c16 &= 0xffff;\n        c32 += a32 * b00;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a16 * b16;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c32 += a00 * b32;\n        c48 += c32 >>> 16;\n        c32 &= 0xffff;\n        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n        c48 &= 0xffff;\n        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\n    }\n    mul(multiplier) {\n        return this.multiply(multiplier);\n    }\n    negate() {\n        if (!this.unsigned && this.eq(Long.MIN_VALUE))\n            return Long.MIN_VALUE;\n        return this.not().add(Long.ONE);\n    }\n    neg() {\n        return this.negate();\n    }\n    not() {\n        return Long.fromBits(~this.low, ~this.high, this.unsigned);\n    }\n    notEquals(other) {\n        return !this.equals(other);\n    }\n    neq(other) {\n        return this.notEquals(other);\n    }\n    ne(other) {\n        return this.notEquals(other);\n    }\n    or(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low | other.low, this.high | other.high, this.unsigned);\n    }\n    shiftLeft(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\n        else\n            return Long.fromBits(0, this.low << (numBits - 32), this.unsigned);\n    }\n    shl(numBits) {\n        return this.shiftLeft(numBits);\n    }\n    shiftRight(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        if ((numBits &= 63) === 0)\n            return this;\n        else if (numBits < 32)\n            return Long.fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\n        else\n            return Long.fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\n    }\n    shr(numBits) {\n        return this.shiftRight(numBits);\n    }\n    shiftRightUnsigned(numBits) {\n        if (Long.isLong(numBits))\n            numBits = numBits.toInt();\n        numBits &= 63;\n        if (numBits === 0)\n            return this;\n        else {\n            const high = this.high;\n            if (numBits < 32) {\n                const low = this.low;\n                return Long.fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\n            }\n            else if (numBits === 32)\n                return Long.fromBits(high, 0, this.unsigned);\n            else\n                return Long.fromBits(high >>> (numBits - 32), 0, this.unsigned);\n        }\n    }\n    shr_u(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    shru(numBits) {\n        return this.shiftRightUnsigned(numBits);\n    }\n    subtract(subtrahend) {\n        if (!Long.isLong(subtrahend))\n            subtrahend = Long.fromValue(subtrahend);\n        return this.add(subtrahend.neg());\n    }\n    sub(subtrahend) {\n        return this.subtract(subtrahend);\n    }\n    toInt() {\n        return this.unsigned ? this.low >>> 0 : this.low;\n    }\n    toNumber() {\n        if (this.unsigned)\n            return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);\n        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\n    }\n    toBigInt() {\n        return BigInt(this.toString());\n    }\n    toBytes(le) {\n        return le ? this.toBytesLE() : this.toBytesBE();\n    }\n    toBytesLE() {\n        const hi = this.high, lo = this.low;\n        return [\n            lo & 0xff,\n            (lo >>> 8) & 0xff,\n            (lo >>> 16) & 0xff,\n            lo >>> 24,\n            hi & 0xff,\n            (hi >>> 8) & 0xff,\n            (hi >>> 16) & 0xff,\n            hi >>> 24\n        ];\n    }\n    toBytesBE() {\n        const hi = this.high, lo = this.low;\n        return [\n            hi >>> 24,\n            (hi >>> 16) & 0xff,\n            (hi >>> 8) & 0xff,\n            hi & 0xff,\n            lo >>> 24,\n            (lo >>> 16) & 0xff,\n            (lo >>> 8) & 0xff,\n            lo & 0xff\n        ];\n    }\n    toSigned() {\n        if (!this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, false);\n    }\n    toString(radix) {\n        radix = radix || 10;\n        if (radix < 2 || 36 < radix)\n            throw new BSONError('radix');\n        if (this.isZero())\n            return '0';\n        if (this.isNegative()) {\n            if (this.eq(Long.MIN_VALUE)) {\n                const radixLong = Long.fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);\n                return div.toString(radix) + rem1.toInt().toString(radix);\n            }\n            else\n                return '-' + this.neg().toString(radix);\n        }\n        const radixToPower = Long.fromNumber(Math.pow(radix, 6), this.unsigned);\n        let rem = this;\n        let result = '';\n        while (true) {\n            const remDiv = rem.div(radixToPower);\n            const intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0;\n            let digits = intval.toString(radix);\n            rem = remDiv;\n            if (rem.isZero()) {\n                return digits + result;\n            }\n            else {\n                while (digits.length < 6)\n                    digits = '0' + digits;\n                result = '' + digits + result;\n            }\n        }\n    }\n    toUnsigned() {\n        if (this.unsigned)\n            return this;\n        return Long.fromBits(this.low, this.high, true);\n    }\n    xor(other) {\n        if (!Long.isLong(other))\n            other = Long.fromValue(other);\n        return Long.fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\n    }\n    eqz() {\n        return this.isZero();\n    }\n    le(other) {\n        return this.lessThanOrEqual(other);\n    }\n    toExtendedJSON(options) {\n        if (options && options.relaxed)\n            return this.toNumber();\n        return { $numberLong: this.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        const { useBigInt64 = false, relaxed = true } = { ...options };\n        if (doc.$numberLong.length > MAX_INT64_STRING_LENGTH) {\n            throw new BSONError('$numberLong string is too long');\n        }\n        if (!DECIMAL_REG_EX.test(doc.$numberLong)) {\n            throw new BSONError(`$numberLong string \"${doc.$numberLong}\" is in an invalid format`);\n        }\n        if (useBigInt64) {\n            const bigIntResult = BigInt(doc.$numberLong);\n            return BigInt.asIntN(64, bigIntResult);\n        }\n        const longResult = Long.fromString(doc.$numberLong);\n        if (relaxed) {\n            return longResult.toNumber();\n        }\n        return longResult;\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Long(\"${this.toString()}\"${this.unsigned ? ', true' : ''})`;\n    }\n}\nLong.TWO_PWR_24 = Long.fromInt(TWO_PWR_24_DBL);\nLong.MAX_UNSIGNED_VALUE = Long.fromBits(0xffffffff | 0, 0xffffffff | 0, true);\nLong.ZERO = Long.fromInt(0);\nLong.UZERO = Long.fromInt(0, true);\nLong.ONE = Long.fromInt(1);\nLong.UONE = Long.fromInt(1, true);\nLong.NEG_ONE = Long.fromInt(-1);\nLong.MAX_VALUE = Long.fromBits(0xffffffff | 0, 0x7fffffff | 0, false);\nLong.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0, false);\n\nconst PARSE_STRING_REGEXP = /^(\\+|-)?(\\d+|(\\d*\\.\\d*))?(E|e)?([-+])?(\\d+)?$/;\nconst PARSE_INF_REGEXP = /^(\\+|-)?(Infinity|inf)$/i;\nconst PARSE_NAN_REGEXP = /^(\\+|-)?NaN$/i;\nconst EXPONENT_MAX = 6111;\nconst EXPONENT_MIN = -6176;\nconst EXPONENT_BIAS = 6176;\nconst MAX_DIGITS = 34;\nconst NAN_BUFFER = ByteUtils.fromNumberArray([\n    0x7c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_NEGATIVE_BUFFER = ByteUtils.fromNumberArray([\n    0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst INF_POSITIVE_BUFFER = ByteUtils.fromNumberArray([\n    0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00\n].reverse());\nconst EXPONENT_REGEX = /^([-+])?(\\d+)?$/;\nconst COMBINATION_MASK = 0x1f;\nconst EXPONENT_MASK = 0x3fff;\nconst COMBINATION_INFINITY = 30;\nconst COMBINATION_NAN = 31;\nfunction isDigit(value) {\n    return !isNaN(parseInt(value, 10));\n}\nfunction divideu128(value) {\n    const DIVISOR = Long.fromNumber(1000 * 1000 * 1000);\n    let _rem = Long.fromNumber(0);\n    if (!value.parts[0] && !value.parts[1] && !value.parts[2] && !value.parts[3]) {\n        return { quotient: value, rem: _rem };\n    }\n    for (let i = 0; i <= 3; i++) {\n        _rem = _rem.shiftLeft(32);\n        _rem = _rem.add(new Long(value.parts[i], 0));\n        value.parts[i] = _rem.div(DIVISOR).low;\n        _rem = _rem.modulo(DIVISOR);\n    }\n    return { quotient: value, rem: _rem };\n}\nfunction multiply64x2(left, right) {\n    if (!left && !right) {\n        return { high: Long.fromNumber(0), low: Long.fromNumber(0) };\n    }\n    const leftHigh = left.shiftRightUnsigned(32);\n    const leftLow = new Long(left.getLowBits(), 0);\n    const rightHigh = right.shiftRightUnsigned(32);\n    const rightLow = new Long(right.getLowBits(), 0);\n    let productHigh = leftHigh.multiply(rightHigh);\n    let productMid = leftHigh.multiply(rightLow);\n    const productMid2 = leftLow.multiply(rightHigh);\n    let productLow = leftLow.multiply(rightLow);\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productMid = new Long(productMid.getLowBits(), 0)\n        .add(productMid2)\n        .add(productLow.shiftRightUnsigned(32));\n    productHigh = productHigh.add(productMid.shiftRightUnsigned(32));\n    productLow = productMid.shiftLeft(32).add(new Long(productLow.getLowBits(), 0));\n    return { high: productHigh, low: productLow };\n}\nfunction lessThan(left, right) {\n    const uhleft = left.high >>> 0;\n    const uhright = right.high >>> 0;\n    if (uhleft < uhright) {\n        return true;\n    }\n    else if (uhleft === uhright) {\n        const ulleft = left.low >>> 0;\n        const ulright = right.low >>> 0;\n        if (ulleft < ulright)\n            return true;\n    }\n    return false;\n}\nfunction invalidErr(string, message) {\n    throw new BSONError(`\"${string}\" is not a valid Decimal128 string - ${message}`);\n}\nclass Decimal128 extends BSONValue {\n    get _bsontype() {\n        return 'Decimal128';\n    }\n    constructor(bytes) {\n        super();\n        if (typeof bytes === 'string') {\n            this.bytes = Decimal128.fromString(bytes).bytes;\n        }\n        else if (isUint8Array(bytes)) {\n            if (bytes.byteLength !== 16) {\n                throw new BSONError('Decimal128 must take a Buffer of 16 bytes');\n            }\n            this.bytes = bytes;\n        }\n        else {\n            throw new BSONError('Decimal128 must take a Buffer or string');\n        }\n    }\n    static fromString(representation) {\n        let isNegative = false;\n        let sawRadix = false;\n        let foundNonZero = false;\n        let significantDigits = 0;\n        let nDigitsRead = 0;\n        let nDigits = 0;\n        let radixPosition = 0;\n        let firstNonZero = 0;\n        const digits = [0];\n        let nDigitsStored = 0;\n        let digitsInsert = 0;\n        let firstDigit = 0;\n        let lastDigit = 0;\n        let exponent = 0;\n        let i = 0;\n        let significandHigh = new Long(0, 0);\n        let significandLow = new Long(0, 0);\n        let biasedExponent = 0;\n        let index = 0;\n        if (representation.length >= 7000) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        const stringMatch = representation.match(PARSE_STRING_REGEXP);\n        const infMatch = representation.match(PARSE_INF_REGEXP);\n        const nanMatch = representation.match(PARSE_NAN_REGEXP);\n        if ((!stringMatch && !infMatch && !nanMatch) || representation.length === 0) {\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        }\n        if (stringMatch) {\n            const unsignedNumber = stringMatch[2];\n            const e = stringMatch[4];\n            const expSign = stringMatch[5];\n            const expNumber = stringMatch[6];\n            if (e && expNumber === undefined)\n                invalidErr(representation, 'missing exponent power');\n            if (e && unsignedNumber === undefined)\n                invalidErr(representation, 'missing exponent base');\n            if (e === undefined && (expSign || expNumber)) {\n                invalidErr(representation, 'missing e before exponent');\n            }\n        }\n        if (representation[index] === '+' || representation[index] === '-') {\n            isNegative = representation[index++] === '-';\n        }\n        if (!isDigit(representation[index]) && representation[index] !== '.') {\n            if (representation[index] === 'i' || representation[index] === 'I') {\n                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n            }\n            else if (representation[index] === 'N') {\n                return new Decimal128(NAN_BUFFER);\n            }\n        }\n        while (isDigit(representation[index]) || representation[index] === '.') {\n            if (representation[index] === '.') {\n                if (sawRadix)\n                    invalidErr(representation, 'contains multiple periods');\n                sawRadix = true;\n                index = index + 1;\n                continue;\n            }\n            if (nDigitsStored < 34) {\n                if (representation[index] !== '0' || foundNonZero) {\n                    if (!foundNonZero) {\n                        firstNonZero = nDigitsRead;\n                    }\n                    foundNonZero = true;\n                    digits[digitsInsert++] = parseInt(representation[index], 10);\n                    nDigitsStored = nDigitsStored + 1;\n                }\n            }\n            if (foundNonZero)\n                nDigits = nDigits + 1;\n            if (sawRadix)\n                radixPosition = radixPosition + 1;\n            nDigitsRead = nDigitsRead + 1;\n            index = index + 1;\n        }\n        if (sawRadix && !nDigitsRead)\n            throw new BSONError('' + representation + ' not a valid Decimal128 string');\n        if (representation[index] === 'e' || representation[index] === 'E') {\n            const match = representation.substr(++index).match(EXPONENT_REGEX);\n            if (!match || !match[2])\n                return new Decimal128(NAN_BUFFER);\n            exponent = parseInt(match[0], 10);\n            index = index + match[0].length;\n        }\n        if (representation[index])\n            return new Decimal128(NAN_BUFFER);\n        firstDigit = 0;\n        if (!nDigitsStored) {\n            firstDigit = 0;\n            lastDigit = 0;\n            digits[0] = 0;\n            nDigits = 1;\n            nDigitsStored = 1;\n            significantDigits = 0;\n        }\n        else {\n            lastDigit = nDigitsStored - 1;\n            significantDigits = nDigits;\n            if (significantDigits !== 1) {\n                while (digits[firstNonZero + significantDigits - 1] === 0) {\n                    significantDigits = significantDigits - 1;\n                }\n            }\n        }\n        if (exponent <= radixPosition && radixPosition - exponent > 1 << 14) {\n            exponent = EXPONENT_MIN;\n        }\n        else {\n            exponent = exponent - radixPosition;\n        }\n        while (exponent > EXPONENT_MAX) {\n            lastDigit = lastDigit + 1;\n            if (lastDigit - firstDigit > MAX_DIGITS) {\n                const digitsString = digits.join('');\n                if (digitsString.match(/^0+$/)) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, 'overflow');\n            }\n            exponent = exponent - 1;\n        }\n        while (exponent < EXPONENT_MIN || nDigitsStored < nDigits) {\n            if (lastDigit === 0 && significantDigits < nDigitsStored) {\n                exponent = EXPONENT_MIN;\n                significantDigits = 0;\n                break;\n            }\n            if (nDigitsStored < nDigits) {\n                nDigits = nDigits - 1;\n            }\n            else {\n                lastDigit = lastDigit - 1;\n            }\n            if (exponent < EXPONENT_MAX) {\n                exponent = exponent + 1;\n            }\n            else {\n                const digitsString = digits.join('');\n                if (digitsString.match(/^0+$/)) {\n                    exponent = EXPONENT_MAX;\n                    break;\n                }\n                invalidErr(representation, 'overflow');\n            }\n        }\n        if (lastDigit - firstDigit + 1 < significantDigits) {\n            let endOfString = nDigitsRead;\n            if (sawRadix) {\n                firstNonZero = firstNonZero + 1;\n                endOfString = endOfString + 1;\n            }\n            if (isNegative) {\n                firstNonZero = firstNonZero + 1;\n                endOfString = endOfString + 1;\n            }\n            const roundDigit = parseInt(representation[firstNonZero + lastDigit + 1], 10);\n            let roundBit = 0;\n            if (roundDigit >= 5) {\n                roundBit = 1;\n                if (roundDigit === 5) {\n                    roundBit = digits[lastDigit] % 2 === 1 ? 1 : 0;\n                    for (i = firstNonZero + lastDigit + 2; i < endOfString; i++) {\n                        if (parseInt(representation[i], 10)) {\n                            roundBit = 1;\n                            break;\n                        }\n                    }\n                }\n            }\n            if (roundBit) {\n                let dIdx = lastDigit;\n                for (; dIdx >= 0; dIdx--) {\n                    if (++digits[dIdx] > 9) {\n                        digits[dIdx] = 0;\n                        if (dIdx === 0) {\n                            if (exponent < EXPONENT_MAX) {\n                                exponent = exponent + 1;\n                                digits[dIdx] = 1;\n                            }\n                            else {\n                                return new Decimal128(isNegative ? INF_NEGATIVE_BUFFER : INF_POSITIVE_BUFFER);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        significandHigh = Long.fromNumber(0);\n        significandLow = Long.fromNumber(0);\n        if (significantDigits === 0) {\n            significandHigh = Long.fromNumber(0);\n            significandLow = Long.fromNumber(0);\n        }\n        else if (lastDigit - firstDigit < 17) {\n            let dIdx = firstDigit;\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            significandHigh = new Long(0, 0);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        else {\n            let dIdx = firstDigit;\n            significandHigh = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit - 17; dIdx++) {\n                significandHigh = significandHigh.multiply(Long.fromNumber(10));\n                significandHigh = significandHigh.add(Long.fromNumber(digits[dIdx]));\n            }\n            significandLow = Long.fromNumber(digits[dIdx++]);\n            for (; dIdx <= lastDigit; dIdx++) {\n                significandLow = significandLow.multiply(Long.fromNumber(10));\n                significandLow = significandLow.add(Long.fromNumber(digits[dIdx]));\n            }\n        }\n        const significand = multiply64x2(significandHigh, Long.fromString('100000000000000000'));\n        significand.low = significand.low.add(significandLow);\n        if (lessThan(significand.low, significandLow)) {\n            significand.high = significand.high.add(Long.fromNumber(1));\n        }\n        biasedExponent = exponent + EXPONENT_BIAS;\n        const dec = { low: Long.fromNumber(0), high: Long.fromNumber(0) };\n        if (significand.high.shiftRightUnsigned(49).and(Long.fromNumber(1)).equals(Long.fromNumber(1))) {\n            dec.high = dec.high.or(Long.fromNumber(0x3).shiftLeft(61));\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent).and(Long.fromNumber(0x3fff).shiftLeft(47)));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x7fffffffffff)));\n        }\n        else {\n            dec.high = dec.high.or(Long.fromNumber(biasedExponent & 0x3fff).shiftLeft(49));\n            dec.high = dec.high.or(significand.high.and(Long.fromNumber(0x1ffffffffffff)));\n        }\n        dec.low = significand.low;\n        if (isNegative) {\n            dec.high = dec.high.or(Long.fromString('9223372036854775808'));\n        }\n        const buffer = ByteUtils.allocate(16);\n        index = 0;\n        buffer[index++] = dec.low.low & 0xff;\n        buffer[index++] = (dec.low.low >> 8) & 0xff;\n        buffer[index++] = (dec.low.low >> 16) & 0xff;\n        buffer[index++] = (dec.low.low >> 24) & 0xff;\n        buffer[index++] = dec.low.high & 0xff;\n        buffer[index++] = (dec.low.high >> 8) & 0xff;\n        buffer[index++] = (dec.low.high >> 16) & 0xff;\n        buffer[index++] = (dec.low.high >> 24) & 0xff;\n        buffer[index++] = dec.high.low & 0xff;\n        buffer[index++] = (dec.high.low >> 8) & 0xff;\n        buffer[index++] = (dec.high.low >> 16) & 0xff;\n        buffer[index++] = (dec.high.low >> 24) & 0xff;\n        buffer[index++] = dec.high.high & 0xff;\n        buffer[index++] = (dec.high.high >> 8) & 0xff;\n        buffer[index++] = (dec.high.high >> 16) & 0xff;\n        buffer[index++] = (dec.high.high >> 24) & 0xff;\n        return new Decimal128(buffer);\n    }\n    toString() {\n        let biased_exponent;\n        let significand_digits = 0;\n        const significand = new Array(36);\n        for (let i = 0; i < significand.length; i++)\n            significand[i] = 0;\n        let index = 0;\n        let is_zero = false;\n        let significand_msb;\n        let significand128 = { parts: [0, 0, 0, 0] };\n        let j, k;\n        const string = [];\n        index = 0;\n        const buffer = this.bytes;\n        const low = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midl = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const midh = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        const high = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n        index = 0;\n        const dec = {\n            low: new Long(low, midl),\n            high: new Long(midh, high)\n        };\n        if (dec.high.lessThan(Long.ZERO)) {\n            string.push('-');\n        }\n        const combination = (high >> 26) & COMBINATION_MASK;\n        if (combination >> 3 === 3) {\n            if (combination === COMBINATION_INFINITY) {\n                return string.join('') + 'Infinity';\n            }\n            else if (combination === COMBINATION_NAN) {\n                return 'NaN';\n            }\n            else {\n                biased_exponent = (high >> 15) & EXPONENT_MASK;\n                significand_msb = 0x08 + ((high >> 14) & 0x01);\n            }\n        }\n        else {\n            significand_msb = (high >> 14) & 0x07;\n            biased_exponent = (high >> 17) & EXPONENT_MASK;\n        }\n        const exponent = biased_exponent - EXPONENT_BIAS;\n        significand128.parts[0] = (high & 0x3fff) + ((significand_msb & 0xf) << 14);\n        significand128.parts[1] = midh;\n        significand128.parts[2] = midl;\n        significand128.parts[3] = low;\n        if (significand128.parts[0] === 0 &&\n            significand128.parts[1] === 0 &&\n            significand128.parts[2] === 0 &&\n            significand128.parts[3] === 0) {\n            is_zero = true;\n        }\n        else {\n            for (k = 3; k >= 0; k--) {\n                let least_digits = 0;\n                const result = divideu128(significand128);\n                significand128 = result.quotient;\n                least_digits = result.rem.low;\n                if (!least_digits)\n                    continue;\n                for (j = 8; j >= 0; j--) {\n                    significand[k * 9 + j] = least_digits % 10;\n                    least_digits = Math.floor(least_digits / 10);\n                }\n            }\n        }\n        if (is_zero) {\n            significand_digits = 1;\n            significand[index] = 0;\n        }\n        else {\n            significand_digits = 36;\n            while (!significand[index]) {\n                significand_digits = significand_digits - 1;\n                index = index + 1;\n            }\n        }\n        const scientific_exponent = significand_digits - 1 + exponent;\n        if (scientific_exponent >= 34 || scientific_exponent <= -7 || exponent > 0) {\n            if (significand_digits > 34) {\n                string.push(`${0}`);\n                if (exponent > 0)\n                    string.push(`E+${exponent}`);\n                else if (exponent < 0)\n                    string.push(`E${exponent}`);\n                return string.join('');\n            }\n            string.push(`${significand[index++]}`);\n            significand_digits = significand_digits - 1;\n            if (significand_digits) {\n                string.push('.');\n            }\n            for (let i = 0; i < significand_digits; i++) {\n                string.push(`${significand[index++]}`);\n            }\n            string.push('E');\n            if (scientific_exponent > 0) {\n                string.push(`+${scientific_exponent}`);\n            }\n            else {\n                string.push(`${scientific_exponent}`);\n            }\n        }\n        else {\n            if (exponent >= 0) {\n                for (let i = 0; i < significand_digits; i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n            else {\n                let radix_position = significand_digits + exponent;\n                if (radix_position > 0) {\n                    for (let i = 0; i < radix_position; i++) {\n                        string.push(`${significand[index++]}`);\n                    }\n                }\n                else {\n                    string.push('0');\n                }\n                string.push('.');\n                while (radix_position++ < 0) {\n                    string.push('0');\n                }\n                for (let i = 0; i < significand_digits - Math.max(radix_position - 1, 0); i++) {\n                    string.push(`${significand[index++]}`);\n                }\n            }\n        }\n        return string.join('');\n    }\n    toJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    toExtendedJSON() {\n        return { $numberDecimal: this.toString() };\n    }\n    static fromExtendedJSON(doc) {\n        return Decimal128.fromString(doc.$numberDecimal);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Decimal128(\"${this.toString()}\")`;\n    }\n}\n\nclass Double extends BSONValue {\n    get _bsontype() {\n        return 'Double';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toExtendedJSON(options) {\n        if (options && (options.legacy || (options.relaxed && isFinite(this.value)))) {\n            return this.value;\n        }\n        if (Object.is(Math.sign(this.value), -0)) {\n            return { $numberDouble: '-0.0' };\n        }\n        return {\n            $numberDouble: Number.isInteger(this.value) ? this.value.toFixed(1) : this.value.toString()\n        };\n    }\n    static fromExtendedJSON(doc, options) {\n        const doubleValue = parseFloat(doc.$numberDouble);\n        return options && options.relaxed ? doubleValue : new Double(doubleValue);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        const eJSON = this.toExtendedJSON();\n        return `new Double(${eJSON.$numberDouble})`;\n    }\n}\n\nclass Int32 extends BSONValue {\n    get _bsontype() {\n        return 'Int32';\n    }\n    constructor(value) {\n        super();\n        if (value instanceof Number) {\n            value = value.valueOf();\n        }\n        this.value = +value | 0;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString(radix) {\n        return this.value.toString(radix);\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON(options) {\n        if (options && (options.relaxed || options.legacy))\n            return this.value;\n        return { $numberInt: this.value.toString() };\n    }\n    static fromExtendedJSON(doc, options) {\n        return options && options.relaxed ? parseInt(doc.$numberInt, 10) : new Int32(doc.$numberInt);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Int32(${this.valueOf()})`;\n    }\n}\n\nclass MaxKey extends BSONValue {\n    get _bsontype() {\n        return 'MaxKey';\n    }\n    toExtendedJSON() {\n        return { $maxKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MaxKey();\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return 'new MaxKey()';\n    }\n}\n\nclass MinKey extends BSONValue {\n    get _bsontype() {\n        return 'MinKey';\n    }\n    toExtendedJSON() {\n        return { $minKey: 1 };\n    }\n    static fromExtendedJSON() {\n        return new MinKey();\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return 'new MinKey()';\n    }\n}\n\nconst checkForHexRegExp = new RegExp('^[0-9a-fA-F]{24}$');\nlet PROCESS_UNIQUE = null;\nconst kId = Symbol('id');\nclass ObjectId extends BSONValue {\n    get _bsontype() {\n        return 'ObjectId';\n    }\n    constructor(inputId) {\n        super();\n        let workingId;\n        if (typeof inputId === 'object' && inputId && 'id' in inputId) {\n            if (typeof inputId.id !== 'string' && !ArrayBuffer.isView(inputId.id)) {\n                throw new BSONError('Argument passed in must have an id that is of type string or Buffer');\n            }\n            if ('toHexString' in inputId && typeof inputId.toHexString === 'function') {\n                workingId = ByteUtils.fromHex(inputId.toHexString());\n            }\n            else {\n                workingId = inputId.id;\n            }\n        }\n        else {\n            workingId = inputId;\n        }\n        if (workingId == null || typeof workingId === 'number') {\n            this[kId] = ObjectId.generate(typeof workingId === 'number' ? workingId : undefined);\n        }\n        else if (ArrayBuffer.isView(workingId) && workingId.byteLength === 12) {\n            this[kId] = ByteUtils.toLocalBufferType(workingId);\n        }\n        else if (typeof workingId === 'string') {\n            if (workingId.length === 12) {\n                const bytes = ByteUtils.fromUTF8(workingId);\n                if (bytes.byteLength === 12) {\n                    this[kId] = bytes;\n                }\n                else {\n                    throw new BSONError('Argument passed in must be a string of 12 bytes');\n                }\n            }\n            else if (workingId.length === 24 && checkForHexRegExp.test(workingId)) {\n                this[kId] = ByteUtils.fromHex(workingId);\n            }\n            else {\n                throw new BSONError('Argument passed in must be a string of 12 bytes or a string of 24 hex characters or an integer');\n            }\n        }\n        else {\n            throw new BSONError('Argument passed in does not match the accepted types');\n        }\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(this.id);\n        }\n    }\n    get id() {\n        return this[kId];\n    }\n    set id(value) {\n        this[kId] = value;\n        if (ObjectId.cacheHexString) {\n            this.__id = ByteUtils.toHex(value);\n        }\n    }\n    toHexString() {\n        if (ObjectId.cacheHexString && this.__id) {\n            return this.__id;\n        }\n        const hexString = ByteUtils.toHex(this.id);\n        if (ObjectId.cacheHexString && !this.__id) {\n            this.__id = hexString;\n        }\n        return hexString;\n    }\n    static getInc() {\n        return (ObjectId.index = (ObjectId.index + 1) % 0xffffff);\n    }\n    static generate(time) {\n        if ('number' !== typeof time) {\n            time = Math.floor(Date.now() / 1000);\n        }\n        const inc = ObjectId.getInc();\n        const buffer = ByteUtils.allocate(12);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        if (PROCESS_UNIQUE === null) {\n            PROCESS_UNIQUE = ByteUtils.randomBytes(5);\n        }\n        buffer[4] = PROCESS_UNIQUE[0];\n        buffer[5] = PROCESS_UNIQUE[1];\n        buffer[6] = PROCESS_UNIQUE[2];\n        buffer[7] = PROCESS_UNIQUE[3];\n        buffer[8] = PROCESS_UNIQUE[4];\n        buffer[11] = inc & 0xff;\n        buffer[10] = (inc >> 8) & 0xff;\n        buffer[9] = (inc >> 16) & 0xff;\n        return buffer;\n    }\n    toString(encoding) {\n        if (encoding === 'base64')\n            return ByteUtils.toBase64(this.id);\n        if (encoding === 'hex')\n            return this.toHexString();\n        return this.toHexString();\n    }\n    toJSON() {\n        return this.toHexString();\n    }\n    equals(otherId) {\n        if (otherId === undefined || otherId === null) {\n            return false;\n        }\n        if (otherId instanceof ObjectId) {\n            return this[kId][11] === otherId[kId][11] && ByteUtils.equals(this[kId], otherId[kId]);\n        }\n        if (typeof otherId === 'string' &&\n            ObjectId.isValid(otherId) &&\n            otherId.length === 12 &&\n            isUint8Array(this.id)) {\n            return ByteUtils.equals(this.id, ByteUtils.fromISO88591(otherId));\n        }\n        if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 24) {\n            return otherId.toLowerCase() === this.toHexString();\n        }\n        if (typeof otherId === 'string' && ObjectId.isValid(otherId) && otherId.length === 12) {\n            return ByteUtils.equals(ByteUtils.fromUTF8(otherId), this.id);\n        }\n        if (typeof otherId === 'object' &&\n            'toHexString' in otherId &&\n            typeof otherId.toHexString === 'function') {\n            const otherIdString = otherId.toHexString();\n            const thisIdString = this.toHexString().toLowerCase();\n            return typeof otherIdString === 'string' && otherIdString.toLowerCase() === thisIdString;\n        }\n        return false;\n    }\n    getTimestamp() {\n        const timestamp = new Date();\n        const time = BSONDataView.fromUint8Array(this.id).getUint32(0, false);\n        timestamp.setTime(Math.floor(time) * 1000);\n        return timestamp;\n    }\n    static createPk() {\n        return new ObjectId();\n    }\n    static createFromTime(time) {\n        const buffer = ByteUtils.fromNumberArray([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\n        BSONDataView.fromUint8Array(buffer).setUint32(0, time, false);\n        return new ObjectId(buffer);\n    }\n    static createFromHexString(hexString) {\n        if (hexString?.length !== 24) {\n            throw new BSONError('hex string must be 24 characters');\n        }\n        return new ObjectId(ByteUtils.fromHex(hexString));\n    }\n    static createFromBase64(base64) {\n        if (base64?.length !== 16) {\n            throw new BSONError('base64 string must be 16 characters');\n        }\n        return new ObjectId(ByteUtils.fromBase64(base64));\n    }\n    static isValid(id) {\n        if (id == null)\n            return false;\n        try {\n            new ObjectId(id);\n            return true;\n        }\n        catch {\n            return false;\n        }\n    }\n    toExtendedJSON() {\n        if (this.toHexString)\n            return { $oid: this.toHexString() };\n        return { $oid: this.toString('hex') };\n    }\n    static fromExtendedJSON(doc) {\n        return new ObjectId(doc.$oid);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new ObjectId(\"${this.toHexString()}\")`;\n    }\n}\nObjectId.index = Math.floor(Math.random() * 0xffffff);\n\nfunction internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined) {\n    let totalLength = 4 + 1;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            totalLength += calculateElement(i.toString(), object[i], serializeFunctions, true, ignoreUndefined);\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n        }\n        for (const key of Object.keys(object)) {\n            totalLength += calculateElement(key, object[key], serializeFunctions, false, ignoreUndefined);\n        }\n    }\n    return totalLength;\n}\nfunction calculateElement(name, value, serializeFunctions = false, isArray = false, ignoreUndefined = false) {\n    if (typeof value?.toBSON === 'function') {\n        value = value.toBSON();\n    }\n    switch (typeof value) {\n        case 'string':\n            return 1 + ByteUtils.utf8ByteLength(name) + 1 + 4 + ByteUtils.utf8ByteLength(value) + 1;\n        case 'number':\n            if (Math.floor(value) === value &&\n                value >= JS_INT_MIN &&\n                value <= JS_INT_MAX) {\n                if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (4 + 1);\n                }\n                else {\n                    return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n                }\n            }\n            else {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n        case 'undefined':\n            if (isArray || !ignoreUndefined)\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            return 0;\n        case 'boolean':\n            return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 1);\n        case 'object':\n            if (value != null &&\n                typeof value._bsontype === 'string' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value == null || value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + 1;\n            }\n            else if (value._bsontype === 'ObjectId') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (12 + 1);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (ArrayBuffer.isView(value) ||\n                value instanceof ArrayBuffer ||\n                isAnyArrayBuffer(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (1 + 4 + 1) + value.byteLength);\n            }\n            else if (value._bsontype === 'Long' ||\n                value._bsontype === 'Double' ||\n                value._bsontype === 'Timestamp') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (8 + 1);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                return (name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (16 + 1);\n            }\n            else if (value._bsontype === 'Code') {\n                if (value.scope != null && Object.keys(value.scope).length > 0) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1 +\n                        internalCalculateObjectSize(value.scope, serializeFunctions, ignoreUndefined));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        1 +\n                        4 +\n                        ByteUtils.utf8ByteLength(value.code.toString()) +\n                        1);\n                }\n            }\n            else if (value._bsontype === 'Binary') {\n                const binary = value;\n                if (binary.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                        (binary.position + 1 + 4 + 1 + 4));\n                }\n                else {\n                    return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) + (binary.position + 1 + 4 + 1));\n                }\n            }\n            else if (value._bsontype === 'Symbol') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    ByteUtils.utf8ByteLength(value.value) +\n                    4 +\n                    1 +\n                    1);\n            }\n            else if (value._bsontype === 'DBRef') {\n                const ordered_values = Object.assign({\n                    $ref: value.collection,\n                    $id: value.oid\n                }, value.fields);\n                if (value.db != null) {\n                    ordered_values['$db'] = value.db;\n                }\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    internalCalculateObjectSize(ordered_values, serializeFunctions, ignoreUndefined));\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.source) +\n                    1 +\n                    (value.global ? 1 : 0) +\n                    (value.ignoreCase ? 1 : 0) +\n                    (value.multiline ? 1 : 0) +\n                    1);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.pattern) +\n                    1 +\n                    ByteUtils.utf8ByteLength(value.options) +\n                    1);\n            }\n            else {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    internalCalculateObjectSize(value, serializeFunctions, ignoreUndefined) +\n                    1);\n            }\n        case 'function':\n            if (serializeFunctions) {\n                return ((name != null ? ByteUtils.utf8ByteLength(name) + 1 : 0) +\n                    1 +\n                    4 +\n                    ByteUtils.utf8ByteLength(value.toString()) +\n                    1);\n            }\n    }\n    return 0;\n}\n\nfunction alphabetize(str) {\n    return str.split('').sort().join('');\n}\nclass BSONRegExp extends BSONValue {\n    get _bsontype() {\n        return 'BSONRegExp';\n    }\n    constructor(pattern, options) {\n        super();\n        this.pattern = pattern;\n        this.options = alphabetize(options ?? '');\n        if (this.pattern.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex patterns cannot contain null bytes, found: ${JSON.stringify(this.pattern)}`);\n        }\n        if (this.options.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Regex options cannot contain null bytes, found: ${JSON.stringify(this.options)}`);\n        }\n        for (let i = 0; i < this.options.length; i++) {\n            if (!(this.options[i] === 'i' ||\n                this.options[i] === 'm' ||\n                this.options[i] === 'x' ||\n                this.options[i] === 'l' ||\n                this.options[i] === 's' ||\n                this.options[i] === 'u')) {\n                throw new BSONError(`The regular expression option [${this.options[i]}] is not supported`);\n            }\n        }\n    }\n    static parseOptions(options) {\n        return options ? options.split('').sort().join('') : '';\n    }\n    toExtendedJSON(options) {\n        options = options || {};\n        if (options.legacy) {\n            return { $regex: this.pattern, $options: this.options };\n        }\n        return { $regularExpression: { pattern: this.pattern, options: this.options } };\n    }\n    static fromExtendedJSON(doc) {\n        if ('$regex' in doc) {\n            if (typeof doc.$regex !== 'string') {\n                if (doc.$regex._bsontype === 'BSONRegExp') {\n                    return doc;\n                }\n            }\n            else {\n                return new BSONRegExp(doc.$regex, BSONRegExp.parseOptions(doc.$options));\n            }\n        }\n        if ('$regularExpression' in doc) {\n            return new BSONRegExp(doc.$regularExpression.pattern, BSONRegExp.parseOptions(doc.$regularExpression.options));\n        }\n        throw new BSONError(`Unexpected BSONRegExp EJSON object form: ${JSON.stringify(doc)}`);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new BSONRegExp(${JSON.stringify(this.pattern)}, ${JSON.stringify(this.options)})`;\n    }\n}\n\nclass BSONSymbol extends BSONValue {\n    get _bsontype() {\n        return 'BSONSymbol';\n    }\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    valueOf() {\n        return this.value;\n    }\n    toString() {\n        return this.value;\n    }\n    inspect() {\n        return `new BSONSymbol(\"${this.value}\")`;\n    }\n    toJSON() {\n        return this.value;\n    }\n    toExtendedJSON() {\n        return { $symbol: this.value };\n    }\n    static fromExtendedJSON(doc) {\n        return new BSONSymbol(doc.$symbol);\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n}\n\nconst LongWithoutOverridesClass = Long;\nclass Timestamp extends LongWithoutOverridesClass {\n    get _bsontype() {\n        return 'Timestamp';\n    }\n    constructor(low) {\n        if (low == null) {\n            super(0, 0, true);\n        }\n        else if (typeof low === 'bigint') {\n            super(low, true);\n        }\n        else if (Long.isLong(low)) {\n            super(low.low, low.high, true);\n        }\n        else if (typeof low === 'object' && 't' in low && 'i' in low) {\n            if (typeof low.t !== 'number' && (typeof low.t !== 'object' || low.t._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t as a number');\n            }\n            if (typeof low.i !== 'number' && (typeof low.i !== 'object' || low.i._bsontype !== 'Int32')) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i as a number');\n            }\n            if (low.t < 0) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive t');\n            }\n            if (low.i < 0) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide a positive i');\n            }\n            if (low.t > 4294967295) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide t equal or less than uint32 max');\n            }\n            if (low.i > 4294967295) {\n                throw new BSONError('Timestamp constructed from { t, i } must provide i equal or less than uint32 max');\n            }\n            super(low.i.valueOf(), low.t.valueOf(), true);\n        }\n        else {\n            throw new BSONError('A Timestamp can only be constructed with: bigint, Long, or { t: number; i: number }');\n        }\n    }\n    toJSON() {\n        return {\n            $timestamp: this.toString()\n        };\n    }\n    static fromInt(value) {\n        return new Timestamp(Long.fromInt(value, true));\n    }\n    static fromNumber(value) {\n        return new Timestamp(Long.fromNumber(value, true));\n    }\n    static fromBits(lowBits, highBits) {\n        return new Timestamp({ i: lowBits, t: highBits });\n    }\n    static fromString(str, optRadix) {\n        return new Timestamp(Long.fromString(str, true, optRadix));\n    }\n    toExtendedJSON() {\n        return { $timestamp: { t: this.high >>> 0, i: this.low >>> 0 } };\n    }\n    static fromExtendedJSON(doc) {\n        const i = Long.isLong(doc.$timestamp.i)\n            ? doc.$timestamp.i.getLowBitsUnsigned()\n            : doc.$timestamp.i;\n        const t = Long.isLong(doc.$timestamp.t)\n            ? doc.$timestamp.t.getLowBitsUnsigned()\n            : doc.$timestamp.t;\n        return new Timestamp({ t, i });\n    }\n    [Symbol.for('nodejs.util.inspect.custom')]() {\n        return this.inspect();\n    }\n    inspect() {\n        return `new Timestamp({ t: ${this.getHighBits()}, i: ${this.getLowBits()} })`;\n    }\n}\nTimestamp.MAX_VALUE = Long.MAX_UNSIGNED_VALUE;\n\nconst FIRST_BIT = 0x80;\nconst FIRST_TWO_BITS = 0xc0;\nconst FIRST_THREE_BITS = 0xe0;\nconst FIRST_FOUR_BITS = 0xf0;\nconst FIRST_FIVE_BITS = 0xf8;\nconst TWO_BIT_CHAR = 0xc0;\nconst THREE_BIT_CHAR = 0xe0;\nconst FOUR_BIT_CHAR = 0xf0;\nconst CONTINUING_CHAR = 0x80;\nfunction validateUtf8(bytes, start, end) {\n    let continuation = 0;\n    for (let i = start; i < end; i += 1) {\n        const byte = bytes[i];\n        if (continuation) {\n            if ((byte & FIRST_TWO_BITS) !== CONTINUING_CHAR) {\n                return false;\n            }\n            continuation -= 1;\n        }\n        else if (byte & FIRST_BIT) {\n            if ((byte & FIRST_THREE_BITS) === TWO_BIT_CHAR) {\n                continuation = 1;\n            }\n            else if ((byte & FIRST_FOUR_BITS) === THREE_BIT_CHAR) {\n                continuation = 2;\n            }\n            else if ((byte & FIRST_FIVE_BITS) === FOUR_BIT_CHAR) {\n                continuation = 3;\n            }\n            else {\n                return false;\n            }\n        }\n    }\n    return !continuation;\n}\n\nconst JS_INT_MAX_LONG = Long.fromNumber(JS_INT_MAX);\nconst JS_INT_MIN_LONG = Long.fromNumber(JS_INT_MIN);\nfunction internalDeserialize(buffer, options, isArray) {\n    options = options == null ? {} : options;\n    const index = options && options.index ? options.index : 0;\n    const size = buffer[index] |\n        (buffer[index + 1] << 8) |\n        (buffer[index + 2] << 16) |\n        (buffer[index + 3] << 24);\n    if (size < 5) {\n        throw new BSONError(`bson size must be >= 5, is ${size}`);\n    }\n    if (options.allowObjectSmallerThanBufferSize && buffer.length < size) {\n        throw new BSONError(`buffer length ${buffer.length} must be >= bson size ${size}`);\n    }\n    if (!options.allowObjectSmallerThanBufferSize && buffer.length !== size) {\n        throw new BSONError(`buffer length ${buffer.length} must === bson size ${size}`);\n    }\n    if (size + index > buffer.byteLength) {\n        throw new BSONError(`(bson size ${size} + options.index ${index} must be <= buffer length ${buffer.byteLength})`);\n    }\n    if (buffer[index + size - 1] !== 0) {\n        throw new BSONError(\"One object, sized correctly, with a spot for an EOO, but the EOO isn't 0x00\");\n    }\n    return deserializeObject(buffer, index, options, isArray);\n}\nconst allowedDBRefKeys = /^\\$ref$|^\\$id$|^\\$db$/;\nfunction deserializeObject(buffer, index, options, isArray = false) {\n    const fieldsAsRaw = options['fieldsAsRaw'] == null ? null : options['fieldsAsRaw'];\n    const raw = options['raw'] == null ? false : options['raw'];\n    const bsonRegExp = typeof options['bsonRegExp'] === 'boolean' ? options['bsonRegExp'] : false;\n    const promoteBuffers = options.promoteBuffers ?? false;\n    const promoteLongs = options.promoteLongs ?? true;\n    const promoteValues = options.promoteValues ?? true;\n    const useBigInt64 = options.useBigInt64 ?? false;\n    if (useBigInt64 && !promoteValues) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    if (useBigInt64 && !promoteLongs) {\n        throw new BSONError('Must either request bigint or Long for int64 deserialization');\n    }\n    const validation = options.validation == null ? { utf8: true } : options.validation;\n    let globalUTFValidation = true;\n    let validationSetting;\n    const utf8KeysSet = new Set();\n    const utf8ValidatedKeys = validation.utf8;\n    if (typeof utf8ValidatedKeys === 'boolean') {\n        validationSetting = utf8ValidatedKeys;\n    }\n    else {\n        globalUTFValidation = false;\n        const utf8ValidationValues = Object.keys(utf8ValidatedKeys).map(function (key) {\n            return utf8ValidatedKeys[key];\n        });\n        if (utf8ValidationValues.length === 0) {\n            throw new BSONError('UTF-8 validation setting cannot be empty');\n        }\n        if (typeof utf8ValidationValues[0] !== 'boolean') {\n            throw new BSONError('Invalid UTF-8 validation option, must specify boolean values');\n        }\n        validationSetting = utf8ValidationValues[0];\n        if (!utf8ValidationValues.every(item => item === validationSetting)) {\n            throw new BSONError('Invalid UTF-8 validation option - keys must be all true or all false');\n        }\n    }\n    if (!globalUTFValidation) {\n        for (const key of Object.keys(utf8ValidatedKeys)) {\n            utf8KeysSet.add(key);\n        }\n    }\n    const startIndex = index;\n    if (buffer.length < 5)\n        throw new BSONError('corrupt bson message < 5 bytes long');\n    const size = buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24);\n    if (size < 5 || size > buffer.length)\n        throw new BSONError('corrupt bson message');\n    const object = isArray ? [] : {};\n    let arrayIndex = 0;\n    const done = false;\n    let isPossibleDBRef = isArray ? false : null;\n    const dataview = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n    while (!done) {\n        const elementType = buffer[index++];\n        if (elementType === 0)\n            break;\n        let i = index;\n        while (buffer[i] !== 0x00 && i < buffer.length) {\n            i++;\n        }\n        if (i >= buffer.byteLength)\n            throw new BSONError('Bad BSON Document: illegal CString');\n        const name = isArray ? arrayIndex++ : ByteUtils.toUTF8(buffer.subarray(index, i));\n        let shouldValidateKey = true;\n        if (globalUTFValidation || utf8KeysSet.has(name)) {\n            shouldValidateKey = validationSetting;\n        }\n        else {\n            shouldValidateKey = !validationSetting;\n        }\n        if (isPossibleDBRef !== false && name[0] === '$') {\n            isPossibleDBRef = allowedDBRefKeys.test(name);\n        }\n        let value;\n        index = i + 1;\n        if (elementType === BSON_DATA_STRING) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            value = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_OID) {\n            const oid = ByteUtils.allocate(12);\n            oid.set(buffer.subarray(index, index + 12));\n            value = new ObjectId(oid);\n            index = index + 12;\n        }\n        else if (elementType === BSON_DATA_INT && promoteValues === false) {\n            value = new Int32(buffer[index++] | (buffer[index++] << 8) | (buffer[index++] << 16) | (buffer[index++] << 24));\n        }\n        else if (elementType === BSON_DATA_INT) {\n            value =\n                buffer[index++] |\n                    (buffer[index++] << 8) |\n                    (buffer[index++] << 16) |\n                    (buffer[index++] << 24);\n        }\n        else if (elementType === BSON_DATA_NUMBER && promoteValues === false) {\n            value = new Double(dataview.getFloat64(index, true));\n            index = index + 8;\n        }\n        else if (elementType === BSON_DATA_NUMBER) {\n            value = dataview.getFloat64(index, true);\n            index = index + 8;\n        }\n        else if (elementType === BSON_DATA_DATE) {\n            const lowBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const highBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            value = new Date(new Long(lowBits, highBits).toNumber());\n        }\n        else if (elementType === BSON_DATA_BOOLEAN) {\n            if (buffer[index] !== 0 && buffer[index] !== 1)\n                throw new BSONError('illegal boolean type value');\n            value = buffer[index++] === 1;\n        }\n        else if (elementType === BSON_DATA_OBJECT) {\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            if (objectSize <= 0 || objectSize > buffer.length - index)\n                throw new BSONError('bad embedded document length in bson');\n            if (raw) {\n                value = buffer.slice(index, index + objectSize);\n            }\n            else {\n                let objectOptions = options;\n                if (!globalUTFValidation) {\n                    objectOptions = { ...options, validation: { utf8: shouldValidateKey } };\n                }\n                value = deserializeObject(buffer, _index, objectOptions, false);\n            }\n            index = index + objectSize;\n        }\n        else if (elementType === BSON_DATA_ARRAY) {\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            let arrayOptions = options;\n            const stopIndex = index + objectSize;\n            if (fieldsAsRaw && fieldsAsRaw[name]) {\n                arrayOptions = { ...options, raw: true };\n            }\n            if (!globalUTFValidation) {\n                arrayOptions = { ...arrayOptions, validation: { utf8: shouldValidateKey } };\n            }\n            value = deserializeObject(buffer, _index, arrayOptions, true);\n            index = index + objectSize;\n            if (buffer[index - 1] !== 0)\n                throw new BSONError('invalid array terminator byte');\n            if (index !== stopIndex)\n                throw new BSONError('corrupted array bson');\n        }\n        else if (elementType === BSON_DATA_UNDEFINED) {\n            value = undefined;\n        }\n        else if (elementType === BSON_DATA_NULL) {\n            value = null;\n        }\n        else if (elementType === BSON_DATA_LONG) {\n            const dataview = BSONDataView.fromUint8Array(buffer.subarray(index, index + 8));\n            const lowBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const highBits = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const long = new Long(lowBits, highBits);\n            if (useBigInt64) {\n                value = dataview.getBigInt64(0, true);\n            }\n            else if (promoteLongs && promoteValues === true) {\n                value =\n                    long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG)\n                        ? long.toNumber()\n                        : long;\n            }\n            else {\n                value = long;\n            }\n        }\n        else if (elementType === BSON_DATA_DECIMAL128) {\n            const bytes = ByteUtils.allocate(16);\n            bytes.set(buffer.subarray(index, index + 16), 0);\n            index = index + 16;\n            value = new Decimal128(bytes);\n        }\n        else if (elementType === BSON_DATA_BINARY) {\n            let binarySize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            const totalBinarySize = binarySize;\n            const subType = buffer[index++];\n            if (binarySize < 0)\n                throw new BSONError('Negative binary type element size found');\n            if (binarySize > buffer.byteLength)\n                throw new BSONError('Binary type size larger than document size');\n            if (buffer['slice'] != null) {\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize =\n                        buffer[index++] |\n                            (buffer[index++] << 8) |\n                            (buffer[index++] << 16) |\n                            (buffer[index++] << 24);\n                    if (binarySize < 0)\n                        throw new BSONError('Negative binary type element size found for subtype 0x02');\n                    if (binarySize > totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                    if (binarySize < totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = ByteUtils.toLocalBufferType(buffer.slice(index, index + binarySize));\n                }\n                else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            else {\n                const _buffer = ByteUtils.allocate(binarySize);\n                if (subType === Binary.SUBTYPE_BYTE_ARRAY) {\n                    binarySize =\n                        buffer[index++] |\n                            (buffer[index++] << 8) |\n                            (buffer[index++] << 16) |\n                            (buffer[index++] << 24);\n                    if (binarySize < 0)\n                        throw new BSONError('Negative binary type element size found for subtype 0x02');\n                    if (binarySize > totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too long binary size');\n                    if (binarySize < totalBinarySize - 4)\n                        throw new BSONError('Binary type with subtype 0x02 contains too short binary size');\n                }\n                for (i = 0; i < binarySize; i++) {\n                    _buffer[i] = buffer[index + i];\n                }\n                if (promoteBuffers && promoteValues) {\n                    value = _buffer;\n                }\n                else {\n                    value = new Binary(buffer.slice(index, index + binarySize), subType);\n                    if (subType === BSON_BINARY_SUBTYPE_UUID_NEW && UUID.isValid(value)) {\n                        value = value.toUUID();\n                    }\n                }\n            }\n            index = index + binarySize;\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === false) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer.subarray(index, i));\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));\n            index = i + 1;\n            const optionsArray = new Array(regExpOptions.length);\n            for (i = 0; i < regExpOptions.length; i++) {\n                switch (regExpOptions[i]) {\n                    case 'm':\n                        optionsArray[i] = 'm';\n                        break;\n                    case 's':\n                        optionsArray[i] = 'g';\n                        break;\n                    case 'i':\n                        optionsArray[i] = 'i';\n                        break;\n                }\n            }\n            value = new RegExp(source, optionsArray.join(''));\n        }\n        else if (elementType === BSON_DATA_REGEXP && bsonRegExp === true) {\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const source = ByteUtils.toUTF8(buffer.subarray(index, i));\n            index = i + 1;\n            i = index;\n            while (buffer[i] !== 0x00 && i < buffer.length) {\n                i++;\n            }\n            if (i >= buffer.length)\n                throw new BSONError('Bad BSON Document: illegal CString');\n            const regExpOptions = ByteUtils.toUTF8(buffer.subarray(index, i));\n            index = i + 1;\n            value = new BSONRegExp(source, regExpOptions);\n        }\n        else if (elementType === BSON_DATA_SYMBOL) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const symbol = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = promoteValues ? symbol : new BSONSymbol(symbol);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_TIMESTAMP) {\n            const i = buffer[index++] +\n                buffer[index++] * (1 << 8) +\n                buffer[index++] * (1 << 16) +\n                buffer[index++] * (1 << 24);\n            const t = buffer[index++] +\n                buffer[index++] * (1 << 8) +\n                buffer[index++] * (1 << 16) +\n                buffer[index++] * (1 << 24);\n            value = new Timestamp({ i, t });\n        }\n        else if (elementType === BSON_DATA_MIN_KEY) {\n            value = new MinKey();\n        }\n        else if (elementType === BSON_DATA_MAX_KEY) {\n            value = new MaxKey();\n        }\n        else if (elementType === BSON_DATA_CODE) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            value = new Code(functionString);\n            index = index + stringSize;\n        }\n        else if (elementType === BSON_DATA_CODE_W_SCOPE) {\n            const totalSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (totalSize < 4 + 4 + 4 + 1) {\n                throw new BSONError('code_w_scope total size shorter minimum expected length');\n            }\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0) {\n                throw new BSONError('bad string length in bson');\n            }\n            const functionString = getValidatedString(buffer, index, index + stringSize - 1, shouldValidateKey);\n            index = index + stringSize;\n            const _index = index;\n            const objectSize = buffer[index] |\n                (buffer[index + 1] << 8) |\n                (buffer[index + 2] << 16) |\n                (buffer[index + 3] << 24);\n            const scopeObject = deserializeObject(buffer, _index, options, false);\n            index = index + objectSize;\n            if (totalSize < 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too short, truncating scope');\n            }\n            if (totalSize > 4 + 4 + objectSize + stringSize) {\n                throw new BSONError('code_w_scope total size is too long, clips outer document');\n            }\n            value = new Code(functionString, scopeObject);\n        }\n        else if (elementType === BSON_DATA_DBPOINTER) {\n            const stringSize = buffer[index++] |\n                (buffer[index++] << 8) |\n                (buffer[index++] << 16) |\n                (buffer[index++] << 24);\n            if (stringSize <= 0 ||\n                stringSize > buffer.length - index ||\n                buffer[index + stringSize - 1] !== 0)\n                throw new BSONError('bad string length in bson');\n            if (validation != null && validation.utf8) {\n                if (!validateUtf8(buffer, index, index + stringSize - 1)) {\n                    throw new BSONError('Invalid UTF-8 string in BSON document');\n                }\n            }\n            const namespace = ByteUtils.toUTF8(buffer.subarray(index, index + stringSize - 1));\n            index = index + stringSize;\n            const oidBuffer = ByteUtils.allocate(12);\n            oidBuffer.set(buffer.subarray(index, index + 12), 0);\n            const oid = new ObjectId(oidBuffer);\n            index = index + 12;\n            value = new DBRef(namespace, oid);\n        }\n        else {\n            throw new BSONError(`Detected unknown BSON type ${elementType.toString(16)} for fieldname \"${name}\"`);\n        }\n        if (name === '__proto__') {\n            Object.defineProperty(object, name, {\n                value,\n                writable: true,\n                enumerable: true,\n                configurable: true\n            });\n        }\n        else {\n            object[name] = value;\n        }\n    }\n    if (size !== index - startIndex) {\n        if (isArray)\n            throw new BSONError('corrupt array bson');\n        throw new BSONError('corrupt object bson');\n    }\n    if (!isPossibleDBRef)\n        return object;\n    if (isDBRefLike(object)) {\n        const copy = Object.assign({}, object);\n        delete copy.$ref;\n        delete copy.$id;\n        delete copy.$db;\n        return new DBRef(object.$ref, object.$id, object.$db, copy);\n    }\n    return object;\n}\nfunction getValidatedString(buffer, start, end, shouldValidateUtf8) {\n    const value = ByteUtils.toUTF8(buffer.subarray(start, end));\n    if (shouldValidateUtf8) {\n        for (let i = 0; i < value.length; i++) {\n            if (value.charCodeAt(i) === 0xfffd) {\n                if (!validateUtf8(buffer, start, end)) {\n                    throw new BSONError('Invalid UTF-8 string in BSON document');\n                }\n                break;\n            }\n        }\n    }\n    return value;\n}\n\nconst regexp = /\\x00/;\nconst ignoreKeys = new Set(['$db', '$ref', '$id', '$clusterTime']);\nfunction serializeString(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_STRING;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes + 1;\n    buffer[index - 1] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value, index + 4);\n    buffer[index + 3] = ((size + 1) >> 24) & 0xff;\n    buffer[index + 2] = ((size + 1) >> 16) & 0xff;\n    buffer[index + 1] = ((size + 1) >> 8) & 0xff;\n    buffer[index] = (size + 1) & 0xff;\n    index = index + 4 + size;\n    buffer[index++] = 0;\n    return index;\n}\nconst NUMBER_SPACE = new DataView(new ArrayBuffer(8), 0, 8);\nconst FOUR_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 4);\nconst EIGHT_BYTE_VIEW_ON_NUMBER = new Uint8Array(NUMBER_SPACE.buffer, 0, 8);\nfunction serializeNumber(buffer, key, value, index) {\n    const isNegativeZero = Object.is(value, -0);\n    const type = !isNegativeZero &&\n        Number.isSafeInteger(value) &&\n        value <= BSON_INT32_MAX &&\n        value >= BSON_INT32_MIN\n        ? BSON_DATA_INT\n        : BSON_DATA_NUMBER;\n    if (type === BSON_DATA_INT) {\n        NUMBER_SPACE.setInt32(0, value, true);\n    }\n    else {\n        NUMBER_SPACE.setFloat64(0, value, true);\n    }\n    const bytes = type === BSON_DATA_INT ? FOUR_BYTE_VIEW_ON_NUMBER : EIGHT_BYTE_VIEW_ON_NUMBER;\n    buffer[index++] = type;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0x00;\n    buffer.set(bytes, index);\n    index += bytes.byteLength;\n    return index;\n}\nfunction serializeBigInt(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_LONG;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index += numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setBigInt64(0, value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index += EIGHT_BYTE_VIEW_ON_NUMBER.byteLength;\n    return index;\n}\nfunction serializeNull(buffer, key, _, index) {\n    buffer[index++] = BSON_DATA_NULL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeBoolean(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BOOLEAN;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value ? 1 : 0;\n    return index;\n}\nfunction serializeDate(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DATE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const dateInMilis = Long.fromNumber(value.getTime());\n    const lowBits = dateInMilis.getLowBits();\n    const highBits = dateInMilis.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = (lowBits >> 8) & 0xff;\n    buffer[index++] = (lowBits >> 16) & 0xff;\n    buffer[index++] = (lowBits >> 24) & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = (highBits >> 8) & 0xff;\n    buffer[index++] = (highBits >> 16) & 0xff;\n    buffer[index++] = (highBits >> 24) & 0xff;\n    return index;\n}\nfunction serializeRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.source && value.source.match(regexp) != null) {\n        throw new BSONError('value ' + value.source + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.source, index);\n    buffer[index++] = 0x00;\n    if (value.ignoreCase)\n        buffer[index++] = 0x69;\n    if (value.global)\n        buffer[index++] = 0x73;\n    if (value.multiline)\n        buffer[index++] = 0x6d;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeBSONRegExp(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_REGEXP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (value.pattern.match(regexp) != null) {\n        throw new BSONError('pattern ' + value.pattern + ' must not contain null bytes');\n    }\n    index = index + ByteUtils.encodeUTF8Into(buffer, value.pattern, index);\n    buffer[index++] = 0x00;\n    const sortedOptions = value.options.split('').sort().join('');\n    index = index + ByteUtils.encodeUTF8Into(buffer, sortedOptions, index);\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeMinMax(buffer, key, value, index) {\n    if (value === null) {\n        buffer[index++] = BSON_DATA_NULL;\n    }\n    else if (value._bsontype === 'MinKey') {\n        buffer[index++] = BSON_DATA_MIN_KEY;\n    }\n    else {\n        buffer[index++] = BSON_DATA_MAX_KEY;\n    }\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeObjectId(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_OID;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    if (isUint8Array(value.id)) {\n        buffer.set(value.id.subarray(0, 12), index);\n    }\n    else {\n        throw new BSONError('object [' + JSON.stringify(value) + '] is not a valid ObjectId');\n    }\n    return index + 12;\n}\nfunction serializeBuffer(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = value.length;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n    buffer[index++] = BSON_BINARY_SUBTYPE_DEFAULT;\n    buffer.set(value, index);\n    index = index + size;\n    return index;\n}\nfunction serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path.has(value)) {\n        throw new BSONError('Cannot convert circular structure to BSON');\n    }\n    path.add(value);\n    buffer[index++] = Array.isArray(value) ? BSON_DATA_ARRAY : BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const endIndex = serializeInto(buffer, value, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n    path.delete(value);\n    return endIndex;\n}\nfunction serializeDecimal128(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_DECIMAL128;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer.set(value.bytes.subarray(0, 16), index);\n    return index + 16;\n}\nfunction serializeLong(buffer, key, value, index) {\n    buffer[index++] =\n        value._bsontype === 'Long' ? BSON_DATA_LONG : BSON_DATA_TIMESTAMP;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const lowBits = value.getLowBits();\n    const highBits = value.getHighBits();\n    buffer[index++] = lowBits & 0xff;\n    buffer[index++] = (lowBits >> 8) & 0xff;\n    buffer[index++] = (lowBits >> 16) & 0xff;\n    buffer[index++] = (lowBits >> 24) & 0xff;\n    buffer[index++] = highBits & 0xff;\n    buffer[index++] = (highBits >> 8) & 0xff;\n    buffer[index++] = (highBits >> 16) & 0xff;\n    buffer[index++] = (highBits >> 24) & 0xff;\n    return index;\n}\nfunction serializeInt32(buffer, key, value, index) {\n    value = value.valueOf();\n    buffer[index++] = BSON_DATA_INT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    buffer[index++] = value & 0xff;\n    buffer[index++] = (value >> 8) & 0xff;\n    buffer[index++] = (value >> 16) & 0xff;\n    buffer[index++] = (value >> 24) & 0xff;\n    return index;\n}\nfunction serializeDouble(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_NUMBER;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    NUMBER_SPACE.setFloat64(0, value.value, true);\n    buffer.set(EIGHT_BYTE_VIEW_ON_NUMBER, index);\n    index = index + 8;\n    return index;\n}\nfunction serializeFunction(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_CODE;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const functionString = value.toString();\n    const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0;\n    return index;\n}\nfunction serializeCode(buffer, key, value, index, checkKeys = false, depth = 0, serializeFunctions = false, ignoreUndefined = true, path) {\n    if (value.scope && typeof value.scope === 'object') {\n        buffer[index++] = BSON_DATA_CODE_W_SCOPE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        let startIndex = index;\n        const functionString = value.code;\n        index = index + 4;\n        const codeSize = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = codeSize & 0xff;\n        buffer[index + 1] = (codeSize >> 8) & 0xff;\n        buffer[index + 2] = (codeSize >> 16) & 0xff;\n        buffer[index + 3] = (codeSize >> 24) & 0xff;\n        buffer[index + 4 + codeSize - 1] = 0;\n        index = index + codeSize + 4;\n        const endIndex = serializeInto(buffer, value.scope, checkKeys, index, depth + 1, serializeFunctions, ignoreUndefined, path);\n        index = endIndex - 1;\n        const totalSize = endIndex - startIndex;\n        buffer[startIndex++] = totalSize & 0xff;\n        buffer[startIndex++] = (totalSize >> 8) & 0xff;\n        buffer[startIndex++] = (totalSize >> 16) & 0xff;\n        buffer[startIndex++] = (totalSize >> 24) & 0xff;\n        buffer[index++] = 0;\n    }\n    else {\n        buffer[index++] = BSON_DATA_CODE;\n        const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n        index = index + numberOfWrittenBytes;\n        buffer[index++] = 0;\n        const functionString = value.code.toString();\n        const size = ByteUtils.encodeUTF8Into(buffer, functionString, index + 4) + 1;\n        buffer[index] = size & 0xff;\n        buffer[index + 1] = (size >> 8) & 0xff;\n        buffer[index + 2] = (size >> 16) & 0xff;\n        buffer[index + 3] = (size >> 24) & 0xff;\n        index = index + 4 + size - 1;\n        buffer[index++] = 0;\n    }\n    return index;\n}\nfunction serializeBinary(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_BINARY;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const data = value.buffer;\n    let size = value.position;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY)\n        size = size + 4;\n    buffer[index++] = size & 0xff;\n    buffer[index++] = (size >> 8) & 0xff;\n    buffer[index++] = (size >> 16) & 0xff;\n    buffer[index++] = (size >> 24) & 0xff;\n    buffer[index++] = value.sub_type;\n    if (value.sub_type === Binary.SUBTYPE_BYTE_ARRAY) {\n        size = size - 4;\n        buffer[index++] = size & 0xff;\n        buffer[index++] = (size >> 8) & 0xff;\n        buffer[index++] = (size >> 16) & 0xff;\n        buffer[index++] = (size >> 24) & 0xff;\n    }\n    buffer.set(data, index);\n    index = index + value.position;\n    return index;\n}\nfunction serializeSymbol(buffer, key, value, index) {\n    buffer[index++] = BSON_DATA_SYMBOL;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    const size = ByteUtils.encodeUTF8Into(buffer, value.value, index + 4) + 1;\n    buffer[index] = size & 0xff;\n    buffer[index + 1] = (size >> 8) & 0xff;\n    buffer[index + 2] = (size >> 16) & 0xff;\n    buffer[index + 3] = (size >> 24) & 0xff;\n    index = index + 4 + size - 1;\n    buffer[index++] = 0x00;\n    return index;\n}\nfunction serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path) {\n    buffer[index++] = BSON_DATA_OBJECT;\n    const numberOfWrittenBytes = ByteUtils.encodeUTF8Into(buffer, key, index);\n    index = index + numberOfWrittenBytes;\n    buffer[index++] = 0;\n    let startIndex = index;\n    let output = {\n        $ref: value.collection || value.namespace,\n        $id: value.oid\n    };\n    if (value.db != null) {\n        output.$db = value.db;\n    }\n    output = Object.assign(output, value.fields);\n    const endIndex = serializeInto(buffer, output, false, index, depth + 1, serializeFunctions, true, path);\n    const size = endIndex - startIndex;\n    buffer[startIndex++] = size & 0xff;\n    buffer[startIndex++] = (size >> 8) & 0xff;\n    buffer[startIndex++] = (size >> 16) & 0xff;\n    buffer[startIndex++] = (size >> 24) & 0xff;\n    return endIndex;\n}\nfunction serializeInto(buffer, object, checkKeys, startingIndex, depth, serializeFunctions, ignoreUndefined, path) {\n    if (path == null) {\n        if (object == null) {\n            buffer[0] = 0x05;\n            buffer[1] = 0x00;\n            buffer[2] = 0x00;\n            buffer[3] = 0x00;\n            buffer[4] = 0x00;\n            return 5;\n        }\n        if (Array.isArray(object)) {\n            throw new BSONError('serialize does not support an array as the root input');\n        }\n        if (typeof object !== 'object') {\n            throw new BSONError('serialize does not support non-object as the root input');\n        }\n        else if ('_bsontype' in object && typeof object._bsontype === 'string') {\n            throw new BSONError(`BSON types cannot be serialized as a document`);\n        }\n        else if (isDate(object) ||\n            isRegExp(object) ||\n            isUint8Array(object) ||\n            isAnyArrayBuffer(object)) {\n            throw new BSONError(`date, regexp, typedarray, and arraybuffer cannot be BSON documents`);\n        }\n        path = new Set();\n    }\n    path.add(object);\n    let index = startingIndex + 4;\n    if (Array.isArray(object)) {\n        for (let i = 0; i < object.length; i++) {\n            const key = `${i}`;\n            let value = object[i];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            if (typeof value === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (typeof value === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (typeof value === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (typeof value === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === undefined) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (typeof value === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    else if (object instanceof Map || isMap(object)) {\n        const iterator = object.entries();\n        let done = false;\n        while (!done) {\n            const entry = iterator.next();\n            done = !!entry.done;\n            if (done)\n                continue;\n            const key = entry.value[0];\n            let value = entry.value[1];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (~key.indexOf('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === null || (value === undefined && ignoreUndefined === false)) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    else {\n        if (typeof object?.toBSON === 'function') {\n            object = object.toBSON();\n            if (object != null && typeof object !== 'object') {\n                throw new BSONError('toBSON function did not return an object');\n            }\n        }\n        for (const key of Object.keys(object)) {\n            let value = object[key];\n            if (typeof value?.toBSON === 'function') {\n                value = value.toBSON();\n            }\n            const type = typeof value;\n            if (typeof key === 'string' && !ignoreKeys.has(key)) {\n                if (key.match(regexp) != null) {\n                    throw new BSONError('key ' + key + ' must not contain null bytes');\n                }\n                if (checkKeys) {\n                    if ('$' === key[0]) {\n                        throw new BSONError('key ' + key + \" must not start with '$'\");\n                    }\n                    else if (~key.indexOf('.')) {\n                        throw new BSONError('key ' + key + \" must not contain '.'\");\n                    }\n                }\n            }\n            if (type === 'string') {\n                index = serializeString(buffer, key, value, index);\n            }\n            else if (type === 'number') {\n                index = serializeNumber(buffer, key, value, index);\n            }\n            else if (type === 'bigint') {\n                index = serializeBigInt(buffer, key, value, index);\n            }\n            else if (type === 'boolean') {\n                index = serializeBoolean(buffer, key, value, index);\n            }\n            else if (value instanceof Date || isDate(value)) {\n                index = serializeDate(buffer, key, value, index);\n            }\n            else if (value === undefined) {\n                if (ignoreUndefined === false)\n                    index = serializeNull(buffer, key, value, index);\n            }\n            else if (value === null) {\n                index = serializeNull(buffer, key, value, index);\n            }\n            else if (isUint8Array(value)) {\n                index = serializeBuffer(buffer, key, value, index);\n            }\n            else if (value instanceof RegExp || isRegExp(value)) {\n                index = serializeRegExp(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype == null) {\n                index = serializeObject(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'object' &&\n                value[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n                throw new BSONVersionError();\n            }\n            else if (value._bsontype === 'ObjectId') {\n                index = serializeObjectId(buffer, key, value, index);\n            }\n            else if (type === 'object' && value._bsontype === 'Decimal128') {\n                index = serializeDecimal128(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Long' || value._bsontype === 'Timestamp') {\n                index = serializeLong(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Double') {\n                index = serializeDouble(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Code') {\n                index = serializeCode(buffer, key, value, index, checkKeys, depth, serializeFunctions, ignoreUndefined, path);\n            }\n            else if (typeof value === 'function' && serializeFunctions) {\n                index = serializeFunction(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Binary') {\n                index = serializeBinary(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'BSONSymbol') {\n                index = serializeSymbol(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'DBRef') {\n                index = serializeDBRef(buffer, key, value, index, depth, serializeFunctions, path);\n            }\n            else if (value._bsontype === 'BSONRegExp') {\n                index = serializeBSONRegExp(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'Int32') {\n                index = serializeInt32(buffer, key, value, index);\n            }\n            else if (value._bsontype === 'MinKey' || value._bsontype === 'MaxKey') {\n                index = serializeMinMax(buffer, key, value, index);\n            }\n            else if (typeof value._bsontype !== 'undefined') {\n                throw new BSONError(`Unrecognized or invalid _bsontype: ${String(value._bsontype)}`);\n            }\n        }\n    }\n    path.delete(object);\n    buffer[index++] = 0x00;\n    const size = index - startingIndex;\n    buffer[startingIndex++] = size & 0xff;\n    buffer[startingIndex++] = (size >> 8) & 0xff;\n    buffer[startingIndex++] = (size >> 16) & 0xff;\n    buffer[startingIndex++] = (size >> 24) & 0xff;\n    return index;\n}\n\nfunction isBSONType(value) {\n    return (value != null &&\n        typeof value === 'object' &&\n        '_bsontype' in value &&\n        typeof value._bsontype === 'string');\n}\nconst keysToCodecs = {\n    $oid: ObjectId,\n    $binary: Binary,\n    $uuid: Binary,\n    $symbol: BSONSymbol,\n    $numberInt: Int32,\n    $numberDecimal: Decimal128,\n    $numberDouble: Double,\n    $numberLong: Long,\n    $minKey: MinKey,\n    $maxKey: MaxKey,\n    $regex: BSONRegExp,\n    $regularExpression: BSONRegExp,\n    $timestamp: Timestamp\n};\nfunction deserializeValue(value, options = {}) {\n    if (typeof value === 'number') {\n        const in32BitRange = value <= BSON_INT32_MAX && value >= BSON_INT32_MIN;\n        const in64BitRange = value <= BSON_INT64_MAX && value >= BSON_INT64_MIN;\n        if (options.relaxed || options.legacy) {\n            return value;\n        }\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (in32BitRange) {\n                return new Int32(value);\n            }\n            if (in64BitRange) {\n                if (options.useBigInt64) {\n                    return BigInt(value);\n                }\n                return Long.fromNumber(value);\n            }\n        }\n        return new Double(value);\n    }\n    if (value == null || typeof value !== 'object')\n        return value;\n    if (value.$undefined)\n        return null;\n    const keys = Object.keys(value).filter(k => k.startsWith('$') && value[k] != null);\n    for (let i = 0; i < keys.length; i++) {\n        const c = keysToCodecs[keys[i]];\n        if (c)\n            return c.fromExtendedJSON(value, options);\n    }\n    if (value.$date != null) {\n        const d = value.$date;\n        const date = new Date();\n        if (options.legacy) {\n            if (typeof d === 'number')\n                date.setTime(d);\n            else if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        else {\n            if (typeof d === 'string')\n                date.setTime(Date.parse(d));\n            else if (Long.isLong(d))\n                date.setTime(d.toNumber());\n            else if (typeof d === 'number' && options.relaxed)\n                date.setTime(d);\n            else if (typeof d === 'bigint')\n                date.setTime(Number(d));\n            else\n                throw new BSONRuntimeError(`Unrecognized type for EJSON date: ${typeof d}`);\n        }\n        return date;\n    }\n    if (value.$code != null) {\n        const copy = Object.assign({}, value);\n        if (value.$scope) {\n            copy.$scope = deserializeValue(value.$scope);\n        }\n        return Code.fromExtendedJSON(value);\n    }\n    if (isDBRefLike(value) || value.$dbPointer) {\n        const v = value.$ref ? value : value.$dbPointer;\n        if (v instanceof DBRef)\n            return v;\n        const dollarKeys = Object.keys(v).filter(k => k.startsWith('$'));\n        let valid = true;\n        dollarKeys.forEach(k => {\n            if (['$ref', '$id', '$db'].indexOf(k) === -1)\n                valid = false;\n        });\n        if (valid)\n            return DBRef.fromExtendedJSON(v);\n    }\n    return value;\n}\nfunction serializeArray(array, options) {\n    return array.map((v, index) => {\n        options.seenObjects.push({ propertyName: `index ${index}`, obj: null });\n        try {\n            return serializeValue(v, options);\n        }\n        finally {\n            options.seenObjects.pop();\n        }\n    });\n}\nfunction getISOString(date) {\n    const isoStr = date.toISOString();\n    return date.getUTCMilliseconds() !== 0 ? isoStr : isoStr.slice(0, -5) + 'Z';\n}\nfunction serializeValue(value, options) {\n    if (value instanceof Map || isMap(value)) {\n        const obj = Object.create(null);\n        for (const [k, v] of value) {\n            if (typeof k !== 'string') {\n                throw new BSONError('Can only serialize maps with string keys');\n            }\n            obj[k] = v;\n        }\n        return serializeValue(obj, options);\n    }\n    if ((typeof value === 'object' || typeof value === 'function') && value !== null) {\n        const index = options.seenObjects.findIndex(entry => entry.obj === value);\n        if (index !== -1) {\n            const props = options.seenObjects.map(entry => entry.propertyName);\n            const leadingPart = props\n                .slice(0, index)\n                .map(prop => `${prop} -> `)\n                .join('');\n            const alreadySeen = props[index];\n            const circularPart = ' -> ' +\n                props\n                    .slice(index + 1, props.length - 1)\n                    .map(prop => `${prop} -> `)\n                    .join('');\n            const current = props[props.length - 1];\n            const leadingSpace = ' '.repeat(leadingPart.length + alreadySeen.length / 2);\n            const dashes = '-'.repeat(circularPart.length + (alreadySeen.length + current.length) / 2 - 1);\n            throw new BSONError('Converting circular structure to EJSON:\\n' +\n                `    ${leadingPart}${alreadySeen}${circularPart}${current}\\n` +\n                `    ${leadingSpace}\\\\${dashes}/`);\n        }\n        options.seenObjects[options.seenObjects.length - 1].obj = value;\n    }\n    if (Array.isArray(value))\n        return serializeArray(value, options);\n    if (value === undefined)\n        return null;\n    if (value instanceof Date || isDate(value)) {\n        const dateNum = value.getTime(), inRange = dateNum > -1 && dateNum < 253402318800000;\n        if (options.legacy) {\n            return options.relaxed && inRange\n                ? { $date: value.getTime() }\n                : { $date: getISOString(value) };\n        }\n        return options.relaxed && inRange\n            ? { $date: getISOString(value) }\n            : { $date: { $numberLong: value.getTime().toString() } };\n    }\n    if (typeof value === 'number' && (!options.relaxed || !isFinite(value))) {\n        if (Number.isInteger(value) && !Object.is(value, -0)) {\n            if (value >= BSON_INT32_MIN && value <= BSON_INT32_MAX) {\n                return { $numberInt: value.toString() };\n            }\n            if (value >= BSON_INT64_MIN && value <= BSON_INT64_MAX) {\n                return { $numberLong: value.toString() };\n            }\n        }\n        return { $numberDouble: Object.is(value, -0) ? '-0.0' : value.toString() };\n    }\n    if (typeof value === 'bigint') {\n        if (!options.relaxed) {\n            return { $numberLong: BigInt.asIntN(64, value).toString() };\n        }\n        return Number(BigInt.asIntN(64, value));\n    }\n    if (value instanceof RegExp || isRegExp(value)) {\n        let flags = value.flags;\n        if (flags === undefined) {\n            const match = value.toString().match(/[gimuy]*$/);\n            if (match) {\n                flags = match[0];\n            }\n        }\n        const rx = new BSONRegExp(value.source, flags);\n        return rx.toExtendedJSON(options);\n    }\n    if (value != null && typeof value === 'object')\n        return serializeDocument(value, options);\n    return value;\n}\nconst BSON_TYPE_MAPPINGS = {\n    Binary: (o) => new Binary(o.value(), o.sub_type),\n    Code: (o) => new Code(o.code, o.scope),\n    DBRef: (o) => new DBRef(o.collection || o.namespace, o.oid, o.db, o.fields),\n    Decimal128: (o) => new Decimal128(o.bytes),\n    Double: (o) => new Double(o.value),\n    Int32: (o) => new Int32(o.value),\n    Long: (o) => Long.fromBits(o.low != null ? o.low : o.low_, o.low != null ? o.high : o.high_, o.low != null ? o.unsigned : o.unsigned_),\n    MaxKey: () => new MaxKey(),\n    MinKey: () => new MinKey(),\n    ObjectId: (o) => new ObjectId(o),\n    BSONRegExp: (o) => new BSONRegExp(o.pattern, o.options),\n    BSONSymbol: (o) => new BSONSymbol(o.value),\n    Timestamp: (o) => Timestamp.fromBits(o.low, o.high)\n};\nfunction serializeDocument(doc, options) {\n    if (doc == null || typeof doc !== 'object')\n        throw new BSONError('not an object instance');\n    const bsontype = doc._bsontype;\n    if (typeof bsontype === 'undefined') {\n        const _doc = {};\n        for (const name of Object.keys(doc)) {\n            options.seenObjects.push({ propertyName: name, obj: null });\n            try {\n                const value = serializeValue(doc[name], options);\n                if (name === '__proto__') {\n                    Object.defineProperty(_doc, name, {\n                        value,\n                        writable: true,\n                        enumerable: true,\n                        configurable: true\n                    });\n                }\n                else {\n                    _doc[name] = value;\n                }\n            }\n            finally {\n                options.seenObjects.pop();\n            }\n        }\n        return _doc;\n    }\n    else if (doc != null &&\n        typeof doc === 'object' &&\n        typeof doc._bsontype === 'string' &&\n        doc[Symbol.for('@@mdb.bson.version')] !== BSON_MAJOR_VERSION) {\n        throw new BSONVersionError();\n    }\n    else if (isBSONType(doc)) {\n        let outDoc = doc;\n        if (typeof outDoc.toExtendedJSON !== 'function') {\n            const mapper = BSON_TYPE_MAPPINGS[doc._bsontype];\n            if (!mapper) {\n                throw new BSONError('Unrecognized or invalid _bsontype: ' + doc._bsontype);\n            }\n            outDoc = mapper(outDoc);\n        }\n        if (bsontype === 'Code' && outDoc.scope) {\n            outDoc = new Code(outDoc.code, serializeValue(outDoc.scope, options));\n        }\n        else if (bsontype === 'DBRef' && outDoc.oid) {\n            outDoc = new DBRef(serializeValue(outDoc.collection, options), serializeValue(outDoc.oid, options), serializeValue(outDoc.db, options), serializeValue(outDoc.fields, options));\n        }\n        return outDoc.toExtendedJSON(options);\n    }\n    else {\n        throw new BSONError('_bsontype must be a string, but was: ' + typeof bsontype);\n    }\n}\nfunction parse(text, options) {\n    const ejsonOptions = {\n        useBigInt64: options?.useBigInt64 ?? false,\n        relaxed: options?.relaxed ?? true,\n        legacy: options?.legacy ?? false\n    };\n    return JSON.parse(text, (key, value) => {\n        if (key.indexOf('\\x00') !== -1) {\n            throw new BSONError(`BSON Document field names cannot contain null bytes, found: ${JSON.stringify(key)}`);\n        }\n        return deserializeValue(value, ejsonOptions);\n    });\n}\nfunction stringify(value, replacer, space, options) {\n    if (space != null && typeof space === 'object') {\n        options = space;\n        space = 0;\n    }\n    if (replacer != null && typeof replacer === 'object' && !Array.isArray(replacer)) {\n        options = replacer;\n        replacer = undefined;\n        space = 0;\n    }\n    const serializeOptions = Object.assign({ relaxed: true, legacy: false }, options, {\n        seenObjects: [{ propertyName: '(root)', obj: null }]\n    });\n    const doc = serializeValue(value, serializeOptions);\n    return JSON.stringify(doc, replacer, space);\n}\nfunction EJSONserialize(value, options) {\n    options = options || {};\n    return JSON.parse(stringify(value, options));\n}\nfunction EJSONdeserialize(ejson, options) {\n    options = options || {};\n    return parse(JSON.stringify(ejson), options);\n}\nconst EJSON = Object.create(null);\nEJSON.parse = parse;\nEJSON.stringify = stringify;\nEJSON.serialize = EJSONserialize;\nEJSON.deserialize = EJSONdeserialize;\nObject.freeze(EJSON);\n\nconst MAXSIZE = 1024 * 1024 * 17;\nlet buffer = ByteUtils.allocate(MAXSIZE);\nfunction setInternalBufferSize(size) {\n    if (buffer.length < size) {\n        buffer = ByteUtils.allocate(size);\n    }\n}\nfunction serialize(object, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const minInternalBufferSize = typeof options.minInternalBufferSize === 'number' ? options.minInternalBufferSize : MAXSIZE;\n    if (buffer.length < minInternalBufferSize) {\n        buffer = ByteUtils.allocate(minInternalBufferSize);\n    }\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    const finishedBuffer = ByteUtils.allocate(serializationIndex);\n    finishedBuffer.set(buffer.subarray(0, serializationIndex), 0);\n    return finishedBuffer;\n}\nfunction serializeWithBufferAndIndex(object, finalBuffer, options = {}) {\n    const checkKeys = typeof options.checkKeys === 'boolean' ? options.checkKeys : false;\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    const startIndex = typeof options.index === 'number' ? options.index : 0;\n    const serializationIndex = serializeInto(buffer, object, checkKeys, 0, 0, serializeFunctions, ignoreUndefined, null);\n    finalBuffer.set(buffer.subarray(0, serializationIndex), startIndex);\n    return startIndex + serializationIndex - 1;\n}\nfunction deserialize(buffer, options = {}) {\n    return internalDeserialize(ByteUtils.toLocalBufferType(buffer), options);\n}\nfunction calculateObjectSize(object, options = {}) {\n    options = options || {};\n    const serializeFunctions = typeof options.serializeFunctions === 'boolean' ? options.serializeFunctions : false;\n    const ignoreUndefined = typeof options.ignoreUndefined === 'boolean' ? options.ignoreUndefined : true;\n    return internalCalculateObjectSize(object, serializeFunctions, ignoreUndefined);\n}\nfunction deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {\n    const internalOptions = Object.assign({ allowObjectSmallerThanBufferSize: true, index: 0 }, options);\n    const bufferData = ByteUtils.toLocalBufferType(data);\n    let index = startIndex;\n    for (let i = 0; i < numberOfDocuments; i++) {\n        const size = bufferData[index] |\n            (bufferData[index + 1] << 8) |\n            (bufferData[index + 2] << 16) |\n            (bufferData[index + 3] << 24);\n        internalOptions.index = index;\n        documents[docStartIndex + i] = internalDeserialize(bufferData, internalOptions);\n        index = index + size;\n    }\n    return index;\n}\n\nvar bson = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    BSONError: BSONError,\n    BSONRegExp: BSONRegExp,\n    BSONRuntimeError: BSONRuntimeError,\n    BSONSymbol: BSONSymbol,\n    BSONType: BSONType,\n    BSONValue: BSONValue,\n    BSONVersionError: BSONVersionError,\n    Binary: Binary,\n    Code: Code,\n    DBRef: DBRef,\n    Decimal128: Decimal128,\n    Double: Double,\n    EJSON: EJSON,\n    Int32: Int32,\n    Long: Long,\n    MaxKey: MaxKey,\n    MinKey: MinKey,\n    ObjectId: ObjectId,\n    Timestamp: Timestamp,\n    UUID: UUID,\n    calculateObjectSize: calculateObjectSize,\n    deserialize: deserialize,\n    deserializeStream: deserializeStream,\n    serialize: serialize,\n    serializeWithBufferAndIndex: serializeWithBufferAndIndex,\n    setInternalBufferSize: setInternalBufferSize\n});\n\nexport { bson as BSON, BSONError, BSONRegExp, BSONRuntimeError, BSONSymbol, BSONType, BSONValue, BSONVersionError, Binary, Code, DBRef, Decimal128, Double, EJSON, Int32, Long, MaxKey, MinKey, ObjectId, Timestamp, UUID, calculateObjectSize, deserialize, deserializeStream, serialize, serializeWithBufferAndIndex, setInternalBufferSize };\n"],"mappings":"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AAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,GAAG,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,GAAG,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,EAAE,EAAE,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,EAAE,GAAG,E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"},"metadata":{},"sourceType":"module","externalDependencies":[]}