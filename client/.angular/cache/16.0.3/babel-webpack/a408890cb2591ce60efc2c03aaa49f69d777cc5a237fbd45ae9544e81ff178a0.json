{"ast":null,"code":"'use strict';\n\nvar _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst {\n  FetchError,\n  Request,\n  isRedirect\n} = require('minipass-fetch');\nconst url = require('url');\nconst CachePolicy = require('./cache/policy.js');\nconst cache = require('./cache/index.js');\nconst remote = require('./remote.js');\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) {\n    return false;\n  }\n  if (options.redirect === 'manual') {\n    return false;\n  }\n  if (options.redirect === 'error') {\n    throw new FetchError(`redirect mode is set to error: ${request.url}`, 'no-redirect', {\n      code: 'ENOREDIRECT'\n    });\n  }\n  if (!response.headers.has('location')) {\n    throw new FetchError(`redirect location header missing for: ${request.url}`, 'no-location', {\n      code: 'EINVALIDREDIRECT'\n    });\n  }\n  if (request.counter >= request.follow) {\n    throw new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect', {\n      code: 'EMAXREDIRECT'\n    });\n  }\n  return true;\n};\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = {\n    ...options\n  };\n  const location = response.headers.get('location');\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url);\n  // Comment below is used under the following license:\n  /**\n   * @license\n   * Copyright (c) 2010-2012 Mikeal Rogers\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   * http://www.apache.org/licenses/LICENSE-2.0\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an \"AS\n   * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n   * express or implied. See the License for the specific language\n   * governing permissions and limitations under the License.\n   */\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) {\n    request.headers.delete('authorization');\n    request.headers.delete('cookie');\n  }\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (response.status === 303 || request.method === 'POST' && [301, 302].includes(response.status)) {\n    _opts.method = 'GET';\n    _opts.body = null;\n    request.headers.delete('content-length');\n  }\n  _opts.headers = {};\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value;\n  });\n  _opts.counter = ++request.counter;\n  const redirectReq = new Request(url.format(redirectUrl), _opts);\n  return {\n    request: redirectReq,\n    options: _opts\n  };\n};\nconst fetch = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator(function* (request, options) {\n    const response = CachePolicy.storable(request, options) ? yield cache(request, options) : yield remote(request, options);\n\n    // if the request wasn't a GET or HEAD, and the response\n    // status is between 200 and 399 inclusive, invalidate the\n    // request url\n    if (!['GET', 'HEAD'].includes(request.method) && response.status >= 200 && response.status <= 399) {\n      yield cache.invalidate(request, options);\n    }\n    if (!canFollowRedirect(request, response, options)) {\n      return response;\n    }\n    const redirect = getRedirect(request, response, options);\n    return fetch(redirect.request, redirect.options);\n  });\n  return function fetch(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\nmodule.exports = fetch;","map":{"version":3,"names":["_asyncToGenerator","require","default","FetchError","Request","isRedirect","url","CachePolicy","cache","remote","canFollowRedirect","request","response","options","status","redirect","code","headers","has","counter","follow","getRedirect","_opts","location","get","redirectUrl","URL","test","undefined","hostname","delete","method","includes","body","forEach","value","key","redirectReq","format","fetch","_ref","storable","invalidate","_x","_x2","apply","arguments","module","exports"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/lib/fetch.js"],"sourcesContent":["'use strict'\n\nconst { FetchError, Request, isRedirect } = require('minipass-fetch')\nconst url = require('url')\n\nconst CachePolicy = require('./cache/policy.js')\nconst cache = require('./cache/index.js')\nconst remote = require('./remote.js')\n\n// given a Request, a Response and user options\n// return true if the response is a redirect that\n// can be followed. we throw errors that will result\n// in the fetch being rejected if the redirect is\n// possible but invalid for some reason\nconst canFollowRedirect = (request, response, options) => {\n  if (!isRedirect(response.status)) {\n    return false\n  }\n\n  if (options.redirect === 'manual') {\n    return false\n  }\n\n  if (options.redirect === 'error') {\n    throw new FetchError(`redirect mode is set to error: ${request.url}`,\n      'no-redirect', { code: 'ENOREDIRECT' })\n  }\n\n  if (!response.headers.has('location')) {\n    throw new FetchError(`redirect location header missing for: ${request.url}`,\n      'no-location', { code: 'EINVALIDREDIRECT' })\n  }\n\n  if (request.counter >= request.follow) {\n    throw new FetchError(`maximum redirect reached at: ${request.url}`,\n      'max-redirect', { code: 'EMAXREDIRECT' })\n  }\n\n  return true\n}\n\n// given a Request, a Response, and the user's options return an object\n// with a new Request and a new options object that will be used for\n// following the redirect\nconst getRedirect = (request, response, options) => {\n  const _opts = { ...options }\n  const location = response.headers.get('location')\n  const redirectUrl = new url.URL(location, /^https?:/.test(location) ? undefined : request.url)\n  // Comment below is used under the following license:\n  /**\n   * @license\n   * Copyright (c) 2010-2012 Mikeal Rogers\n   * Licensed under the Apache License, Version 2.0 (the \"License\");\n   * you may not use this file except in compliance with the License.\n   * You may obtain a copy of the License at\n   * http://www.apache.org/licenses/LICENSE-2.0\n   * Unless required by applicable law or agreed to in writing,\n   * software distributed under the License is distributed on an \"AS\n   * IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n   * express or implied. See the License for the specific language\n   * governing permissions and limitations under the License.\n   */\n\n  // Remove authorization if changing hostnames (but not if just\n  // changing ports or protocols).  This matches the behavior of request:\n  // https://github.com/request/request/blob/b12a6245/lib/redirect.js#L134-L138\n  if (new url.URL(request.url).hostname !== redirectUrl.hostname) {\n    request.headers.delete('authorization')\n    request.headers.delete('cookie')\n  }\n\n  // for POST request with 301/302 response, or any request with 303 response,\n  // use GET when following redirect\n  if (\n    response.status === 303 ||\n    (request.method === 'POST' && [301, 302].includes(response.status))\n  ) {\n    _opts.method = 'GET'\n    _opts.body = null\n    request.headers.delete('content-length')\n  }\n\n  _opts.headers = {}\n  request.headers.forEach((value, key) => {\n    _opts.headers[key] = value\n  })\n\n  _opts.counter = ++request.counter\n  const redirectReq = new Request(url.format(redirectUrl), _opts)\n  return {\n    request: redirectReq,\n    options: _opts,\n  }\n}\n\nconst fetch = async (request, options) => {\n  const response = CachePolicy.storable(request, options)\n    ? await cache(request, options)\n    : await remote(request, options)\n\n  // if the request wasn't a GET or HEAD, and the response\n  // status is between 200 and 399 inclusive, invalidate the\n  // request url\n  if (!['GET', 'HEAD'].includes(request.method) &&\n      response.status >= 200 &&\n      response.status <= 399) {\n    await cache.invalidate(request, options)\n  }\n\n  if (!canFollowRedirect(request, response, options)) {\n    return response\n  }\n\n  const redirect = getRedirect(request, response, options)\n  return fetch(redirect.request, redirect.options)\n}\n\nmodule.exports = fetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}