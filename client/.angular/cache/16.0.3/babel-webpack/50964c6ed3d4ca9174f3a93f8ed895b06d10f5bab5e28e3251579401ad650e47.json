{"ast":null,"code":"const CacheSemantics = require('http-cache-semantics');\nconst Negotiator = require('negotiator');\nconst ssri = require('ssri');\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true\n};\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = {\n  status: 200,\n  headers: {}\n};\n\n// returns a plain object representation of the Request\nconst requestObject = request => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n    compress: request.compress\n  };\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\n\n// returns a plain object representation of the Response\nconst responseObject = response => {\n  const _obj = {\n    status: response.status,\n    headers: {}\n  };\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value;\n  });\n  return _obj;\n};\nclass CachePolicy {\n  constructor({\n    entry,\n    request,\n    response,\n    options\n  }) {\n    this.entry = entry;\n    this.request = requestObject(request);\n    this.response = responseObject(response);\n    this.options = options;\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions);\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time;\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable(request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) {\n      return false;\n    }\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store') {\n      return false;\n    }\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method)) {\n      return false;\n    }\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions);\n    return policy.storable();\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies(request) {\n    const _req = requestObject(request);\n    if (this.request.headers.host !== _req.headers.host) {\n      return false;\n    }\n    if (this.request.compress !== _req.compress) {\n      return false;\n    }\n    const negotiatorA = new Negotiator(this.request);\n    const negotiatorB = new Negotiator(_req);\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {\n      return false;\n    }\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {\n      return false;\n    }\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {\n      return false;\n    }\n    if (this.options.integrity) {\n      return ssri.parse(this.options.integrity).match(this.entry.integrity);\n    }\n    return true;\n  }\n\n  // returns true if the request and response allow caching\n  storable() {\n    return this.policy.storable();\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate() {\n    return !!this.policy._rescc['must-revalidate'];\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation(request) {\n    const _req = requestObject(request);\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET';\n    return !this.policy.satisfiesWithoutRevalidation(_req);\n  }\n  responseHeaders() {\n    return this.policy.responseHeaders();\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders(request) {\n    const _req = requestObject(request);\n    return this.policy.revalidationHeaders(_req);\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated(request, response) {\n    const _req = requestObject(request);\n    const _res = responseObject(response);\n    const policy = this.policy.revalidatedPolicy(_req, _res);\n    return !policy.modified;\n  }\n}\nmodule.exports = CachePolicy;","map":{"version":3,"names":["CacheSemantics","require","Negotiator","ssri","policyOptions","shared","ignoreCargoCult","emptyResponse","status","headers","requestObject","request","_obj","method","url","compress","forEach","value","key","responseObject","response","CachePolicy","constructor","entry","options","policy","_responseTime","metadata","time","storable","cachePath","cache","includes","satisfies","_req","host","negotiatorA","negotiatorB","JSON","stringify","mediaTypes","languages","encodings","integrity","parse","match","mustRevalidate","_rescc","needsRevalidation","satisfiesWithoutRevalidation","responseHeaders","revalidationHeaders","revalidated","_res","revalidatedPolicy","modified","module","exports"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/lib/cache/policy.js"],"sourcesContent":["const CacheSemantics = require('http-cache-semantics')\nconst Negotiator = require('negotiator')\nconst ssri = require('ssri')\n\n// options passed to http-cache-semantics constructor\nconst policyOptions = {\n  shared: false,\n  ignoreCargoCult: true,\n}\n\n// a fake empty response, used when only testing the\n// request for storability\nconst emptyResponse = { status: 200, headers: {} }\n\n// returns a plain object representation of the Request\nconst requestObject = (request) => {\n  const _obj = {\n    method: request.method,\n    url: request.url,\n    headers: {},\n    compress: request.compress,\n  }\n\n  request.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\n// returns a plain object representation of the Response\nconst responseObject = (response) => {\n  const _obj = {\n    status: response.status,\n    headers: {},\n  }\n\n  response.headers.forEach((value, key) => {\n    _obj.headers[key] = value\n  })\n\n  return _obj\n}\n\nclass CachePolicy {\n  constructor ({ entry, request, response, options }) {\n    this.entry = entry\n    this.request = requestObject(request)\n    this.response = responseObject(response)\n    this.options = options\n    this.policy = new CacheSemantics(this.request, this.response, policyOptions)\n\n    if (this.entry) {\n      // if we have an entry, copy the timestamp to the _responseTime\n      // this is necessary because the CacheSemantics constructor forces\n      // the value to Date.now() which means a policy created from a\n      // cache entry is likely to always identify itself as stale\n      this.policy._responseTime = this.entry.metadata.time\n    }\n  }\n\n  // static method to quickly determine if a request alone is storable\n  static storable (request, options) {\n    // no cachePath means no caching\n    if (!options.cachePath) {\n      return false\n    }\n\n    // user explicitly asked not to cache\n    if (options.cache === 'no-store') {\n      return false\n    }\n\n    // we only cache GET and HEAD requests\n    if (!['GET', 'HEAD'].includes(request.method)) {\n      return false\n    }\n\n    // otherwise, let http-cache-semantics make the decision\n    // based on the request's headers\n    const policy = new CacheSemantics(requestObject(request), emptyResponse, policyOptions)\n    return policy.storable()\n  }\n\n  // returns true if the policy satisfies the request\n  satisfies (request) {\n    const _req = requestObject(request)\n    if (this.request.headers.host !== _req.headers.host) {\n      return false\n    }\n\n    if (this.request.compress !== _req.compress) {\n      return false\n    }\n\n    const negotiatorA = new Negotiator(this.request)\n    const negotiatorB = new Negotiator(_req)\n\n    if (JSON.stringify(negotiatorA.mediaTypes()) !== JSON.stringify(negotiatorB.mediaTypes())) {\n      return false\n    }\n\n    if (JSON.stringify(negotiatorA.languages()) !== JSON.stringify(negotiatorB.languages())) {\n      return false\n    }\n\n    if (JSON.stringify(negotiatorA.encodings()) !== JSON.stringify(negotiatorB.encodings())) {\n      return false\n    }\n\n    if (this.options.integrity) {\n      return ssri.parse(this.options.integrity).match(this.entry.integrity)\n    }\n\n    return true\n  }\n\n  // returns true if the request and response allow caching\n  storable () {\n    return this.policy.storable()\n  }\n\n  // NOTE: this is a hack to avoid parsing the cache-control\n  // header ourselves, it returns true if the response's\n  // cache-control contains must-revalidate\n  get mustRevalidate () {\n    return !!this.policy._rescc['must-revalidate']\n  }\n\n  // returns true if the cached response requires revalidation\n  // for the given request\n  needsRevalidation (request) {\n    const _req = requestObject(request)\n    // force method to GET because we only cache GETs\n    // but can serve a HEAD from a cached GET\n    _req.method = 'GET'\n    return !this.policy.satisfiesWithoutRevalidation(_req)\n  }\n\n  responseHeaders () {\n    return this.policy.responseHeaders()\n  }\n\n  // returns a new object containing the appropriate headers\n  // to send a revalidation request\n  revalidationHeaders (request) {\n    const _req = requestObject(request)\n    return this.policy.revalidationHeaders(_req)\n  }\n\n  // returns true if the request/response was revalidated\n  // successfully. returns false if a new response was received\n  revalidated (request, response) {\n    const _req = requestObject(request)\n    const _res = responseObject(response)\n    const policy = this.policy.revalidatedPolicy(_req, _res)\n    return !policy.modified\n  }\n}\n\nmodule.exports = CachePolicy\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}