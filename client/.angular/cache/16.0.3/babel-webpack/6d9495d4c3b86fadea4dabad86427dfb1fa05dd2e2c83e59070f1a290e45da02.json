{"ast":null,"code":"var _asyncToGenerator = require(\"C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nconst Minipass = require('minipass');\nconst fetch = require('minipass-fetch');\nconst promiseRetry = require('promise-retry');\nconst ssri = require('ssri');\nconst CachingMinipassPipeline = require('./pipeline.js');\nconst getAgent = require('./agent.js');\nconst pkg = require('../package.json');\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;\nconst RETRY_ERRORS = ['ECONNRESET',\n// remote socket closed on us\n'ECONNREFUSED',\n// remote host refused to open connection\n'EADDRINUSE',\n// failed to bind to a local port (proxy?)\n'ETIMEDOUT',\n// someone in the transaction is WAY TOO SLOW\n'ERR_SOCKET_TIMEOUT' // same as above, but this one comes from agentkeepalive\n// Known codes we do NOT retry on:\n// ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n];\n\nconst RETRY_TYPES = ['request-timeout'];\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options);\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close');\n  }\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT);\n  }\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual'\n  };\n  return promiseRetry( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator(function* (retryHandler, attemptNum) {\n      const req = new fetch.Request(request, _opts);\n      try {\n        let res = yield fetch(req, _opts);\n        if (_opts.integrity && res.status === 200) {\n          // we got a 200 response and the user has specified an expected\n          // integrity value, so wrap the response in an ssri stream to verify it\n          const integrityStream = ssri.integrityStream({\n            algorithms: _opts.algorithms,\n            integrity: _opts.integrity,\n            size: _opts.size\n          });\n          const pipeline = new CachingMinipassPipeline({\n            events: ['integrity', 'size']\n          }, res.body, integrityStream);\n          // we also propagate the integrity and size events out to the pipeline so we can use\n          // this new response body as an integrityEmitter for cacache\n          integrityStream.on('integrity', i => pipeline.emit('integrity', i));\n          integrityStream.on('size', s => pipeline.emit('size', s));\n          res = new fetch.Response(pipeline, res);\n          // set an explicit flag so we know if our response body will emit integrity and size\n          res.body.hasIntegrityEmitter = true;\n        }\n        res.headers.set('x-fetch-attempts', attemptNum);\n\n        // do not retry POST requests, or requests with a streaming body\n        // do retry requests with a 408, 420, 429 or 500+ status in the response\n        const isStream = Minipass.isStream(req.body);\n        const isRetriable = req.method !== 'POST' && !isStream && ([408, 420, 429].includes(res.status) || res.status >= 500);\n        if (isRetriable) {\n          if (typeof options.onRetry === 'function') {\n            options.onRetry(res);\n          }\n          return retryHandler(res);\n        }\n        return res;\n      } catch (err) {\n        const code = err.code === 'EPROMISERETRY' ? err.retried.code : err.code;\n\n        // err.retried will be the thing that was thrown from above\n        // if it's a response, we just got a bad status code and we\n        // can re-throw to allow the retry\n        const isRetryError = err.retried instanceof fetch.Response || RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type);\n        if (req.method === 'POST' || isRetryError) {\n          throw err;\n        }\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(err);\n        }\n        return retryHandler(err);\n      }\n    });\n    return function (_x, _x2) {\n      return _ref.apply(this, arguments);\n    };\n  }(), options.retry).catch(err => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err;\n    }\n    throw err;\n  });\n};\nmodule.exports = remoteFetch;","map":{"version":3,"names":["Minipass","require","fetch","promiseRetry","ssri","CachingMinipassPipeline","getAgent","pkg","USER_AGENT","name","version","RETRY_ERRORS","RETRY_TYPES","remoteFetch","request","options","agent","url","headers","has","set","_opts","redirect","_ref","_asyncToGenerator","retryHandler","attemptNum","req","Request","res","integrity","status","integrityStream","algorithms","size","pipeline","events","body","on","i","emit","s","Response","hasIntegrityEmitter","isStream","isRetriable","method","includes","onRetry","err","code","retried","isRetryError","type","_x","_x2","apply","arguments","retry","catch","module","exports"],"sources":["C:/Users/shinz/OneDrive/Desktop/web/ecommerce/node_modules/make-fetch-happen/lib/remote.js"],"sourcesContent":["const Minipass = require('minipass')\nconst fetch = require('minipass-fetch')\nconst promiseRetry = require('promise-retry')\nconst ssri = require('ssri')\n\nconst CachingMinipassPipeline = require('./pipeline.js')\nconst getAgent = require('./agent.js')\nconst pkg = require('../package.json')\n\nconst USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`\n\nconst RETRY_ERRORS = [\n  'ECONNRESET', // remote socket closed on us\n  'ECONNREFUSED', // remote host refused to open connection\n  'EADDRINUSE', // failed to bind to a local port (proxy?)\n  'ETIMEDOUT', // someone in the transaction is WAY TOO SLOW\n  'ERR_SOCKET_TIMEOUT', // same as above, but this one comes from agentkeepalive\n  // Known codes we do NOT retry on:\n  // ENOTFOUND (getaddrinfo failure. Either bad hostname, or offline)\n]\n\nconst RETRY_TYPES = [\n  'request-timeout',\n]\n\n// make a request directly to the remote source,\n// retrying certain classes of errors as well as\n// following redirects (through the cache if necessary)\n// and verifying response integrity\nconst remoteFetch = (request, options) => {\n  const agent = getAgent(request.url, options)\n  if (!request.headers.has('connection')) {\n    request.headers.set('connection', agent ? 'keep-alive' : 'close')\n  }\n\n  if (!request.headers.has('user-agent')) {\n    request.headers.set('user-agent', USER_AGENT)\n  }\n\n  // keep our own options since we're overriding the agent\n  // and the redirect mode\n  const _opts = {\n    ...options,\n    agent,\n    redirect: 'manual',\n  }\n\n  return promiseRetry(async (retryHandler, attemptNum) => {\n    const req = new fetch.Request(request, _opts)\n    try {\n      let res = await fetch(req, _opts)\n      if (_opts.integrity && res.status === 200) {\n        // we got a 200 response and the user has specified an expected\n        // integrity value, so wrap the response in an ssri stream to verify it\n        const integrityStream = ssri.integrityStream({\n          algorithms: _opts.algorithms,\n          integrity: _opts.integrity,\n          size: _opts.size,\n        })\n        const pipeline = new CachingMinipassPipeline({\n          events: ['integrity', 'size'],\n        }, res.body, integrityStream)\n        // we also propagate the integrity and size events out to the pipeline so we can use\n        // this new response body as an integrityEmitter for cacache\n        integrityStream.on('integrity', i => pipeline.emit('integrity', i))\n        integrityStream.on('size', s => pipeline.emit('size', s))\n        res = new fetch.Response(pipeline, res)\n        // set an explicit flag so we know if our response body will emit integrity and size\n        res.body.hasIntegrityEmitter = true\n      }\n\n      res.headers.set('x-fetch-attempts', attemptNum)\n\n      // do not retry POST requests, or requests with a streaming body\n      // do retry requests with a 408, 420, 429 or 500+ status in the response\n      const isStream = Minipass.isStream(req.body)\n      const isRetriable = req.method !== 'POST' &&\n          !isStream &&\n          ([408, 420, 429].includes(res.status) || res.status >= 500)\n\n      if (isRetriable) {\n        if (typeof options.onRetry === 'function') {\n          options.onRetry(res)\n        }\n\n        return retryHandler(res)\n      }\n\n      return res\n    } catch (err) {\n      const code = (err.code === 'EPROMISERETRY')\n        ? err.retried.code\n        : err.code\n\n      // err.retried will be the thing that was thrown from above\n      // if it's a response, we just got a bad status code and we\n      // can re-throw to allow the retry\n      const isRetryError = err.retried instanceof fetch.Response ||\n        (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type))\n\n      if (req.method === 'POST' || isRetryError) {\n        throw err\n      }\n\n      if (typeof options.onRetry === 'function') {\n        options.onRetry(err)\n      }\n\n      return retryHandler(err)\n    }\n  }, options.retry).catch((err) => {\n    // don't reject for http errors, just return them\n    if (err.status >= 400 && err.type !== 'system') {\n      return err\n    }\n\n    throw err\n  })\n}\n\nmodule.exports = remoteFetch\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}